#Chuwa Homework 16 MING HAO(Howard) Lee 

## 1. List all of the new learned annotations to your annotations.md

## 2. What is selenium?

Selenium is a powerful tool for automating web browsers. It is primarily used for testing web applications but can be used for various web browser automation tasks. Here are the key points:

### 1. Purpose:
- Automates web browsers for testing and other web-related tasks.

### 2. Components:
- **Selenium WebDriver**: Automates browser actions.
- **Selenium IDE**: A Chrome and Firefox extension for recording and playing back tests.
- **Selenium Grid**: Allows running tests on different machines and browsers simultaneously.

### 3. Languages Supported:
- Java, C#, Python, Ruby, JavaScript, and Kotlin.

### 4. Browsers Supported:
- Chrome, Firefox, Internet Explorer, Safari, and Edge.

### 5. Use Cases:
- Automated functional testing.
- Regression testing.
- Web scraping.

### 6. Advantages:
- Open-source.
- Supports multiple programming languages and browsers.
- Can be integrated with various testing frameworks and CI/CD tools.

### 7. Disadvantages:
- Requires programming knowledge.
- Can be complex to set up and maintain.
- Limited support for handling advanced web elements (like captcha).


## 3. What is cucumber?

Cucumber is a tool for running automated tests written in plain language. It bridges the gap between technical and non-technical stakeholders by allowing them to understand test scenarios. Here are the key points:

### 1. Purpose:
- Facilitates Behavior-Driven Development (BDD) by running tests written in plain language.

### 2. Core Features:
- **Gherkin Syntax**: Uses a simple language syntax for writing test scenarios.
- **Feature Files**: Contain test scenarios written in Gherkin.

### 3. Languages Supported:
- Java, Ruby, JavaScript, Kotlin, and others.

### 4. Integration:
- Works with various testing frameworks and tools like JUnit, TestNG, and Selenium.

### 5. Advantages:
- Enhances collaboration between developers, testers, and business stakeholders.
- Easy to understand and write test cases.
- Encourages writing clear and concise requirements.

### 6. Disadvantages:
- Can become complex with large projects.
- May require significant maintenance.
- Depends on a strong understanding of BDD principles.

### 7. Use Cases:
- Automated acceptance testing.
- Functional testing.
- Regression testing.


## 4. What is JMeter?
JMeter is an open-source tool used for performance and load testing of web applications and other services. Here are the key points:

### 1. Purpose:
- Measures and analyzes the performance of web applications and various services.

### 2. Core Features:
- **Load Testing**: Simulates heavy loads on servers, networks, or objects.
- **Performance Testing**: Measures response times and throughput.
- **Functional Testing**: Tests the functionality of web applications.

### 3. Supported Protocols:
- HTTP, HTTPS, FTP, JDBC, JMS, SOAP, REST, and more.

### 4. Components:
- **Thread Groups**: Simulate user requests.
- **Samplers**: Perform the actual requests to the server.
- **Listeners**: Collect and display test results.
- **Config Elements**: Set up default values and variables for testing.

### 5. Advantages:
- Open-source and free.
- Extensible with plugins.
- Supports various types of applications and protocols.
- Provides detailed and customizable reporting.

### 6. Disadvantages:
- Can be resource-intensive.
- Requires a good understanding of performance testing concepts.
- Limited real-time monitoring capabilities.

### 7. Use Cases:
- Stress testing.
- Load testing.
- Performance benchmarking.
- Functional testing.


## 5. What is the lifecircle of Junit?
JUnit is a popular framework for writing and running tests in Java. The lifecycle of a JUnit test involves several stages, ensuring tests are set up, executed, and cleaned up properly. Here are the key points:

### 1. Annotations:
Control the lifecycle methods in JUnit.

- `@BeforeAll`: Runs once before any test methods in the class. Used for initializing shared resources.
- `@BeforeEach`: Runs before each test method. Used for setting up test-specific resources.
- `@Test`: Defines the actual test method.
- `@AfterEach`: Runs after each test method. Used for cleaning up test-specific resources.
- `@AfterAll`: Runs once after all test methods in the class. Used for cleaning up shared resources.

### 2. Lifecycle Stages:
- **Setup (BeforeAll)**: Initialize resources that are expensive to create and shared across tests.
- **Setup (BeforeEach)**: Prepare the test environment, reset state, and initialize resources specific to each test.
- **Test Execution (Test)**: Execute the test logic, including assertions to verify expected outcomes.
- **Teardown (AfterEach)**: Clean up resources, reset states specific to the test, and ensure no side effects between tests.
- **Teardown (AfterAll)**: Release shared resources and perform any final cleanup activities.

### 3. Execution Order:
- `@BeforeAll`
- `@BeforeEach`
- `@Test`
- `@AfterEach`
- `@AfterAll`

### 4. Best Practices:
- Keep test methods independent.
- Use meaningful names for test methods.
- Ensure cleanup in `@AfterEach` and `@AfterAll` to prevent resource leaks.
- Group related tests in test classes.

## 6. Is @BeforeAll method should be Class level(static)?
Yes, the `@BeforeAll` method in JUnit should be static. This is because `@BeforeAll` methods are meant to run once before any test methods in the class are executed, and being static ensures they are associated with the class itself rather than any instance of the class. This allows JUnit to call the method before creating any instances of the test class.

Here are the key points:

- **Static Requirement**: The `@BeforeAll` method must be static (`static` keyword).
- **Purpose**: It initializes resources shared across all tests and runs only once before all test methods in the class.
- **Example**:
  ```java
  import org.junit.jupiter.api.BeforeAll;
  import org.junit.jupiter.api.Test;

  class MyTests {

      @BeforeAll
      static void setUpBeforeClass() {
          // Initialization code here
      }

      @Test
      void testMethod() {
          // Test code here
      }
  }
  ```
- **JUnit 5 Note**: In JUnit 5, if you do not want to use static methods for `@BeforeAll`, you can use the `@TestInstance(TestInstance.Lifecycle.PER_CLASS)` annotation on the test class, which changes the test instance lifecycle to per class, allowing non-static `@BeforeAll` and `@AfterAll` methods.


## 7. What is Mockito? and what is its limitations? what kind of tools can give help?
### Purpose:
- Creates mock objects for unit testing.
- Verifies interactions between objects.

### Core Features:
- Mock Creation
- Stub Methods
- Verification
- Spying
- Argument Captors

### Limitations:
- Cannot mock static methods directly.
- Cannot mock final classes/methods (without configuration).
- Cannot mock private methods.
- Cannot mock constructor calls.
- Complex dependencies require intricate setup.
- Limited to Java.

### Tools to Overcome Limitations:
- PowerMock: Mocks static methods, constructors, final classes.
- JUnit: Testing framework, integrates with Mockito.
- TestNG: Advanced testing framework.
- AssertJ: Fluent assertion syntax.
- Spring Boot Test: Integration testing for Spring applications.



## 8. What is @Mock and what is @InjectMocks?
## @Mock and @InjectMocks in Mockito

### @Mock:
- **Purpose**: Creates and injects a mock instance of a class or interface.
- **Usage**: Annotates fields in a test class that should be mocked.
- **Example**:
    ```java
    @Mock
    private MyDependency myDependency;
    ```

### @InjectMocks:
- **Purpose**: Injects mock objects (annotated with `@Mock`) into the class under test.
- **Usage**: Annotates the class being tested to automatically inject its dependencies.
- **Example**:
    ```java
    @InjectMocks
    private MyService myService;
    ```
### Example of Using `@Mock` and `@InjectMocks` Together:
```Java
  import static org.mockito.Mockito.*;
  import org.junit.jupiter.api.BeforeEach;
  import org.junit.jupiter.api.Test;
  import org.mockito.InjectMocks;
  import org.mockito.Mock;
  import org.mockito.MockitoAnnotations;
  
  class MyServiceTest {
    
    @Mock
    private MyDependency myDependency;
    
    @InjectMocks
    private MyService myService;
    
    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }
    
    @Test
    void testServiceMethod() {
        when(myDependency.someMethod()).thenReturn("mocked response");
        
        String result = myService.performAction();
        
        verify(myDependency).someMethod();
        assertEquals("mocked response", result);
    }
  }
```
- `@Mock` creates a mock instance of `MyDependency`.
- `@InjectMocks` injects this mock into `myService`, the class under test.


## 9. What is the stubbing (define behaviors)?
### Stubbing:

- **Purpose**: Define the behavior of mock objects' methods.
- **Usage**: Specify what the mock should return when its methods are called.
- **Example**: Use `when(...).thenReturn(...)` to define the behavior.

### Key Points:

1. **Basic Stubbing**:
   - Define return values for method calls.
```Java
when(mockObject.method()).thenReturn(value);
```

2. **Stubbing with Arguments**:
   - Specify behavior based on method arguments.
```Java
when(mockObject.method(arg)).thenReturn(value);
```

3. **Stubbing with Multiple Returns**:
   - Define multiple return values for sequential calls.
```Java
when(mockObject.method()).thenReturn(value1, value2, value3);
```

4. **Throwing Exceptions**:
   - Specify exceptions to be thrown.
```Java
when(mockObject.method()).thenThrow(new RuntimeException());
```
5. **Using Answer**:
   - Define custom behavior using `Answer` interface.
```Java
when(mockObject.method()).thenAnswer(invocation -> {
    Object arg = invocation.getArgument(0);
    return "response for " + arg;
});
```
### Example: 
```Java
import static org.mockito.Mockito.*;
import org.junit.jupiter.api.Test;

class MyServiceTest {

    @Test
    void testStubbing() {
        MyDependency mockDependency = mock(MyDependency.class);

        // Basic stubbing
        when(mockDependency.someMethod()).thenReturn("mocked response");

        // Stubbing with arguments
        when(mockDependency.methodWithArgs(anyString())).thenReturn("response based on arg");

        // Throwing exception
        when(mockDependency.methodThatThrows()).thenThrow(new RuntimeException("error"));

        // Using Answer for custom behavior
        when(mockDependency.customMethod(anyInt())).thenAnswer(invocation -> {
            int arg = invocation.getArgument(0);
            return "response for " + arg;
        });

        // Usage
        String result = mockDependency.someMethod();
        System.out.println(result); // Output: mocked response

        result = mockDependency.methodWithArgs("test");
        System.out.println(result); // Output: response based on arg

        try {
            mockDependency.methodThatThrows();
        } catch (RuntimeException e) {
            System.out.println(e.getMessage()); // Output: error
        }

        result = mockDependency.customMethod(5);
        System.out.println(result); // Output: response for 5
    }
}
```

## 10. What is Mockito ArgumentMatchers?### Mockito ArgumentMatchers

**ArgumentMatchers** in Mockito are used to specify flexible and dynamic arguments when stubbing methods or verifying interactions with mock objects. They allow you to define behaviors and verifications without hardcoding specific values, making tests more robust and easier to maintain.

### Key Points:

1. **Purpose**:
   - Provides flexibility in specifying arguments for methods.
   - Facilitates the stubbing and verification of methods with varying or unknown arguments.

2. **Common ArgumentMatchers**:
   - `any()`: Matches any object.
   - `any(Class<T> type)`: Matches any object of the given type.
   - `anyString()`: Matches any `String`.
   - `anyInt()`: Matches any `int`.
   - `anyList()`: Matches any `List`.
   - `eq(T value)`: Matches an object that is equal to the given value.
   - `isA(Class<T> type)`: Matches an object of the specified type.
   - `contains(String substring)`: Matches a `String` containing the given substring.
   - `argThat(Matcher<T> matcher)`: Matches an argument that satisfies the given custom matcher.

3. **Usage in Stubbing**:
   - Define return values for method calls.
```Java
when(mockObject.method(anyString())).thenReturn("response");
```

4. **Usage in Verification**:
   - Verify method calls with specific arguments.
```Java
verify(mockObject).method(anyInt());
```
**Example**
```Java
import static org.mockito.Mockito.*;
import static org.mockito.ArgumentMatchers.*;
import org.junit.jupiter.api.Test;

class MyServiceTest {

    @Test
    void testArgumentMatchers() {
        MyDependency mockDependency = mock(MyDependency.class);

        // Stubbing using ArgumentMatchers
        when(mockDependency.methodWithArgs(anyString(), anyInt())).thenReturn("stubbed response");

        // Custom matcher example
        when(mockDependency.methodWithArgs(argThat(arg -> arg.startsWith("test")), eq(5)))
            .thenReturn("custom response");

        // Using the stubbed method
        String result = mockDependency.methodWithArgs("any string", 10);
        System.out.println(result); // Output: stubbed response

        result = mockDependency.methodWithArgs("test123", 5);
        System.out.println(result); // Output: custom response

        // Verification using ArgumentMatchers
        mockDependency.methodWithArgs("verify this", 15);
        verify(mockDependency).methodWithArgs(anyString(), eq(15));
    }
}
```
### Summary:

- **ArgumentMatchers** provide flexible argument matching in Mockito.
- **Common Matchers**: `any()`, `anyString()`, `anyInt()`, `eq()`, `isA()`, `contains()`, `argThat()`.
- **Usage**: Enhances stubbing and verification of methods with dynamic or unspecified arguments.


## 11. What is Hamcrest Matchers?
A library used for writing readable and flexible assertions in tests, often used with testing frameworks like JUnit.

#### Key Points:

1. **Purpose**: Provides a set of matchers for making assertions more readable and expressive.

2. **Common Matchers**:
   - `equalTo()`: Checks if values are equal.
   - `not()`: Inverts the matcher.
   - `is()`: Improves readability (e.g., `is(equalTo())`).
   - `hasItem()`: Checks if a collection contains an item.
   - `containsString()`: Checks if a string contains a substring.
   - `startsWith()`: Checks if a string starts with a substring.
   - `greaterThan()`, `lessThan()`: Compares values.
   - `instanceOf()`: Checks if an object is an instance of a class.

3. **Integration**: Commonly used with JUnit for enhanced readability of test assertions.

#### Summary:

- **Hamcrest Matchers**: Library for readable and flexible assertions.
- **Common Matchers**: `equalTo()`, `not()`, `is()`, `hasItem()`, `containsString()`, `startsWith()`, `greaterThan()`, `instanceOf()`.
- **Usage**: Enhances readability and expressiveness of test assertions, often used with JUnit.


## 12. Do you know @spy? what is difference between @spy and @Mock?
### @Spy:
- **Purpose**: Partially mock an existing instance, allowing real methods to be called unless stubbed.
- **Usage**: Use when you need to call some real methods and mock others.
- **Example**:
  ```Java
  @Spy
  private MyClass myClass = new MyClass();
  ```

### @Mock:
- **Purpose**: Create a mock object with no real method invocations, only behavior defined by stubbing.
- **Usage**: Use when you need to mock all methods of a class or interface.
- - **Example**:
  ```Java
  @Mock
  private MyClass myClass;
  ```

### Key Differences:
- **Real Method Invocation**:
  - `@Spy`: Calls real methods unless explicitly stubbed.
  - `@Mock`: Does not call any real methods unless explicitly stubbed.
- **Usage**:
  - `@Spy`: For partial mocking.
  - `@Mock`: For complete mocking.

### Summary:
- **@Spy**: Partially mocks an object, allowing real methods to be called.
- **@Mock**: Fully mocks an object, with no real method invocations.
- **Difference**: `@Spy` calls real methods unless stubbed; `@Mock` does not call real methods unless stubbed.


## 13. What is assertion?
### Assertion
**Assertion**: A statement in a test that checks if a condition is true. Used to verify that the code behaves as expected.

#### Key Points:
1. **Purpose**:
   - Ensures code correctness by validating expected outcomes.
   - Detects and reports errors in code during testing.

2. **Common Assertions**:
   - Equality: `assertEquals(expected, actual)`
   - Truth: `assertTrue(condition)`
   - Falsehood: `assertFalse(condition)`
   - Nullity: `assertNull(object)`, `assertNotNull(object)`
   - Same Object: `assertSame(expected, actual)`, `assertNotSame(unexpected, actual)`

3. **Usage Example (JUnit)**:

```java
import static org.junit.jupiter.api.Assertions.*;

@Test
void testMethod() {
    int result = add(2, 3);
    assertEquals(5, result);
    assertTrue(result > 0);
}
```
**Summary**:
- **Assertion**: Checks if a condition is true in tests.
- **Purpose**: Validates expected outcomes, ensuring code correctness.
- **Common Assertions**: `assertEquals`, `assertTrue`, `assertFalse`, `assertNull`, `assertNotNull`, `assertSame`.


## 14. If you have developed a new feature, how many types of tests for this feature? and what kind of tests are written by you? what is the purpose of each type of tests?

- **Unit Tests**: Validate individual components in isolation.
- **Integration Tests**: Ensure components work together.
- **Functional Tests**: Verify the feature's functionality from the user's perspective.
- **End-to-End Tests**: Validate entire application workflows.
- **Acceptance Tests**: Ensure the feature meets business requirements.
- **Performance Tests**: Measure responsiveness and scalability under load.
- **Security Tests**: Identify vulnerabilities and ensure security.
- **Regression Tests**: Ensure new changes do not break existing functionality.


## 15. Add unit test for CommentServiceImpl, the coverage should be 100%.
Assuming `CommentServiceImpl` has methods like `addComment`, `getCommentById`, `updateComment`, and `deleteComment`, here's a basic example:

### CommentServiceImpl.java
```Java
public class CommentServiceImpl implements CommentService {

    private final CommentRepository commentRepository;

    public CommentServiceImpl(CommentRepository commentRepository) {
        this.commentRepository = commentRepository;
    }

    @Override
    public Comment addComment(Comment comment) {
        return commentRepository.save(comment);
    }

    @Override
    public Comment getCommentById(Long id) {
        return commentRepository.findById(id).orElseThrow(() -> new CommentNotFoundException(id));
    }

    @Override
    public Comment updateComment(Long id, Comment commentDetails) {
        Comment comment = getCommentById(id);
        comment.setText(commentDetails.getText());
        return commentRepository.save(comment);
    }

    @Override
    public void deleteComment(Long id) {
        Comment comment = getCommentById(id);
        commentRepository.delete(comment);
    }
}
```

### CommentServiceImplTest.java
```Java
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Optional;

@ExtendWith(MockitoExtension.class)
class CommentServiceImplTest {

    @Mock
    private CommentRepository commentRepository;

    @InjectMocks
    private CommentServiceImpl commentService;

    private Comment comment;

    @BeforeEach
    void setUp() {
        comment = new Comment();
        comment.setId(1L);
        comment.setText("Sample comment");
    }

    @Test
    void addComment() {
        when(commentRepository.save(any(Comment.class))).thenReturn(comment);
        Comment createdComment = commentService.addComment(comment);
        assertNotNull(createdComment);
        assertEquals("Sample comment", createdComment.getText());
    }

    @Test
    void getCommentById() {
        when(commentRepository.findById(1L)).thenReturn(Optional.of(comment));
        Comment foundComment = commentService.getCommentById(1L);
        assertNotNull(foundComment);
        assertEquals(1L, foundComment.getId());
    }

    @Test
    void getCommentById_NotFound() {
        when(commentRepository.findById(1L)).thenReturn(Optional.empty());
        assertThrows(CommentNotFoundException.class, () -> commentService.getCommentById(1L));
    }

    @Test
    void updateComment() {
        Comment updatedComment = new Comment();
        updatedComment.setText("Updated comment");

        when(commentRepository.findById(1L)).thenReturn(Optional.of(comment));
        when(commentRepository.save(any(Comment.class))).thenReturn(updatedComment);

        Comment result = commentService.updateComment(1L, updatedComment);
        assertNotNull(result);
        assertEquals("Updated comment", result.getText());
    }

    @Test
    void deleteComment() {
        when(commentRepository.findById(1L)).thenReturn(Optional.of(comment));
        doNothing().when(commentRepository).delete(comment);
        
        commentService.deleteComment(1L);
        
        verify(commentRepository, times(1)).delete(comment);
    }
}
```

## 16. Write Integration tests for PostController. The tests should cover all scenarios.

Assumptions
- The `PostController` handles basic CRUD operations for a `Post` entity.
- The controller has endpoints for creating, reading, updating, and deleting posts.

### PostController.java
```Java
@RestController
@RequestMapping("/posts")
public class PostController {

    @Autowired
    private PostService postService;

    @PostMapping
    public ResponseEntity<Post> createPost(@RequestBody Post post) {
        Post createdPost = postService.createPost(post);
        return new ResponseEntity<>(createdPost, HttpStatus.CREATED);
    }

    @GetMapping("/{id}")
    public ResponseEntity<Post> getPostById(@PathVariable Long id) {
        Post post = postService.getPostById(id);
        return new ResponseEntity<>(post, HttpStatus.OK);
    }

    @PutMapping("/{id}")
    public ResponseEntity<Post> updatePost(@PathVariable Long id, @RequestBody Post postDetails) {
        Post updatedPost = postService.updatePost(id, postDetails);
        return new ResponseEntity<>(updatedPost, HttpStatus.OK);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletePost(@PathVariable Long id) {
        postService.deletePost(id);
        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }

    @GetMapping
    public ResponseEntity<List<Post>> getAllPosts() {
        List<Post> posts = postService.getAllPosts();
        return new ResponseEntity<>(posts, HttpStatus.OK);
    }
}
```
### PostControllerIntegrationTest.java
```Java
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.*;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import java.util.List;

@SpringBootTest
@AutoConfigureMockMvc
class PostControllerIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @BeforeEach
    void setUp() {
        // Set up initial data if necessary
    }

    @Test
    void createPost() throws Exception {
        Post post = new Post();
        post.setTitle("New Post");
        post.setContent("This is a new post.");

        mockMvc.perform(post("/posts")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(post)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.title").value("New Post"))
                .andExpect(jsonPath("$.content").value("This is a new post."));
    }

    @Test
    void getPostById() throws Exception {
        // Assuming a post with ID 1 exists
        mockMvc.perform(get("/posts/{id}", 1L))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id").value(1L))
                .andExpect(jsonPath("$.title").exists())
                .andExpect(jsonPath("$.content").exists());
    }

    @Test
    void updatePost() throws Exception {
        Post postDetails = new Post();
        postDetails.setTitle("Updated Post");
        postDetails.setContent("This post has been updated.");

        mockMvc.perform(put("/posts/{id}", 1L)
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(postDetails)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.title").value("Updated Post"))
                .andExpect(jsonPath("$.content").value("This post has been updated."));
    }

    @Test
    void deletePost() throws Exception {
        // Assuming a post with ID 1 exists
        mockMvc.perform(delete("/posts/{id}", 1L))
                .andExpect(status().isNoContent());
    }

    @Test
    void getAllPosts() throws Exception {
        mockMvc.perform(get("/posts"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$").isArray());
    }
}
```

