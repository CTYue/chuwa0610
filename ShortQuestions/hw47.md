# HW16

1. List all of the new learned annotations to your annotations.md

   see annotation.md [here](annotation.md)
2. what is selenium?
   Selenium is a powerful tool for controlling web browsers through programs and performing browser automation. It is primarily used for automating web applications for testing purposes, but is also capable of any web-based administrative tasks.
3. what is cucumber?
   Cucumber is a software tool for testing other software. It runs automated acceptance tests written in a behavior-driven development (BDD) style. At its core, Cucumber reads executable specifications written in plain language and validates that the software does what those specifications say. The main advantage of Cucumber is that it facilitates communication between business and technical teams by using language that is easy to understand.
4. what is JMeter?
   JMeter is an open-source load testing tool. It is primarily used for analyzing and measuring the performance of a variety of services, with a focus on web applications. JMeter can simulate multiple users with concurrent threads, create a heavy load against web or other applications to test strength or analyze overall performance under different load types.
5. What is the life circle of Junit?
   1. `@BeforeAll` – **Class level Setup**. This annotation is used for static methods which run once before any of the test methods in the class. It’s often used for expensive setup operations.
   2. `@BeforeEach` – **Setup**. This method runs before each test execution. It is used to prepare the test environment (e.g., open a database connection, initialize a class).
   3. `@Test` – **Test Execution**. These are annotated with @Test and contain the code to perform specific tests. This is where the actual tests are run.
   4. `@AfterEach` – **Cleanup**. This method runs after each test execution. It is typically used to clean up the test environment (e.g., close database connections).
   5. `@AfterAll` – **Class level Cleanup**. This is used for static methods to run once after all tests in the class have been executed. It’s often used for cleaning up expensive setup operations.  
   [more](https://howtodoinjava.com/junit5/junit-5-test-lifecycle/)
6. Is @BeforeAll method should be Class level (static)?
   Yes, the `@BeforeAll` annotation is used to signify that the annotated method should be run before all other tests in the current test class. It must be applied to a static method when used in a standard test class.
7. What is Mockito? and what are its limitations? what kind of tools can give help?
   > Mockito is a popular mocking framework for Java that is used to develop effective unit tests for applications. It is used to mock interfaces so that a dummy functionality can be added to a mock interface that can be used in unit testing. Mockito allows developers to create and configure mock objects. Using Mockito, you can mock away external dependencies and insert the mocks into the code under test. This simplifies testing by isolating the unit of interest and controlling its interactions explicitly.

   **Limitations of Mockito:** Cannot Mock Final Methods, Constructors, Private, Static Methods.

   **Solution:** Using PowerMockito which is a PowerMock's extension API to support Mockito. It provides capabilities to work with the Java Reflection API in a simple way to overcome the problems of Mockito, such as the lack of ability to mock final, static or private methods.
8. What is @Mock and what is @InjectMocks?
   * `@Mock`:
    - Creates and injects a mock instance of a field.
    - Used to define and configure the behavior of mocks.
    - Does not instantiate the class under test.
   * `@InjectMocks`:
    - Creates an instance of the class under test.
    - Automatically injects mocks (created with @Mock or @Spy) into the class under test.
    - Ensures that the class under test has all its dependencies properly mocked and injected.
9. What is the stubbing (define behaviors)?  
   > stubbing refers to the practice of defining specific behaviors of mocks during the setup phase of a test.
10. what is Mockito ArgumentMatchers  
    > Mockito ArgumentMatchers allow providing flexible argument matching when stubbing methods. Instead of requiring exact values, matchers can specify conditions that arguments must meet to match the stubbing.
11. what is Hamcrest Matchers
    > Hamcrest is a framework for writing matcher objects, allowing 'match' rules to be defined declaratively. While often used in conjunction with Mockito for asserting conditions in tests, Hamcrest provides a rich set of matchers beyond simple equality. It is widely used in assertions to provide more readable and flexible validation logic.
12. do you know @spy? what is the difference between @spy and @Mock?

    | `@spy`                                                                                                                                                                                   | `@Mock`                                                                                                                                                                                                                     |
    |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    | creates a spy on a real object, meaning the actual methods are called unless they are explicitly overridden                                                                              | creates a completely mock version of the class with **no methods** actually being executed                                                                                                                                  |
    | Calling a method on a `@Spy` will execute the real method unless it has been stubbed.                                                                                                    | Calling a method on a `@Mock` object does not actually execute the real method unless it's explicitly stubbed to do so.                                                                                                     |
    | Use @Spy when you need to test most of the real object's functionality but override some behavior. It’s useful when testing or debugging real implementations with slight modifications. | Use @Mock when you want to simulate the behavior of complex dependencies and do not want any actual method logic to be executed. This is particularly useful in unit testing where you need to isolate the unit under test. |
13. What is assertion?
    > Assertion is a statement that checks whether a specified condition is true.
14. If you have developed a new feature, how many types of tests for this feature? and what kind of tests are written by you? what is the purpose of each type of tests?
    1. Unit test (Me): To test individual components or functions in isolation from the rest of the application. The goal is to ensure that each part performs as expected independently.
    2. Functional test (Me): To test the feature by simulating real-world scenarios to ensure it meets the specified requirements. 
    3. Integration test (Me): To test the interactions between integrated components or systems to ensure they work together as expected.
    4. smoke test (Me): To test the entire flow.
    5. Regression test (QA): To test if existing functionalities still work
    6. End-to-End test (QA): To test the entire flow
    7. Performance Tests (performance engineers): o ensure that the new feature performs well under expected and peak load conditions. This includes testing response times, throughput, and stability.
    8. Security Tests (QA):  To identify vulnerabilities in the new feature, such as injection attacks, breaches of data privacy, and other security threats.
15. Add unit test for CommentServiceImpl, the coverage should be 100%.
16. write Integration tests for PostController. The tests should cover all scenarios.