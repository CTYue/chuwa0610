# howework 43

## Yirun Wang

### 1. List all of the annotations you learned from class and homework to annotaitons.md (your own cheatsheet).

@Configuration + @ComponentScan + @Component + @Autowire

@Configuration + @ComponentScan + @Bean + @Autowire

**@Configuration**:

- **Define Configuration Classes**: A class annotated with `@Configuration` is used to define beans and configuration settings for the application.

- **Support for `@Bean` Annotation**: Methods within a `@Configuration` class that are annotated with `@Bean` define and configure individual beans.

- **Java-based Configuration**: Provides a type-safe and easily refactorable alternative to traditional XML configuration.

**@ComponentScan**:

- **Package Scanning**: `@ComponentScan` tells Spring where to look for annotated components to be registered as beans.

- **Automatic Detection**: It automatically detects classes annotated with Spring stereotypes (`@Component`, `@Service`, `@Repository`, `@Controller`) and registers them as beans.

- **Customizable Base Packages**: You can specify which packages to scan, allowing for a flexible configuration of bean discovery.

**@Component**:

- **Bean Declaration**: Marks a class as a Spring-managed bean.

- **Automatic Scanning**: Spring can automatically detect and register classes annotated with `@Component` during a classpath scan.

- **Usage**: Can be used on any class that you want Spring to manage, making it a generic stereotype for any Spring-managed component.

**@Autowire**:

- **Automatic Dependency Injection**: `@Autowired` allows Spring to automatically resolve and inject the required dependencies.

- **Types of Injection**: It can be used with constructors, setter methods, and directly on fields.

- **Simplifies Wiring**: Reduces the need for explicit configuration in XML or Java configuration classes.

**@Bean**:

- **Bean Declaration**: Methods annotated with `@Bean` return an object that Spring should register as a bean in the application context.

- **Method-Level Annotation**: Applied to methods within a class annotated with `@Configuration`.

- **Customization and Initialization**: Allows for custom initialization of the bean, beyond what is achievable with component scanning.

### 2. Compare Spring and Springboot? What are the benfits of Srpingboot?

| Feature                              | Spring Framework                                             | Spring Boot                                                  |
| ------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Core Features**                    | Provides core features like dependency injection, AOP, and transaction management | Builds on top of Spring Framework to offer additional conveniences |
| **Configuration**                    | Requires extensive configuration via XML or Java annotations | Provides auto-configuration to minimize manual configuration |
| **Flexibility**                      | Offers great flexibility and control, allowing extensive customization | Provides opinionated defaults while still allowing customization |
| **Setup**                            | Involves a lot of manual configuration, which can be time-consuming | Simplifies setup with embedded servers and starter dependencies |
| **Project Structure**                | Requires manual setup of project structure, web servers, and configurations | Automatically configures project structure and dependencies  |
| **Auto-Configuration**               | Not available                                                | Provides auto-configuration for rapid setup                  |
| **Embedded Servers**                 | Not provided                                                 | Comes with embedded web servers (Tomcat, Jetty, Undertow)    |
| **Opinionated Defaults**             | Not opinionated; leaves decisions to the developer           | Offers opinionated defaults for quick setup                  |
| **Starter Dependencies**             | Not available                                                | Simplifies dependency management with pre-configured starters |
| **Production-Ready Features**        | Requires manual setup                                        | Includes metrics, health checks, and externalized configuration out-of-the-box |
| **Rapid Development**                | More setup required before starting development              | Enables rapid prototyping and development with minimal setup |
| **Microservices Support**            | Requires additional setup for microservices                  | Well-suited for microservices with built-in support          |
| **Simplified Dependency Management** | Manual management of dependencies                            | Provides starter dependencies for common functionalities     |
| **Community and Ecosystem**          | Large and active community                                   | Large and active community with additional Spring Boot-specific resources |

### 3. What is IoC and What is DI?

**IOC: Inversion of Control**

Instead of the application creating and managing objects directly, with IoC, the control of object creation and management is inverted from the application to the Spring container.

1. **DI: Dependency Injection**

Dependency Injection is a core implementation of IoC where dependencies of a component are injected into it by an external entity, typically a framework like Spring. 

- **Constructor Injection**

  ```java
  public class MyComponent {
      private final MyService myService;
  
      public MyComponent(MyService myService) {
          this.myService = myService;
      }
  }
  
  ```

- **Setter Injection**

  ```java
  public class MyComponent {
      private MyService myService;
  
      public void setMyService(MyService myService) {
          this.myService = myService;
      }
  }
  
  ```

- **Field Injection**

  ```java
  public class MyComponent {
      @Autowired
      private MyService myService;
  }
  
  ```

  

2. Service Locator Pattern

The Service Locator pattern involves using a central registry known as the "service locator" that manages the lifecycle and dependencies of application components. Spring's ApplicationContext acts as a service locator, providing access to configured beans.

3. Factory Pattern

The Factory Pattern involves creating a factory class responsible for creating instances of objects. In Spring, bean definitions in XML or Java configuration classes (`@Bean` methods) act as factories for creating and configuring beans.

4. Template Method Pattern

The Template Method Pattern defines the skeleton of an algorithm in a method, deferring some steps to subclasses. In Spring, this pattern is used in various template classes like `JdbcTemplate` for JDBC operations or `RestTemplate` for RESTful web services.

### 4. What is @CompnonentScan?

The `@ComponentScan` annotation is used in Spring to specify the base packages to scan for Spring-managed components such as `@Component`, `@Service`, `@Repository`, and `@Controller`. It enables Spring to automatically discover and register Spring beans (components) from specified base packages.

```java
@Configuration
@ComponentScan(basePackages = "com.example")
public class AppConfig {
    // Configuration settings
}

```

**basePackageClasses**: Allows specifying classes as a reference point for package scanning.

```java
@ComponentScan(basePackageClasses = {MyComponent.class, MyService.class})
```

### 5. What is @SpringbootApplication?

`@SpringBootApplication` is a convenience annotation provided by Spring Boot that combines `@Configuration`, `@EnableAutoConfiguration`, and `@ComponentScan`.

**Configuration**: Marks a class as a configuration class, similar to XML configuration in traditional Spring applications.

**Auto-Configuration**: Enables Spring Boot's auto-configuration mechanism, which automatically configures the Spring application based on dependencies and classpath settings.

**Component Scan**: Enables component scanning to automatically discover and register Spring-managed beans (components) from specified base packages.

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MyApplication {

    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}

```

`@SpringBootApplication` on `MyApplication` class configures the application to start with Spring Boot's auto-configuration and component scanning features.

### 6. How many ways to define a bean? Provide code examples.

1. XML Configuration 

   Traditional approach, provides explicit bean definitions.

   In applicationContext.xml

   ```xml
   <bean id="myService" class="com.example.MyServiceImpl"/>
   ```

2. @Configuration - Java Configuration Class

   `@Configuration` and `@Bean` annotations to define beans.

   ```java
   @Configuration
   public class AppConfig {
   
       @Bean
       public MyService myService() {
           return new MyServiceImpl();
       }
   }
   
   ```

3. @ComponentScan - Component Scanning

   Components annotated with `@Component`, `@Service`, `@Repository`, or `@Controller` are automatically registered as beans through component scanning.

   ```java
   @Component
   public class MyComponent {
       // Bean logic
   }
   ```

4. @Bean - Factory 

   Factory methods annotated with `@Bean` in `@Configuration` classes can define beans programmatically.

   ```java
   @Configuration
   public class AppConfig {
   
       @Bean
       public MyService myService() {
           return new MyServiceImpl();
       }
   
       @Bean
       public DataSource dataSource() {
           // Initialize and configure DataSource bean
           DataSource dataSource = new DataSource();
           dataSource.setUrl("jdbc:mysql://localhost:3306/mydatabase");
           dataSource.setUsername("root");
           dataSource.setPassword("password");
           return dataSource;
       }
   }
   ```

5. XML with Annotations

   Integrates existing XML configurations into Java-based Spring applications.

   ```java
   @Configuration
   @ImportResource("classpath:applicationContext.xml")
   public class AppConfig {
       // Java-based configuration
   }
   ```

### 7. What is default bean name for @Component and @Bean ? Also compare @Component and @Bean .

The default bean name is derived from the name of the annotated class or method.

Or rewrite explicitly:

```java
@Configuration
public class AppConfig {

    @Bean(name = "customService")
    public MyService myService() {
        return new MyServiceImpl();
    }
}

```

**Automatic Detection**: `@Component` allows for automatic detection and registration of Spring-managed components, while `@Bean` requires explicit configuration within `@Configuration` classes.

**Scope Control**: `@Bean` provides more control over bean scope through annotations like `@Scope`, whereas `@Component` defaults to singleton scope.

**Usage Context**: Use `@Component` for general-purpose Spring-managed components, and `@Bean` for fine-grained control over bean instantiation and configuration, especially when dealing with third-party or non-Spring classes.

**Configuration**: `@Bean` is typically used within Java-based configuration classes (`@Configuration`), whereas `@Component` is used directly on classes that need to be managed by Spring.

### 8. Compare @component and @service, @repository, @controller?

**@Component**

Marks a Java class as a Spring component to be automatically detected and registered as a bean.

**@Service**

Specialized `@Component` annotation indicating that the annotated class is a service layer component in the business logic.

Often manages transactions, ensuring that a series of operations either complete successfully or roll back in case of errors.

```java
@Service
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Transactional
    public User createUser(String username, String email) {
        User user = new User();
        user.setUsername(username);
        user.setEmail(email);
        return userRepository.save(user);
    }

    public User getUserById(Long id) {
        return userRepository.findById(id).orElse(null);
    }
}

```

**@Repository**

Specialized `@Component` annotation indicating that the annotated class is a data access component (DAO) for storing and retrieving data.

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    User findByUsername(String username);
}
```

**@Controller**

Specialized `@Component` annotation indicating that the annotated class serves as a controller in a Spring MVC application.

Used in the presentation layer to handle HTTP requests and responses.

```java
@Controller
public class MyController {
    @RequestMapping("/home")
    public String home() {
        return "index";
    }
}

```

### 9. Explain @Autowired , @Qualifier , @Resource and @Primary ?

**@Autowired**

Used for automatic dependency injection, and it can be applied to constructors, fields, or setter methods.

```java
@Service
public class MyService {
    
    @Autowired
    private MyRepository myRepository;
    
    // constructor injection
    @Autowired
    public MyService(MyRepository myRepository) {
        this.myRepository = myRepository;
    }

    // setter injection
    @Autowired
    public void setMyRepository(MyRepository myRepository) {
        this.myRepository = myRepository;
    }
}

```

**@Qualifier**

Used in conjunction with `@Autowired` to resolve conflicts when multiple beans of the same type exist. Specifies which bean to inject when multiple candidates are present.

```java
@Service
public class MyService {
    
    @Autowired
    @Qualifier("specificRepository")
    private MyRepository myRepository;
}

@Repository("specificRepository")
public class SpecificRepository implements MyRepository {
    // implementation
}

@Repository("anotherRepository")
public class AnotherRepository implements MyRepository {
    // implementation
}

```

**@Resource**

Similar to `@Autowired` but has more options for specifying the injection. It can inject by name, type, or both.  JSR-250 annotation for dependency injection. By default, it injects by name.

```java
@Service
public class MyService {
    
    @Resource(name = "specificRepository")
    private MyRepository myRepository;
}

@Repository("specificRepository")
public class SpecificRepository implements MyRepository {
    // implementation
}

```

**@Primary**

 Indicates which bean should be given preference when autowiring by type. Specifies a primary bean when multiple candidates are present for autowiring.

```java
@Repository
@Primary
public class PrimaryRepository implements MyRepository {
    // implementation
}

@Repository
public class SecondaryRepository implements MyRepository {
    // implementation
}

@Service
public class MyService {
    
    @Autowired
    private MyRepository myRepository; // PrimaryRepository will be injected
}

```

### 10. How many annotations we can use to inject a bean?

@Autowire

@Qualifier to resolve conflicts when multiple beans of the same type exist.

@Resource like `@Resource(name = "specificRepository")`

@Inject

### 11. Explain and compare differnet types of denpendency injection, their pros and cons, and use cases.

1. Constructor Injection

   ```java
   @Service
   public class MyService {
   
       private final MyRepository myRepository;
   
       @Autowired
       public MyService(MyRepository myRepository) {
           this.myRepository = myRepository;
       }
   }
   
   ```

2. Setter Injection

   ```java
   @Autowired
       public void setMyRepository(MyRepository myRepository) {
           this.myRepository = myRepository;
       }
   ```

3. Field Injection

   ```java
   @Service
   public class MyService {
   
       @Autowired
       private MyRepository myRepository;
   }
   ```

   | Feature       | Constructor Injection                                        | Setter Injection                                             | Field Injection                                              |
   | ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | **Pros**      | - Immutability: Dependencies can be `final`.                 | - Flexibility: Allows for optional dependencies.             | - Simplicity: Easy to read and understand.                   |
   |               | - Required Dependencies: Ensures all dependencies are provided. | - Readability: Keeps constructor clean.                      | - Readability: Keeps constructor and setter methods clean.   |
   |               | - Testability: Easier to mock dependencies in tests.         |                                                              |                                                              |
   | **Cons**      | - Complexity with Many Dependencies: Constructor can become cluttered. | - Mutability: Dependencies can be changed after initialization. | - Testability: More difficult to mock dependencies in tests. |
   |               |                                                              | - Potential Null Issues: Requires careful handling.          | - Immutability: Dependencies cannot be `final`.              |
   |               |                                                              |                                                              | - Reflection-Based: Relies on reflection for injection.      |
   | **Use Cases** | - Preferred when the class has mandatory dependencies.       | - When the class has optional dependencies.                  | - When you want a quick and simple way to inject dependencies. |
   |               | - When you want to leverage immutability for the dependencies. | - When you want to inject dependencies after object creation. | - Suitable for prototyping or simple applications.           |

### 12. If we have multiple beans for one type, how to set one is primary? and how Spring IOC picks one bean to inject if no primary.

Use @Primary to indicate.

Use @Qualifier to specify which bean to use. 

If there are multiple beans of the same type and no further qualification, Spring will throw a `NoUniqueBeanDefinitionException`.

### 13. Compare BeanFactory and ApplicationContext in Spring framework?

**BeanFactory**

- Core interface for accessing a Spring bean container

- Lazy initialization of beans (only when requested)

- Lack of advanced features such as AOP, event monitoring

- Needs to be manually register `BeanPostProcess` and `BeanFactoryPostProcessor`
- For annotation-based configuration, limited support

**ApplicationContext**

- Advanced interface that extends `BeanFactory` and adds more enterprise-specific functionality
- Eager initialization of singleton beans (on startup)
- Automatically detects and registers `BeanPostProcessor` and `BeanFactoryPostProcessor`
- Supported via `MessageSource`
- For event handling, supported via the `ApplicationEventPublisher`
- Provides `ApplicationListener` for responding to lifecycle events
- For annotation-based configuration, full support including `@Configuration`, `@ComponentScan`, etc.

### 14. Explain bean scope in Spring IOC? List bean scopes with explainations and code examples if possible.

Bean scope determines the lifecycle and visibility of beans.

| Scope       | Description                                         | Example Usage                                        |
| ----------- | --------------------------------------------------- | ---------------------------------------------------- |
| Singleton   | One instance per Spring IoC container               | Services, DAOs, utility classes                      |
| Prototype   | New instance every time `getBean()` is called       | Stateful beans, mutable objects                      |
| Request     | One instance per HTTP request                       | Web controllers, request-specific processing         |
| Session     | One instance per user session                       | User-specific data, shopping cart                    |
| Application | One instance per web application context            | Global data, configuration settings                  |
| WebSocket   | One instance per WebSocket session                  | WebSocket-related processing                         |
| Custom      | Custom-defined scope based on specific requirements | Specialized use cases not covered by built-in scopes |

1. Singleton Scope

   The singleton scope ensures that Spring IoC container creates and manages only one instance of the bean throughout the application context. Any subsequent requests for the bean result in returning the same instance.

   ```java
   @Service
   @Scope("singleton")
   public class MySingletonService {
       // Singleton service implementation
   }
   
   ```

2. Prototype Scope

   In prototype scope, Spring IoC container creates a new bean instance every time a request for that bean is made (via `getBean()`). This means that every injection point or method call requesting the bean gets a new instance.

   ```java
   import org.springframework.context.annotation.Scope;
   import org.springframework.stereotype.Component;
   
   @Component
   @Scope("prototype")
   public class MyPrototypeBean {
   
       private String message;
   
       public MyPrototypeBean() {
           System.out.println("Creating a new instance of MyPrototypeBean...");
       }
   
       public void setMessage(String message) {
           this.message = message;
       }
   
       public String getMessage() {
           return message;
       }
   }
   
   ```

   ```java
   @Service
   public class MyService {
   
       @Autowired
       private MyPrototypeBean myPrototypeBean;
   
       public void showMessage() {
           myPrototypeBean.setMessage("Hello, Prototype Bean!");
           System.out.println("Message from prototype bean: " + myPrototypeBean.getMessage());
       }
   }
   ```

   `MyPrototypeBean` is prototype-scoped, a new instance will be injected into `MyService` each time `MyService` itself is requested from the Spring container.

   or ApplicationContext

   ```java
   @Component
   public class BeanUser {
   
       @Autowired
       private ApplicationContext applicationContext;
   
       public void usePrototypeBean() {
           MyPrototypeBean bean = applicationContext.getBean(MyPrototypeBean.class);
           bean.setMessage("Hello, Prototype Bean!");
           System.out.println("Message from prototype bean: " + bean.getMessage());
       }
   }
   ```

3. Request Scope

   This scope is specific to web applications. It ensures that one instance of a bean is created for each HTTP request. Once the request is completed, the bean instance is discarded.

   ```java
   
   @Controller
   @RequestMapping("/example")
   public class MyController {
   
       @Autowired
       private RequestScopedBean requestScopedBean;
   
       @GetMapping("/message")
       @ResponseBody
       public String getMessage() {
           requestScopedBean.setRequestMessage("Hello, Request Scoped Bean!");
           return "Message set in request scoped bean: " + requestScopedBean.getRequestMessage();
       }
   }
   ```

   `RequestScopedBean` is injected into `MyController` using `@Autowired`. Since `RequestScopedBean` is request-scoped, a new instance will be injected into `MyController` for each HTTP request.

4. Session Scope

   Session scope is also specific to web applications. It ensures that one instance of a bean is created for each user session. The instance is kept alive until the session expires.

5. Application Scope

    This scope is specific to web applications and ensures that one instance of a bean is created for the entire web application context. It's similar to singleton scope but limited to the web application context.

6. WebSocket

   Introduced in Spring 4.2, WebSocket scope is specific to web applications that use WebSocket. It ensures that one instance of a bean is created for each WebSocket session.

7. Custom

   ```java
   public class MyCustomScope implements Scope {
   
       private final Map<String, Object> scopedObjects = new HashMap<>();
   
       @Override
       public Object get(String name, ObjectFactory<?> objectFactory) {
           if (!scopedObjects.containsKey(name)) {
               scopedObjects.put(name, objectFactory.getObject());
           }
           return scopedObjects.get(name);
       }
   
       @Override
       public Object remove(String name) {
           return scopedObjects.remove(name);
       }
   
       // Implement other methods as per Scope interface
   }
   
   ```

   

### 15. Configure a bean using xml. If bean has parameters/dependencies, how can we configure the bean?

```java
public class MyService {

    private MyDependency myDependency;
		private String serviceName;

    public MyService(MyDependency myDependency, String serviceName) {
        this.myDependency = myDependency;
        this.serviceName = serviceName;
    }

    public void doSomething() {
        myDependency.doAction();
    }
}

public class MyDependency {

    public void doAction() {
        System.out.println("Doing something in MyDependency...");
    }
}

```

And in the xml file:

```xml
<beans>
	  <bean id="myDependency" class="com.example.MyDependency"/>

    <bean id="myService" class="com.example.MyService">
        <constructor-arg ref="myDependency"/>
        <constructor-arg value="MyServiceBean"/>
    </bean>
</beans>
```

**`<constructor-arg>` element**: Specifies the constructor arguments for the bean. Use `ref` attribute to inject another bean by its `id`, or use `value` attribute to inject literal values.

Get Bean with ApplicationContext:

```java
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class MainApp {

    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");

        MyService myService = (MyService) context.getBean("myService");
        myService.doSomething();
    }
}

```

### 16. Do Q15 without xml, use Springboot IOC annotations instead.

```java
@Component
public class MyDependency {

    public void doAction() {
        System.out.println("Doing something in MyDependency...");
    }
}
```

```java

@Service
public class MyService {

    private MyDependency myDependency;
		private String serviceName;

    public MyService(MyDependency myDependency, String serviceName) {
        this.myDependency = myDependency;
        this.serviceName = serviceName;
    }
    public void doSomething() {
        myDependency.doAction();
    }
}
```

```java
@Configuration
public class AppConfig {

    @Bean
    public MyService myService(MyDependency myDependency) {
        String serviceName = "MyService"; // Provide the serviceName here
        return new MyService(myDependency, serviceName);
    }

    @Bean
    public MyDependency myDependency() {
        return new MyDependency();
    }
}
```

Or using `application.properties` or `application.yml`

**application.properties:**

```
myapp.service.name=MyService
```

**application.yml:**

```yml
myapp:
  service:
    name: MyService
```

And then inject it using `@Value` annotation:

````java
@Service
public class MyService {

    private final MyDependency myDependency;
    private final String serviceName;

    @Autowired
    public MyService(MyDependency myDependency, @Value("${myapp.service.name}") String serviceName) {
        this.myDependency = myDependency;
        this.serviceName = serviceName;
    }

    public void doSomething() {
        System.out.println(serviceName + " is doing something...");
        myDependency.doAction();
    }
}
````

Finally,

```java
@SpringBootApplication
@RestController
public class MyApplication {

    private final MyService myService;

    @Autowired
    public MyApplication(MyService myService) {
        this.myService = myService;
    }

    @GetMapping("/invoke-service")
    public String invokeService() {
        myService.doSomething();
        return "Service invoked successfully!";
    }

    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

