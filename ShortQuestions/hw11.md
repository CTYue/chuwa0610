# HW11

1. **Explain TLS, PKI, certificate, public key, private key, and signature.**
    
    SSL: Secure Sockets layer. Usually together with TLS, so when we talked about SSL, we actually talked about “TLS”.
    
    TLS: Transport layer security, TLS is the successor of SSL. With support of advanced encryption algorithms such as AES.
    
    The TLS handshake flow would be 
    
    1. The client contacts the server using HTTPS
    2. The server sends client its certificate and public key.
    3. The client verifies this with a trusted root Certification Authority to ensure the certificate is legal.
    4. The client and server negotiate the strongest type of encryption that each can support
    5. The client encrypts a session with the server’s public key, and sends back to server.
    6. The server decrypts the communication from client with its private key, and the session is established.
    7. Symmetric encryption start, session key is used to encrypt and decrypt data.
    
    PKI: Public key infrastructure, which used to verify the legitimacy.
    
    It contains public keys, subject holder information, issuer information, serial number etc
    
2. **list all http status codes that related to authentication and authorization failures.**
    
    401 Unauthorized: the request has not been applied because it lacks valid authentication.
    
    403 Forbidden: The server understood the request but refused to authorize it. It indicates that the user does not have the necessary permissions for the resource.
    
    407 Proxy Authentication Required: Similar to 401 Unauthorized, but it used on Proxy authentication
    
3. **Compare authentication and authorization?**
    
    Authentication: verify the identity of a user eg: Login
    
    Authorization: Determining if a specific user has the permission. eg: token, session, cookie, OAuth
    
4. **What is HTTP Session?**
    
    HTTP session is a way to store information on the server for the user across multiple request from the same user. HTTP session including cookie and session. Cookie stores in Client side/browser, Session stored in server side.
    
5. **What is Cookie?**
    
    A small piece of data from a web server to a user’s browser. The browser stores the cookie and sends it back with each subsequent request to the same server. Which allows the server to identify and track users and remember their preference or other data.
    
    Cookie are produced by the web server and sent to the client through HTTP headers.
    
6. **What is the difference between Session and Cookie?**
    
    Session is a server side storage mechanism which used to maintain state across multiple requests from the same user.  Session is always used with cookie. SessionID can be stored in Cookie or URL.
    
7. **How do we use session and cookie to keep user information across the the application?**
    
    When a user logs in or starts interacting with the application, the server creates a session object. The session object holds user-specific data, such as userId, preferences or authentication status.
    
    The server will generates a unique session ID associate with the session object.
    
    The session ID will stored in cookie, which will be sent to client.
    
    Cookie and session can provide user identification and tracking, remember user preference, login information and other data.
    
8. **What is JWT?**
    
    JSON web token is a safe representing claims to be transferred between 2 parties. 
    
    Header: consist the type of token, the signing algorithm being used.
    
    Payload: Payload contains claims, like iss, sub, aud, exp etc
    
    Signature: digital signature of Header and Payload, which ensure the JWT is not be modified during the transfer.
    
9. **What is the spring security filter?**
    
    Spring security utilized a chain of filters where each filter has a specific responsibility. The request must go through this chain before reaching the application.
    
10. **Explain how JWT works**
    
    JWT can transfer the important claims like userId, expired time etc. In register process, the server will generate the JWT with the private key.
    
    Client will verify the JWT or not verify it and add JWT into request header. Server will verify the JWT when request is arrived.
    
11. **Explain how do we store sensitive user information such as password and credit card number in DB?**
    
    Add a random value(salt) to password or card number and hash it, store the salt along with password or card number.
    
12. **Compare UserDetailService, AuthenticationProvider, AuthenticationManager, AuthenticationFilter?(把这⼏个名字看熟悉也⾏)**
    
    ![image.png](HW11%20799e6dd0098c44c3815540e559ad89cf/image.png)
    
    UserDetailsSevice: The interface used to load the user data, which defined a function to load user by username.
    
    AuthenticationManager: Authentication Manager accept an Authentication object and try to verify it, if verification success, it will return a Authentication instance with user information, if failed, it will throw error. Authentication Manager manage multiple Authentication Provider.
    
    AuthenticationProvider: The interface which has the method to verify the user. When the AuthenticationManager received an authentication request. The providerManager will traverse the Authentication Provider list and send the Authentication request to every  AuthenticationProvider.
    
    Authentication Filter: it’s a filter which will catch the request and get the authentication information from the request header. And send it to Authentication Manager.
    
13. **What is the disadvantage of Session? how to overcome the disadvantage?**
    
    Scalability issue, since server must to store the session of many user.
    
    Performance issue: if session data is big, it will cause performance issue.
    
    Use redis and JWT to improve the performance, use single sign on to improve security and reduce scalability issues.
    
14. **how to get value from application.properties in Spring security?**
    
    Use @Value eg:
    
    ```java
    myapp.security.secretKey=verySecretKey
    
    @Component
    public class SecurityConfigComponent {
    
        @Value("${myapp.security.secretKey}")
        private String secretKey;
    
        public void someMethod() {
            System.out.println("The secret key is: " + secretKey);
        }
    }
    ```
    
15. **What is the role of configure(HttpSecurity http) and configure(AuthenticationManagerBuilder auth)?**
    
    configure(AuthenticationManagerBuilder auth) is used for configuring how the authentication is performed.
    
    ```java
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth
            .inMemoryAuthentication()
            .withUser("user").password("{noop}password").roles("USER")
            .and()
            .withUser("admin").password("{noop}admin").roles("ADMIN");
    }
    ```
    
    configure(HttpSecurity http) is used to configure web-based security for specific http requests.
    
    ```java
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
            .antMatchers("/", "/home").permitAll()
            .antMatchers("/admin/**").hasRole("ADMIN")
            .and()
            .formLogin()
            .loginPage("/login")
            .permitAll()
            .and()
            .logout()
            .permitAll();
    }
    ```
    
16. **What is Spring security authentication and authorization?**

Authentication is the process of verifying who a user is, Authorization is the process of deciding if a user has the right to perform an action or access resources in a system. 

eg:

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth
            .inMemoryAuthentication()
            .withUser("user").password(passwordEncoder().encode("password")).roles("USER")
            .and()
            .withUser("admin").password(passwordEncoder().encode("admin")).roles("ADMIN");
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
            .antMatchers("/").permitAll()
            .antMatchers("/user/**").hasRole("USER")
            .antMatchers("/admin/**").hasRole("ADMIN")
            .and()
            .formLogin();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```