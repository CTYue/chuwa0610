# Chuwa Homework11 MingHao(Howard) Lee 

## 1. List all of the annotations you learned from class and homework.


## 2. Compare Spring and Spring Boot. What are the benefits of Spring Boot?

### Spring Framework
- **Definition**: A comprehensive framework for enterprise Java development.
- **Core Focus**: Provides extensive features for building robust and maintainable Java applications.
- **Configuration**: Requires a significant amount of configuration, which can be done using XML or annotations.
- **Complexity**: Suitable for complex enterprise-level applications with fine-grained control over configuration and components.
- **Modularity**: Offers a wide range of modules (e.g., Spring Core, Spring MVC, Spring AOP, Spring Security, etc.), allowing developers to use only the parts they need.
- **Dependency Management**: Developers need to manually manage dependencies in their build files (e.g., Maven, Gradle).

### Spring Boot
- **Definition**: An extension of the Spring Framework that simplifies the setup, configuration, and deployment of Spring applications.
- **Core Focus**: Provides a convention-over-configuration approach to reduce boilerplate code and configuration.
- **Configuration**: Uses default configurations and embedded servers (e.g., Tomcat, Jetty) to minimize setup time. Can override defaults with properties or YAML files.
- **Complexity**: Ideal for developing microservices and standalone applications quickly.
- **Starter POMs**: Includes a set of pre-defined starter dependencies (e.g., spring-boot-starter-web, spring-boot-starter-data-jpa) that simplify dependency management.
- **Auto-Configuration**: Automatically configures application components based on the dependencies present in the classpath.
- **Production-Ready Features**: Includes embedded servers, metrics, health checks, and externalized configuration out of the box.

### Benefits of Spring Boot

1. **Reduced Development Time**:
   - **Auto-Configuration**: Automatically configures your application based on the included dependencies, reducing manual configuration.
   - **Embedded Servers**: Comes with embedded servers like Tomcat and Jetty, allowing you to run applications as standalone without needing an external server.

2. **Simplified Dependency Management**:
   - **Starter POMs**: Provides starter dependencies that simplify the inclusion of necessary libraries and modules, avoiding version conflicts.

3. **Microservice Architecture Support**:
   - **Ease of Setup**: Simplifies the creation and deployment of microservices with minimal configuration.
   - **Spring Cloud Integration**: Easily integrates with Spring Cloud for building scalable and resilient microservices.

4. **Production-Ready Features**:
   - **Actuator**: Provides built-in endpoints for monitoring and managing applications, including health checks, metrics, and environment information.
   - **Externalized Configuration**: Allows configuration properties to be externalized to external files or environment variables, supporting different environments (e.g., development, testing, production).

5. **Development Convenience**:
   - **Spring Boot CLI**: Command-line interface for quickly bootstrapping new Spring Boot applications.
   - **DevTools**: Provides tools for improving developer productivity, such as automatic restarts, live reload, and configurations for development environments.

6. **Community and Documentation**:
   - **Extensive Documentation**: Rich documentation and tutorials available to help developers get started and resolve issues.
   - **Active Community**: Strong community support with numerous resources, forums, and examples available online.


## 3. What is IOC and what is DI?
### Inversion of Control (IoC)

**Definition:**

Inversion of Control is a design principle in which the control of object creation and the management of dependencies is inverted from the application code to a container or framework.

**Explanation:**

### Traditional Approach
In a traditional application, the main program controls the flow and the creation of objects.

### IoC Approach
With IoC, the framework or container controls the flow and the creation of objects. The control is "inverted" from the application to the framework.

**Example:**
 - Without IoC:
```Java
  public class Service {
      private Repository repository;
  
      public Service() {
          this.repository = new Repository(); // Service controls the creation of Repository
      }
  }

```
 - With Ioc:
```Java
  public class Service {
      private Repository repository;
  
      public Service(Repository repository) {
          this.repository = repository; // Repository is injected by the framework
      }
  }
```
**Benefit:**
- Decouples the code, making it more modular, testable, and maintainable.


### Dependency Injection (DI)

**Definition:**

Dependency Injection is a specific implementation of IoC where the dependencies (objects or services) are injected into a class rather than the class creating them itself.

**Explanation:**

- **Without DI:** A class is responsible for creating its own dependencies.
- **With DI:** Dependencies are provided to the class by an external entity (like a framework).

**Types of DI:**

1. **Constructor Injection:** Dependencies are provided through a class constructor.
2. **Setter Injection:** Dependencies are provided through setter methods.
3. **Field Injection:** Dependencies are directly assigned to fields (not recommended due to testing difficulties).

**Example:**
 - Constructor Injection:
```Java
  public class Service {
      private Repository repository;
  
      public Service(Repository repository) {
          this.repository = repository; // Dependency is injected via the constructor
      }
  }
```

 - Setter Injection:
```Java
  public class Service {
      private Repository repository;
  
      public void setRepository(Repository repository) {
          this.repository = repository; // Dependency is injected via a setter method
      }
  }
```

**Benefit:**
- Promotes loose coupling between classes.
- Enhances testability by allowing dependencies to be mocked or stubbed.
- Improves code readability and maintainability by clearly defining dependencies.

### How IoC and DI Work Together

- **IoC Container:** Manages the lifecycle and configuration of application objects. Examples include the Spring Framework's ApplicationContext.

- **DI Mechanism:** The IoC container uses DI to inject dependencies into objects, ensuring they are properly configured and ready to use.

**Illustration:**

Imagine you are at a restaurant:

- **Without IoC/DI:** You go to the kitchen, gather ingredients, and cook your meal.

- **With IoC/DI:** You order from a menu, and the chef prepares and serves your meal. The restaurant (IoC container) manages everything, and you (the application) just enjoy the meal.

By using IoC and DI, your code becomes more flexible, easier to test, and more aligned with best practices for software development.



## 4. What is `@ComponentScan`?
**Definition:**

The `@ComponentScan` annotation is used in Spring to specify the packages to scan for annotated components. It tells Spring which packages to look into for finding beans (i.e., classes annotated with `@Component`, `@Service`, `@Repository`, and `@Controller`).

**Purpose:**

- To enable Spring to detect and register beans from the specified packages automatically.
- To facilitate component scanning, which is a key feature in Spring's IoC (Inversion of Control) container.

**Usage:**

- Typically placed on a configuration class (annotated with `@Configuration` or `@SpringBootApplication`).
- Can specify one or multiple packages to scan.

**Example:**
 - Constructor Injection:
```Java
  @Configuration
  @ComponentScan(basePackages = "com.example.project")
  public class AppConfig {
      // This class can contain bean definitions and other configuration settings
  }
```

**Explanation:**

- `@Configuration`: Indicates that the class can be used by the Spring IoC container as a source of bean definitions.
- `@ComponentScan(basePackages = "com.example.project")`: Instructs Spring to scan the `com.example.project` package for components/beans.

## How It Works

When Spring initializes the application context, it performs the following steps:

1. **Scans the specified packages:** Looks for classes annotated with `@Component`, `@Service`, `@Repository`, and `@Controller`.
2. **Registers the components:** Creates bean definitions for these classes and registers them in the application context.
3. **Manages the lifecycle:** Spring IoC container manages the lifecycle of these beans, including their creation, dependency injection, and destruction.

## Why Use `@ComponentScan`?

1. **Automatic Bean Detection:**
   - Simplifies configuration by automatically detecting and registering beans, reducing the need for manual bean definitions.

2. **Modular Design:**
   - Encourages a modular application structure where components are grouped logically in packages, making the codebase easier to manage and maintain.

3. **Flexibility:**
   - Allows specifying multiple packages or even excluding specific classes or packages from being scanned.



## 5. What is `@SpringBootApplication`?
## `@SpringBootApplication` in Spring Boot

**Definition:**

The `@SpringBootApplication` annotation is a convenience annotation that combines several other annotations commonly used in Spring Boot applications. It is placed on the main application class to enable auto-configuration and component scanning.

**Purpose:**

- Simplifies configuration of a Spring Boot application.
- Bootstraps and launches the Spring application.

**Components of `@SpringBootApplication`:**

1. `@Configuration`: Marks the class as a source of bean definitions.
2. `@EnableAutoConfiguration`: Enables Spring Bootâ€™s auto-configuration mechanism.
3. `@ComponentScan`: Enables component scanning to find and register beans.

**Usage:**

- Placed on the main class of the application.
- The main class should have a `main` method that uses `SpringApplication.run` to launch the application.

**Example:**

```java
   import org.springframework.boot.SpringApplication;
   import org.springframework.boot.autoconfigure.SpringBootApplication;
   
   @SpringBootApplication
   public class MyApplication {
   
       public static void main(String[] args) {
           SpringApplication.run(MyApplication.class, args);
       }
   }
```
## Benefits of `@SpringBootApplication`

1. **Simplified Configuration:** Combines multiple annotations into one.
2. **Auto-Configuration:** Automatically configures the application based on dependencies.
3. **Component Scanning:** Automatically scans and registers beans.
4. **Convenient Entry Point:** Provides a single entry point to start the application.

Using `@SpringBootApplication` makes it easy to set up and run Spring Boot applications with minimal configuration.

## 6. How many ways to define a bean? Provide code examples.
**Using `@Component` Annotation:**

```java
   import org.springframework.stereotype.Component;
   
   @Component
   public class MyComponent {
       // Bean definition
   }
```

**Using `@Bean Annotation` in a Configuration Class:**

```java
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;
   
   @Configuration
   public class AppConfig {
       @Bean
       public MyBean myBean() {
           return new MyBean();
       }
   }
```

**Using XML Configuration:**
```java
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
                              http://www.springframework.org/schema/beans/spring-beans.xsd">
   
       <bean id="myBean" class="com.example.MyBean"/>
   </beans>
```


## 7. What is the default bean name for `@Component` and `@Bean`? Also, compare `@Component` and `@Bean`.
### Default Bean Names

- `@Component`: The default bean name is the class name with the first letter in lowercase.
```java
   @Component
   public class MyService { }
   // Default bean name: "myService"
```

- `@Bean`: The default bean name is the class name with the first letter in lowercase.
```java
   @Bean
   public MyBean myBean() {
       return new MyBean();
   }
   // Default bean name: "myBean"
```
### Comparison: `@Component` vs. `@Bean`

- `@Component`:
  - Automatically detects and registers beans during classpath scanning.
  - Used for general-purpose Spring-managed components.
  - Example:
```java
  @Component
  public class MyComponent { }
```

- `@Bean`:
  - Explicitly declares a bean within a `@Configuration` class.
  - Provides greater control over bean instantiation and configuration.
  - Example:
 ```java
   @Configuration
   public class AppConfig {
       @Bean
       public MyBean myBean() {
           return new MyBean();
       }
   }
```

### Key Differences
- **Detection:** `@Component` is automatically detected, whereas `@Bean` is explicitly defined.
- **Configuration:** `@Bean` is used within a configuration class to create and configure beans, while `@Component` is used to mark classes as Spring components.






## 8. Compare `@Component` and `@Service`, `@Repository`, `@Controller`.
- `@Component`:
  - General-purpose annotation for Spring-managed components.
  - Can be used for any Spring bean.

- `@Service`:
  - Specialization of `@Component`.
  - Indicates that a class provides business logic or service layer functionality.
  - Example:
```Java
   @Service
   public class MyService { }
```
- `@Repository`:
  - Specialization of `@Component`.
  - Indicates that a class is a Data Access Object (DAO) and interacts with the database.
  - Provides additional features for exception translation.
  - Example:
```Java
   @Repository
   public class MyRepository { }
```

- `@Controller`:
  - Specialization of `@Component`.
  - Indicates that a class is a Spring MVC controller, handling web requests and returning views.
  - Example:
```Java
   @Controller
   public class MyController { }
```

### Key Points
- All are specializations of `@Component` with additional semantics and specific roles.
- `@Service`: Business logic/service layer.
- `@Repository`: Data access layer/DAO.
- `@Controller`: Web layer/MVC controller.
- `@Component`: General-purpose, used when none of the specific annotations apply.


## 9. Explain `@Autowired`, `@Qualifier`, `@Resource`, and `@Primary`.
- `@Autowired`:
   - Automatically injects dependencies by type.
   - Can be used on fields, constructors, and setter methods.
   - Example:
```Java
   @Autowired
   private MyService myService;
```

- `@Qualifier`:
   - Used with `@Autowired` to resolve ambiguity when multiple beans of the same type exist.
   - Specifies the name of the bean to inject.
   - Example:
```Java
   @Autowired
   @Qualifier("specificBean")
   private MyService myService;
```

- `@Resource`:
   - JSR-250 annotation, similar to `@Autowired` but injects dependencies by name (default) or type.
   - Provides more control over injection, such as looking up JNDI resources.
   - Example:
```Java
   @Resource(name = "myService")
   private MyService myService;
``` 

- `@Primary`:
   - Indicates the preferred bean when multiple beans of the same type are present.
   - Used to specify the default bean to inject.
   - Example:
```Java
   @Primary
   @Bean
   public MyService primaryService() {
       return new MyServiceImpl();
   }
```

### Key Points
- `@Autowired`: Automatic injection by type.
- `@Qualifier`: Resolves bean conflicts by specifying the bean name.
- `@Resource`: Injection by name (default) or type, more control over injection.
- `@Primary`: Specifies the default bean when multiple beans of the same type exist.




## 10. How many annotations can we use to inject a bean?
There are several annotations in Spring that can be used to inject a bean. Here are the primary ones:

1. `@Autowired`:
   - Automatically injects dependencies by type.
   - Can be used on fields, constructors, and setter methods.

2. `@Qualifier`:
   - Used with `@Autowired` to resolve ambiguity when multiple beans of the same type exist.
   - Specifies the name of the bean to inject.

3. `@Resource`:
   - JSR-250 annotation, similar to `@Autowired` but injects dependencies by name (default) or type.
   - Provides more control over injection, such as looking up JNDI resources.

4. `@Inject`:
   - Part of the Java Dependency Injection (JSR-330) standard.
   - Similar to `@Autowired`, injects dependencies by type.
   - Does not support optional dependencies directly.

5. `@Primary`:
   - Used alongside `@Autowired` to specify the preferred bean when multiple beans of the same type are present.
   - Indicates the default bean to inject.

### Key Points
- `@Autowired`: By type injection.
- `@Qualifier`: Resolves ambiguity by specifying bean name.
- `@Resource`: By name (default) or type injection, part of JSR-250.
- `@Inject`: By type injection, part of JSR-330.
- `@Primary`: Specifies the default bean when multiple beans of the same type exist.

## 11. Explain and compare different types of dependency injection, their pros and cons, and use cases.
1. **Constructor Injection**
   - **Definition:** Dependencies are provided through a class constructor.
   - **Pros:**
     - Ensures all required dependencies are provided.
     - Promotes immutability.
     - Easier for testing (can use mocks).
   - **Cons:**
     - Can become cumbersome with many dependencies.
   - **Use Case:** When the class has mandatory dependencies that should not change after construction.
   - **Example:**
```Java
   public class MyService {
       private final MyRepository repository;
   
       @Autowired
       public MyService(MyRepository repository) {
           this.repository = repository;
       }
   }
```

2. **Setter Injection**
   - **Definition:** Dependencies are provided through setter methods.
   - **Pros:**
     - Allows for optional dependencies.
     - More flexible if dependencies can change.
   - **Cons:**
     - Can lead to incomplete object state if not all setters are called.
   - **Use Case:** When dependencies are optional or can change.
   - **Example:**
```Java
   public class MyService {
       private MyRepository repository;
   
       @Autowired
       public void setRepository(MyRepository repository) {
           this.repository = repository;
       }
   }
```

3. **Field Injection**
   - **Definition:** Dependencies are injected directly into fields.
   - **Pros:**
     - Less boilerplate code.
     - Simplifies the code.
   - **Cons:**
     - Harder to test (requires reflection).
     - Violates the principle of encapsulation.
   - **Use Case:** Simple applications or when you want to avoid constructor/setter clutter.
   - **Example:**
```Java
   public class MyService {
       @Autowired
       private MyRepository repository;
   }
```

### Comparison Summary

- **Constructor Injection:**
  - **Pros:** Enforces complete dependencies, promotes immutability, easier to test.
  - **Cons:** Verbose with many dependencies.
  - **Use Case:** Mandatory, non-changing dependencies.

- **Setter Injection:**
  - **Pros:** Supports optional and mutable dependencies, more flexible.
  - **Cons:** Risk of incomplete object state.
  - **Use Case:** Optional or changeable dependencies.

- **Field Injection:**
  - **Pros:** Minimal boilerplate, simple to use.
  - **Cons:** Harder to test, breaks encapsulation.
  - **Use Case:** Simple applications, when simplicity is preferred over testing and encapsulation.

### Key Points

- Choose **Constructor Injection** for mandatory dependencies.
- Use **Setter Injection** for optional or mutable dependencies.
- Opt for **Field Injection** for simplicity, but be cautious about testing and encapsulation.



## 12. If we have multiple beans for one type, how to set one as primary? How does Spring IOC pick one bean to inject if no primary is set?
### `@Primary` Annotation:

- Used to indicate which bean should be the default when multiple beans of the same type are present.
- **Example:**
```Java
   @Bean
   @Primary
   public MyService primaryService() {
       return new MyServiceImpl();
   }
```

### Bean Selection by Spring IoC

1. **With `@Primary`:**
   - The bean annotated with `@Primary` is chosen as the default bean.
   - **Example:**
```Java
   @Bean
   @Primary
   public MyService primaryService() {
       return new MyServiceImpl();
   }
   
   @Bean
   public MyService secondaryService() {
       return new AnotherServiceImpl();
   }
```


2. **Without `@Primary`:**
   - If no bean is marked as primary, Spring IoC requires further disambiguation.
   - Use `@Qualifier` to specify the bean to inject.
   - **Example:**
```Java
   @Autowired
   @Qualifier("secondaryService")
   private MyService myService;
```
   - If no `@Qualifier` is provided, Spring will throw a `NoUniqueBeanDefinitionException`.

### Key Points
- Use `@Primary` to set a default bean when multiple beans of the same type exist.
- Use `@Qualifier` to specify which bean to inject when there are multiple beans and no primary is set.
- Without `@Primary` or `@Qualifier`, Spring will throw an exception if multiple beans are found.

## 13. Compare BeanFactory and ApplicationContext in the Spring framework.
### BeanFactory

- **Definition:** The root interface for accessing Spring's bean container.
- **Lazy Initialization:** Beans are created only when requested.
- **Basic Capabilities:** Provides basic functionality for dependency injection.
- **Usage:** Suitable for lightweight applications where minimal overhead is needed.

### ApplicationContext

- **Definition:** A more advanced container, extending BeanFactory.
- **Eager Initialization:** Beans are created at startup.
- **Additional Features:**
  - **Event Propagation:** Supports event handling.
  - **Internationalization:** Provides support for internationalization (i18n).
  - **Application Lifecycle:** Manages the lifecycle of beans and application context.
  - **Built-in BeanPostProcessor:** Automatically registers BeanPostProcessor and BeanFactoryPostProcessor.
- **Usage:** Preferred for enterprise-level applications requiring advanced features.

### Key Points

- **Initialization:**
  - **BeanFactory:** Lazy initialization.
  - **ApplicationContext:** Eager initialization.
- **Features:**
  - **BeanFactory:** Basic DI capabilities.
  - **ApplicationContext:** Advanced features like event handling, internationalization, and lifecycle management.
- **Use Case:**
  - **BeanFactory:** Lightweight, minimal overhead applications.
  - **ApplicationContext:** Full-featured, enterprise-level applications.



## 14. Explain bean scope in Spring IOC. List bean scopes with explanations and code examples if possible.
1. **Singleton (Default)**
   - **Definition:** A single instance of the bean per Spring IoC container.
   - **Use Case:** Shared state across the application.
   - **Example:**
```Java
   @Component
   public class MySingletonBean { }
```
2. **Prototype**
   - **Definition:** A new instance of the bean every time it is requested.
   - **Use Case:** Stateless, per-use instances.
   - **Example:**
```Java
   @Scope("prototype")
   @Component
   public class MyPrototypeBean { }
```

3. **Request (Web-aware)**
   - **Definition:** A single instance per HTTP request.
   - **Use Case:** Web applications where a bean is needed for the duration of a single HTTP request.
   - **Example:**
```Java
   @Scope("request")
   @Component
   public class MyRequestBean { }
```

4. **Session (Web-aware)**
   - **Definition:** A single instance per HTTP session.
   - **Use Case:** Web applications where a bean is needed for the duration of an HTTP session.
   - **Example:**
```Java
   @Scope("session")
   @Component
   public class MySessionBean { }
```
  
5. **Application (Web-aware)**
   - **Definition:** A single instance per ServletContext.
   - **Use Case:** Web applications where a bean is needed for the duration of the servlet context.
   - **Example:**
```Java
   @Scope("application")
   @Component
   public class MyApplicationBean { }
```

### Key Points
- **Singleton:** Default, shared instance, global state.
- **Prototype:** New instance per request, stateless.
- **Request:** Per HTTP request, web-specific.
- **Session:** Per HTTP session, web-specific.
- **Application:** Per ServletContext, web-specific.
- **Global Session:** Per global HTTP session, Portlet-specific.(rarely use)


## 15. Configure a bean using XML. If the bean has parameters/dependencies, how can we configure the bean?
### Basic Bean Configuration

#### XML Configuration:
```xml
   <bean id="myBean" class="com.example.MyBean"/>
```

### Bean with Constructor Dependencies

#### XML Configuration:
```xml
   <bean id="myBean" class="com.example.MyBean">
       <constructor-arg value="SomeValue"/>
       <constructor-arg ref="dependencyBean"/>
   </bean>
   
   <bean id="dependencyBean" class="com.example.DependencyBean"/>
```

**Explanation:**

- `<constructor-arg>`: Specifies constructor arguments. `value` for literal values, `ref` for bean references.

### Bean with Setter Dependencies

#### XML Configuration:
```xml
   <bean id="myBean" class="com.example.MyBean">
       <property name="someProperty" value="SomeValue"/>
       <property name="dependency" ref="dependencyBean"/>
   </bean>
   
   <bean id="dependencyBean" class="com.example.DependencyBean"/>
```

**Explanation:**

- `<property>`: Specifies setter injection. `name` corresponds to the property name, `value` for literal values, `ref` for bean references.

### Key Points

- Use `<bean>` to define beans.
- Use `<constructor-arg>` for constructor injection.
- Use `<property>` for setter injection.
- `value` attribute for literal values.
- `ref` attribute for referencing other beans.


## 16. Configure a bean without XML, using Spring Boot IOC annotations instead.
### Basic Bean Configuration

#### Java Configuration:
```Java
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;
   
   @Configuration
   public class AppConfig {
   
       @Bean
       public MyBean myBean() {
           return new MyBean();
       }
   }
```

### Bean with Constructor Dependencies

#### Java Configuration:
```Java
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;
   
   @Configuration
   public class AppConfig {
   
       @Bean
       public MyBean myBean(DependencyBean dependencyBean) {
           return new MyBean(dependencyBean);
       }
   
       @Bean
       public DependencyBean dependencyBean() {
           return new DependencyBean();
       }
   }
```

### Bean with Setter Dependencies

#### Java Configuration:
```Java
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;
   
   @Configuration
   public class AppConfig {
   
       @Bean
       public MyBean myBean() {
           MyBean myBean = new MyBean();
           myBean.setSomeProperty("SomeValue");
           myBean.setDependency(dependencyBean());
           return myBean;
       }
   
       @Bean
       public DependencyBean dependencyBean() {
           return new DependencyBean();
       }
   }
```
### Key Points
- `@Configuration`: Marks the class as a source of bean definitions.
- `@Bean`: Indicates that a method produces a bean to be managed by the Spring container.
- **Constructor Injection:** Specify the dependencies as method parameters.
- **Setter Injection:** Configure the bean properties within the method body.


