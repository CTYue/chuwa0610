# Chuwa Homework11 MingHao(Howard) Lee 

## 1. List all of the annotations you learned from class and homework.


## 2. Compare Spring and Spring Boot. What are the benefits of Spring Boot?

### Spring Framework
- **Definition**: A comprehensive framework for enterprise Java development.
- **Core Focus**: Provides extensive features for building robust and maintainable Java applications.
- **Configuration**: Requires a significant amount of configuration, which can be done using XML or annotations.
- **Complexity**: Suitable for complex enterprise-level applications with fine-grained control over configuration and components.
- **Modularity**: Offers a wide range of modules (e.g., Spring Core, Spring MVC, Spring AOP, Spring Security, etc.), allowing developers to use only the parts they need.
- **Dependency Management**: Developers need to manually manage dependencies in their build files (e.g., Maven, Gradle).

### Spring Boot
- **Definition**: An extension of the Spring Framework that simplifies the setup, configuration, and deployment of Spring applications.
- **Core Focus**: Provides a convention-over-configuration approach to reduce boilerplate code and configuration.
- **Configuration**: Uses default configurations and embedded servers (e.g., Tomcat, Jetty) to minimize setup time. Can override defaults with properties or YAML files.
- **Complexity**: Ideal for developing microservices and standalone applications quickly.
- **Starter POMs**: Includes a set of pre-defined starter dependencies (e.g., spring-boot-starter-web, spring-boot-starter-data-jpa) that simplify dependency management.
- **Auto-Configuration**: Automatically configures application components based on the dependencies present in the classpath.
- **Production-Ready Features**: Includes embedded servers, metrics, health checks, and externalized configuration out of the box.

### Benefits of Spring Boot

1. **Reduced Development Time**:
   - **Auto-Configuration**: Automatically configures your application based on the included dependencies, reducing manual configuration.
   - **Embedded Servers**: Comes with embedded servers like Tomcat and Jetty, allowing you to run applications as standalone without needing an external server.

2. **Simplified Dependency Management**:
   - **Starter POMs**: Provides starter dependencies that simplify the inclusion of necessary libraries and modules, avoiding version conflicts.

3. **Microservice Architecture Support**:
   - **Ease of Setup**: Simplifies the creation and deployment of microservices with minimal configuration.
   - **Spring Cloud Integration**: Easily integrates with Spring Cloud for building scalable and resilient microservices.

4. **Production-Ready Features**:
   - **Actuator**: Provides built-in endpoints for monitoring and managing applications, including health checks, metrics, and environment information.
   - **Externalized Configuration**: Allows configuration properties to be externalized to external files or environment variables, supporting different environments (e.g., development, testing, production).

5. **Development Convenience**:
   - **Spring Boot CLI**: Command-line interface for quickly bootstrapping new Spring Boot applications.
   - **DevTools**: Provides tools for improving developer productivity, such as automatic restarts, live reload, and configurations for development environments.

6. **Community and Documentation**:
   - **Extensive Documentation**: Rich documentation and tutorials available to help developers get started and resolve issues.
   - **Active Community**: Strong community support with numerous resources, forums, and examples available online.


## 3. What is IOC and what is DI?
### Inversion of Control (IoC)

**Definition:**

Inversion of Control is a design principle in which the control of object creation and the management of dependencies is inverted from the application code to a container or framework.

**Explanation:**

### Traditional Approach
In a traditional application, the main program controls the flow and the creation of objects.

### IoC Approach
With IoC, the framework or container controls the flow and the creation of objects. The control is "inverted" from the application to the framework.

**Example:**
 - Without IoC:
```Java
  public class Service {
      private Repository repository;
  
      public Service() {
          this.repository = new Repository(); // Service controls the creation of Repository
      }
  }

```
 - With Ioc:
```Java
  public class Service {
      private Repository repository;
  
      public Service(Repository repository) {
          this.repository = repository; // Repository is injected by the framework
      }
  }
```
**Benefit:**
- Decouples the code, making it more modular, testable, and maintainable.


### Dependency Injection (DI)

**Definition:**

Dependency Injection is a specific implementation of IoC where the dependencies (objects or services) are injected into a class rather than the class creating them itself.

**Explanation:**

- **Without DI:** A class is responsible for creating its own dependencies.
- **With DI:** Dependencies are provided to the class by an external entity (like a framework).

**Types of DI:**

1. **Constructor Injection:** Dependencies are provided through a class constructor.
2. **Setter Injection:** Dependencies are provided through setter methods.
3. **Field Injection:** Dependencies are directly assigned to fields (not recommended due to testing difficulties).

**Example:**
 - Constructor Injection:
```Java
  public class Service {
      private Repository repository;
  
      public Service(Repository repository) {
          this.repository = repository; // Dependency is injected via the constructor
      }
  }
```

 - Setter Injection:
```Java
  public class Service {
      private Repository repository;
  
      public void setRepository(Repository repository) {
          this.repository = repository; // Dependency is injected via a setter method
      }
  }
```

**Benefit:**
- Promotes loose coupling between classes.
- Enhances testability by allowing dependencies to be mocked or stubbed.
- Improves code readability and maintainability by clearly defining dependencies.

### How IoC and DI Work Together

- **IoC Container:** Manages the lifecycle and configuration of application objects. Examples include the Spring Framework's ApplicationContext.

- **DI Mechanism:** The IoC container uses DI to inject dependencies into objects, ensuring they are properly configured and ready to use.

**Illustration:**

Imagine you are at a restaurant:

- **Without IoC/DI:** You go to the kitchen, gather ingredients, and cook your meal.

- **With IoC/DI:** You order from a menu, and the chef prepares and serves your meal. The restaurant (IoC container) manages everything, and you (the application) just enjoy the meal.

By using IoC and DI, your code becomes more flexible, easier to test, and more aligned with best practices for software development.



## 4. What is `@ComponentScan`?
**Definition:**

The `@ComponentScan` annotation is used in Spring to specify the packages to scan for annotated components. It tells Spring which packages to look into for finding beans (i.e., classes annotated with `@Component`, `@Service`, `@Repository`, and `@Controller`).

**Purpose:**

- To enable Spring to detect and register beans from the specified packages automatically.
- To facilitate component scanning, which is a key feature in Spring's IoC (Inversion of Control) container.

**Usage:**

- Typically placed on a configuration class (annotated with `@Configuration` or `@SpringBootApplication`).
- Can specify one or multiple packages to scan.

**Example:**
 - Constructor Injection:
```Java
  @Configuration
  @ComponentScan(basePackages = "com.example.project")
  public class AppConfig {
      // This class can contain bean definitions and other configuration settings
  }
```

**Explanation:**

- `@Configuration`: Indicates that the class can be used by the Spring IoC container as a source of bean definitions.
- `@ComponentScan(basePackages = "com.example.project")`: Instructs Spring to scan the `com.example.project` package for components/beans.

## How It Works

When Spring initializes the application context, it performs the following steps:

1. **Scans the specified packages:** Looks for classes annotated with `@Component`, `@Service`, `@Repository`, and `@Controller`.
2. **Registers the components:** Creates bean definitions for these classes and registers them in the application context.
3. **Manages the lifecycle:** Spring IoC container manages the lifecycle of these beans, including their creation, dependency injection, and destruction.

## Why Use `@ComponentScan`?

1. **Automatic Bean Detection:**
   - Simplifies configuration by automatically detecting and registering beans, reducing the need for manual bean definitions.

2. **Modular Design:**
   - Encourages a modular application structure where components are grouped logically in packages, making the codebase easier to manage and maintain.

3. **Flexibility:**
   - Allows specifying multiple packages or even excluding specific classes or packages from being scanned.



## 5. What is `@SpringBootApplication`?

## 6. How many ways to define a bean? Provide code examples.

## 7. What is the default bean name for `@Component` and `@Bean`? Also, compare `@Component` and `@Bean`.

## 8. Compare `@Component` and `@Service`, `@Repository`, `@Controller`.

## 9. Explain `@Autowired`, `@Qualifier`, `@Resource`, and `@Primary`.

## 10. How many annotations can we use to inject a bean?

## 11. Explain and compare different types of dependency injection, their pros and cons, and use cases.

## 12. If we have multiple beans for one type, how to set one as primary? How does Spring IOC pick one bean to inject if no primary is set?

## 13. Compare BeanFactory and ApplicationContext in the Spring framework.

## 14. Explain bean scope in Spring IOC. List bean scopes with explanations and code examples if possible.

## 15. Configure a bean using XML. If the bean has parameters/dependencies, how can we configure the bean?

## 16. Configure a bean without XML, using Spring Boot IOC annotations instead.
