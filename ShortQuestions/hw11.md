
2. 
### Comparison Between Spring and Spring Boot

#### Overview

**Spring Framework** is a comprehensive framework for enterprise Java development, providing a wide range of functionalities including IoC, AOP, data access, web MVC, integration, and security.

**Spring Boot** is an extension of the Spring Framework that simplifies the development of stand-alone, production-ready Spring applications with features like auto-configuration, starter POMs, embedded servers, and production-ready tools.

#### Comparison

| Feature                     | Spring Framework                            | Spring Boot                                  |
|-----------------------------|---------------------------------------------|----------------------------------------------|
| **Configuration**           | Requires manual XML or Java-based config    | Auto-configuration reduces manual setup      |
| **Dependencies**            | Manually manage dependencies                | Starter POMs simplify dependency management  |
| **Application Type**        | Requires an external server                 | Stand-alone applications with embedded server|
| **Setup Complexity**        | Can be complex and verbose                  | Simplified and convention-based              |
| **Development Speed**       | Slower due to manual setup                  | Faster with auto-configuration and starters  |
| **Monitoring and Metrics**  | Requires additional setup                   | Built-in with Actuator                       |
| **Microservices Support**   | Supported but requires manual configuration | Optimized for microservices                  |

#### Benefits of Spring Boot

1. **Simplified Setup**:
    - **Auto-Configuration**: Automatically configures many aspects of the application based on the dependencies and settings, reducing the need for manual setup.
    - **Starter Dependencies**: Provides a set of predefined dependencies that make it easy to get started with various Spring projects.

2. **Rapid Development**:
    - **Embedded Servers**: Applications can be run directly from the command line or an IDE without needing an external server, facilitating faster development cycles.
    - **Minimal Configuration**: Reduces boilerplate code and configuration, allowing developers to focus on business logic.

3. **Microservices Ready**:
    - **Modularity**: Ideal for building microservices with minimal setup.
    - **Spring Cloud**: Works seamlessly with Spring Cloud for building scalable, resilient distributed systems.

4. **Production-Ready**:
    - **Actuator**: Provides a range of built-in endpoints for monitoring and managing applications (e.g., health checks, metrics).
    - **Externalized Configuration**: Simplifies managing different environments through external configuration.

5. **Community and Ecosystem**:
    - **Wide Adoption**: Extensive community support and a large ecosystem of tools and libraries.
    - **Integration**: Integrates well with other Spring projects and third-party tools.

3. 
- Inversion of Control (IoC) is a design principle in software engineering that inverts the flow of control in a system compared to traditional procedural programming. In traditional programming, the custom code calls library functions to perform tasks. In IoC, the framework or container manages the control flow and calls custom code when needed.
- Dependency Injection (DI) is a design pattern and a specific form of IoC where dependencies (i.e., objects that a class needs to perform its functions) are provided to the class by an external entity, typically a framework or container.

4. 
The @ComponentScan annotation in Spring is used to specify the base packages to scan for Spring components. It is part of the Spring framework's way of enabling automatic detection of Spring components, such as @Component, @Service, @Repository, and @Controller annotations, and registering them as beans in the Spring application context.

By default, @ComponentScan scans the package of the class with the annotation, but it can be customized to scan other packages as well.

5. 
The @SpringBootApplication annotation is a convenience annotation that combines several other annotations commonly used in Spring Boot applications. It serves as the entry point for a Spring Boot application and triggers the auto-configuration and component scanning features of Spring Boot.

Composition

The @SpringBootApplication annotation is a combination of the following three annotations:

- @Configuration: Indicates that the class can be used by the Spring IoC container as a source of bean definitions.
- @EnableAutoConfiguration: Tells Spring Boot to start adding beans based on classpath settings, other beans, and various property settings.
- @ComponentScan: Enables component scanning so that the web controller classes and other components you create will be automatically discovered and registered as beans in the Spring application context.

6. 
- Using @Component Annotation
   The @Component annotation is a generic stereotype for any Spring-managed component. Spring will automatically detect and register the class as a bean.
``` 
import org.springframework.stereotype.Component;

@Component
public class MyComponent {
public void doSomething() {
System.out.println("Doing something...");
}
}
```
- Using @Service, @Repository, and @Controller Annotations
   These annotations are specializations of @Component, used to indicate service, repository, and controller layers respectively.

```
import org.springframework.stereotype.Service;

@Service
public class MyService {
public void performService() {
System.out.println("Performing service...");
}
}

import org.springframework.stereotype.Repository;

@Repository
public class MyRepository {
public void save() {
System.out.println("Saving data...");
}
}

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@Controller
public class MyController {
@GetMapping("/hello")
public String sayHello() {
return "Hello, World!";
}
} 
```

- Using @Bean Annotation in a Configuration Class
   The @Bean annotation is used to explicitly declare a single bean, typically in a @Configuration class.

``` 
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig {

    @Bean
    public MyBean myBean() {
        return new MyBean();
    }
}

public class MyBean {
public void doSomething() {
System.out.println("Doing something...");
}
}
```
- Using XML Configuration
   Beans can also be defined in an XML configuration file.
``` 
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="myBean" class="com.example.MyBean"/>
</beans>
```

``` 
public class MyBean {
    public void doSomething() {
        System.out.println("Doing something...");
    }
}
```
- Using Java-based Configuration with @ComponentScan
When using Java-based configuration, you can enable component scanning to automatically detect and register beans annotated with @Component, @Service, @Repository, and @Controller.
``` 
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan(basePackages = "com.example")
public class AppConfig {
// Configuration code
} 
```
7. 
The default bean name for a class annotated with @Component is the name of the class with the first letter in lowercase. 

The default bean name for a method annotated with @Bean is the name of the method itself.

- @Component

Purpose: Used to annotate a class at the class level to indicate that it is a Spring component. It is a specialization of the @Component stereotype.

Detection: Detected during classpath scanning. Spring automatically detects classes annotated with @Component, @Service, @Repository, and @Controller during the component scanning process.

Default Bean Name: The default bean name is the class name with the first letter in lowercase.

Use Case: Suitable for automatic registration of beans, especially when the bean does not need any specific configuration or custom logic for creation.

- @Bean

Purpose: Used to annotate a method in a @Configuration class to indicate that it returns a bean to be managed by the Spring container.

Detection: Methods annotated with @Bean are detected when the @Configuration class is processed by Spring.

Default Bean Name: The default bean name is the name of the method.

Use Case: Suitable for explicit bean declaration, especially when the bean needs specific configuration, custom initialization logic, or depends on other beans.

8. 
### Summary of Differences Between `@Component`, `@Service`, `@Repository`, and `@Controller`

| Aspect               | `@Component`                             | `@Service`                               | `@Repository`                            | `@Controller`                            |
|----------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
| **Purpose**          | Generic stereotype annotation            | Indicates a service component            | Indicates a repository component         | Indicates a controller component         |
| **Layer**            | Any layer                                | Service layer                            | Data access layer                        | Presentation layer                       |
| **Additional Semantics** | None                                   | Semantics for business logic             | Exception translation for data access    | Semantics for handling web requests      |
| **Usage Example**    | Any Spring-managed component             | Service beans                            | DAO beans                                | Web controllers                          |
| **Default Bean Name**| Class name with first letter lowercase   | Class name with first letter lowercase   | Class name with first letter lowercase   | Class name with first letter lowercase   |

#### When to Use Each

- **Use `@Component`**: For any Spring-managed bean that doesn’t fall into the service, repository, or controller categories.
- **Use `@Service`**: For service layer beans that contain business logic.
- **Use `@Repository`**: For data access layer beans (DAOs) that interact with the database. It also provides automatic exception translation.
- **Use `@Controller`**: For web controller beans that handle HTTP requests and responses in a Spring MVC application.

By using these specific annotations, you provide better semantic meaning to your code, which makes it easier to understand the role of each component in your application architecture. Additionally, some of these annotations provide additional features or behaviors, such as exception translation for `@Repository` or request handling for `@Controller`.


9. 
- The @Autowired annotation is used for automatic dependency injection in Spring. It can be applied to constructors, methods, fields, or other constructors to inject the dependencies.
- The @Qualifier annotation is used in conjunction with @Autowired to resolve ambiguity when multiple beans of the same type are present. It specifies which bean should be injected.
- The @Resource annotation is part of JSR-250 and can be used to inject a bean by name (and type if the name is not specified). It is a more general-purpose dependency injection annotation.
- The @Primary annotation is used to specify a default bean to be injected when multiple beans of the same type are available. It indicates that the annotated bean should be given preference when autowiring by type.

10. 
In Spring, there are several annotations you can use to inject a bean into another bean. These annotations support different types of dependency injection such as constructor injection, setter injection, and field injection.

11. 

Constructor Injection

- Pros:

Immutability: Ensures that dependencies are set at the time of object creation, making the object immutable.
Mandatory Dependencies: Makes it clear which dependencies are required by the class.
Testability: Simplifies testing by allowing dependencies to be provided through constructors.
- Cons:

Complexity: Can lead to large constructors if a class has many dependencies.
Boilerplate Code: May result in more boilerplate code, especially for complex objects.


Setter Injection

- Pros:

Flexibility: Allows for optional dependencies to be set after object creation.
Readability: Can make classes more readable by separating the injection of dependencies from object creation.

- Cons:

Partial Initialization: The object can be in an invalid state if dependencies are not set before use.
Immutability: Does not support immutability since dependencies can be changed after object creation.

Field Injection
- Pros:

Simplicity: Requires the least amount of boilerplate code.
Conciseness: Keeps the class concise by avoiding the need for constructor or setter methods.
- Cons:

Testability: Harder to test since dependencies are hidden and cannot be set easily without reflection.
Immutability: Does not support immutability as fields can be changed.
Visibility: Violates encapsulation by making fields directly accessible.

12. 
- The @Primary annotation is used to indicate that a bean should be given preference when multiple candidates are qualified to be autowired. This bean will be used as the default unless a specific bean is explicitly specified.
- The @Qualifier annotation is used to specify which bean should be injected when there are multiple beans of the same type. This can be used in combination with @Autowired.
- Naming Beans Explicitly: You can also name your beans explicitly and use these names to refer to the beans when autowiring.
- If there are multiple beans of the same type and none is marked as @Primary, and no @Qualifier is used to specify the bean, Spring will fail to resolve the dependency and throw an exception indicating that it found multiple beans.

13. 
### Comparison Between `BeanFactory` and `ApplicationContext` in Spring Framework

| Feature                     | `BeanFactory`                             | `ApplicationContext`                         |
|-----------------------------|-------------------------------------------|---------------------------------------------|
| **Initialization**          | Lazy initialization                      | Eager initialization by default             |
| **Internationalization**    | Not supported                             | Supported                                   |
| **Event Propagation**       | Not supported                             | Supported                                   |
| **AOP Integration**         | Limited                                   | Full integration                            |
| **BeanPostProcessor**       | Must be registered manually               | Automatically registered                    |
| **BeanFactoryPostProcessor**| Must be registered manually               | Automatically registered                    |
| **Resource Loading**        | Basic                                     | Advanced                                    |
| **Environment Abstraction** | Not supported                             | Supported                                   |
| **Use Case**                | Lightweight and resource-constrained scenarios | Enterprise applications requiring advanced features |

### Use Cases

**BeanFactory**:
- Suitable for lightweight applications or scenarios where resource usage is a critical concern.
- Useful for applications where advanced features of `ApplicationContext` are not required.

**ApplicationContext**:
- Suitable for most enterprise applications due to its advanced features.
- Recommended for web applications, where features like internationalization, event handling, and AOP integration are commonly needed.

### Conclusion

- **BeanFactory** is a simpler, more lightweight container that provides basic dependency injection and lifecycle management. It is suitable for scenarios with resource constraints and where advanced features are not necessary.
- **ApplicationContext** is a more feature-rich container that builds on top of `BeanFactory` and provides additional capabilities such as internationalization, event propagation, AOP integration, and environment abstraction. It is the preferred choice for most Spring applications, especially enterprise-level applications.

Choosing between `BeanFactory` and `ApplicationContext` depends on the specific requirements of the application, but in general, `ApplicationContext` is recommended due to its comprehensive feature set.

14.- 

1. Singleton Scope (singleton)
   Description: The default scope in Spring. Ensures that a single instance of the bean is created per Spring IoC container.
   Lifecycle: The bean is created when the container is initialized and is shared across the application.
   Use Case: Stateless beans, service objects, and data access objects.
   Example:


``` 
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

@Component
@Scope("singleton")
public class SingletonBean {
// Bean definition
}
```
2. Prototype Scope (prototype)
   Description: Creates a new instance of the bean every time it is requested from the Spring container.
   Lifecycle: The bean is created and initialized each time it is requested and is not managed after initialization.
   Use Case: Stateful beans, beans with dynamic state, or per-invocation instances.
   Example:
``` 
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;
@Component
@Scope("prototype")
public class PrototypeBean {
// Bean definition
}
```

3. Request Scope (request)
   Description: Creates a new instance of the bean for each HTTP request. This scope is valid only in the context of a web-aware Spring ApplicationContext.
   Lifecycle: The bean is created at the beginning of a request and destroyed at the end of the request.
   Use Case: Web applications, request-specific data or state.
   Example:
``` 
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;
import org.springframework.web.context.annotation.RequestScope;

@Component
@RequestScope
public class RequestBean {
// Bean definition
} 
```
4. Session Scope (session)
   Description: Creates a new instance of the bean for each HTTP session. This scope is valid only in the context of a web-aware Spring ApplicationContext.
   Lifecycle: The bean is created at the beginning of a session and destroyed when the session ends.
   Use Case: Web applications, session-specific data or state.
   Example:
``` 
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;
import org.springframework.web.context.annotation.SessionScope;

@Component
@SessionScope
public class SessionBean {
// Bean definition
} 
```
5. Global Session Scope (globalSession)
   Description: Similar to the session scope but for global HTTP sessions. This scope is typically used in portlet-based web applications.
   Lifecycle: The bean is created at the beginning of a global session and destroyed when the global session ends.
   Use Case: Portlet applications, global session-specific data or state.
   Example:
``` 
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;
import org.springframework.web.context.annotation.SessionScope;

@Component
@Scope("globalSession")
public class GlobalSessionBean {
// Bean definition
} 
```
6. Application Scope (application)
   Description: Creates a single instance of the bean per ServletContext. This scope is valid only in the context of a web-aware Spring ApplicationContext.
   Lifecycle: The bean is created when the web application is started and destroyed when the web application is stopped.
   Use Case: Web applications, application-wide shared data or state.
   Example:
``` 
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;
import org.springframework.web.context.annotation.ApplicationScope;

@Component
@ApplicationScope
public class ApplicationBean {
// Bean definition
} 
```
7. WebSocket Scope (websocket)
   Description: Creates a new instance of the bean for each WebSocket session. This scope is valid only in the context of a web-aware Spring ApplicationContext.
   Lifecycle: The bean is created at the beginning of a WebSocket session and destroyed when the WebSocket session ends.
   Use Case: WebSocket applications, session-specific data or state.
   Example:
``` 
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;
import org.springframework.web.context.annotation.ApplicationScope;

@Component
@Scope("websocket")
public class WebSocketBean {
// Bean definition
} 
```
15. 
If the bean has parameters or dependencies, you can specify these using constructor-arg elements for constructor injection or property elements for setter injection.
``` 
package com.example;

public class MyBean {
    private final MyDependency myDependency;

    public MyBean(MyDependency myDependency) {
        this.myDependency = myDependency;
    }

    public void doSomething() {
        myDependency.execute();
    }
}

package com.example;

public class MyDependency {
    public void execute() {
        System.out.println("Dependency executed!");
    }
}

```

``` 
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="myDependency" class="com.example.MyDependency"/>
    
    <bean id="myBean" class="com.example.MyBean">
        <constructor-arg ref="myDependency"/>
    </bean>
</beans>
```
16. 
MyBean.java:

``` 
package com.example;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class MyBean {

    private final MyDependency myDependency;
    private String message;

    @Autowired
    public MyBean(MyDependency myDependency) {
        this.myDependency = myDependency;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public void doSomething() {
        System.out.println("Message: " + message);
        myDependency.execute();
    }
}
```

MyDependency.java:
``` 
package com.example;

import org.springframework.stereotype.Component;

@Component
public class MyDependency {
public void execute() {
System.out.println("Dependency executed!");
}
}
```

Configuration Class

Create a configuration class to configure the beans if needed.

AppConfig.java:

``` 
package com.example;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig {

    @Bean
    public MyBean myBean(MyDependency myDependency) {
        MyBean myBean = new MyBean(myDependency);
        myBean.setMessage("Hello, Spring Boot!");
        return myBean;
    }
}
```

Spring Boot Application

Finally, set up the Spring Boot application.

MainApp.java:

``` 
package com.example;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;

@SpringBootApplication
public class MainApp {

    public static void main(String[] args) {
        SpringApplication.run(MainApp.class, args);
    }

    @Bean
    public CommandLineRunner commandLineRunner(MyBean myBean) {
        return args -> {
            myBean.doSomething();
        };
    }
}
```

