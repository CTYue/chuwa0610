## 2. Compare Spring and Spring boot? What are the benfits of Srping boot?
1. Spring boot provides standalone apps
2. Spring boot contains embedded servers such as Tomcat and Jetty
3. Spring boot provides varies starters packages, which simplifies the project configuration
4. Spring boot supports auto configuration. It can automatically configure the Spring framework whenever possible.
5. Spring boot provides production ready features such as metrics, health check.
6. No XML configuration is required in Spring boot.

## 3. What is IOC and what is DI?
IOC(Inversion of Control) is one of the core features of Spring that provides a streamlined way to configure and manage Java objects. These container is responsible for managing the lifecycle of a defined Java object, significantly increasing configurability of a Spring based application.  
DI(Dependency injection) is to tell Spring to inject the bean for the variable. The four common ways of DI are:
1. **Constructor injection**: constructor parameter receives dependencies during bean construction
2. **Field injection**: allows direct injection into field declaration without constructor or method delegation. This method is not recommended.
3. **Setter injection**: uses Java setter method to inject dependency.
4. **Method injection**: allows setting one or many dependencies by one method, and for initialization work if needed, while receiving dependencies.

## 4. What is `@ComponentScan`?
`@ComponentScan` annotation defines where Spring should scan the bean definations and generate the beans.
```
@Configuration
@ComponentScan(basePackages = {"com.chuwa.springbasic"})
public class BeanConfig {
   // ...
}
```

## 5. What is `@SpringbootApplication`?
`@SpringbootApplication` is combination of three annotations: 
- `@EnableAutoConfigration`: allows the application to add beans using classpath definitions
- `@Configuration`: declares a class as the source for bean definitions
- `@ComponentScan`: directs Spring to search for components in the path specified

## 6. How many ways to define a bean? Provide code examples.
### 1. Method-level Configuration  
Utilizes `@Bean` with `@Configuration` to define a method as a Spring bean.
```
@Configuration
public class AppConfig {
    @Bean
    public MyBean myBean() {
        return new MyBean();
    }
}
```
### 2. Class-level Configuration
Uses `@Component`, `@Service`, `@Repository`, `@Controller` to define a class as a Spring bean
```
@Component
public class myBean(){// ...}
```
### 3. XML-based Configuration
Beans are defined in an XML file, which Spring loads at runtime.
```
<beans>
    <bean id="myBean" class="com.example.MyBean"/>
</beans>
```

## 7. What is default bean name for @Component and @Bean? Also compare @Component and @Bean .
When using class-level annotaions such as `@Component`, `@Service`, and `@Controller`, the default bean name is the class name and Spring will convert the first letter to lowercase.
For method-level annotation `@Bean`, the method name will be the bean name. If `@Qualifier` is used along with `@Bean`, the name specified by the `@Qualifier` will be the bean name.  
`@Component` is a class-level annotation that is used to mark a class as Spring component. `@Bean` is a method-level annotation that marks a method as Spring component.

## 8. Compare @component and @service, @repository, @controller?
@service, @repository, @controller are specialization of @Component annotation. They are all class-level annotations.
- `@Component` - used to denote a class as a Component. We can use @Component across the application to mark the beans as Springâ€™s managed components.
- `@Service` - indicates that a class belongs to the business logic layer
- `@Repository` - indicates that the class provides the mechanism for storage, retrieval, update, delete and search operation on object.
- `@Controller` - indicates that a particular class serves the role of a controller. It is typically used in combination with annotated handler methods based on the `@RequestMapping` annotation and marks a class as a web request handler.

## 9. Explain @Autowired , @Qualifier , @Resource and @Primary ?
- `@Autowired` annotation marks a constructor, setter method, properties and Config() method as to be autowired that is injecting beans at runtime by Spring dependency injection.
- `@Qualifier` annotation is used to differentiate beans when there are multiple beans of the same type. It allows for more fine-grained control over which bean is injected in a specific scenario by specifying an identifier that is used at injection time.
```
@Bean
@Qualifier("primary")
public ModelMapper modelMapper() {
   return new ModelMapper();
}
```
- `@Resource` annotation is part of the Java Common Annotations (JSR-250) and serves a similar purpose as @Autowired in Spring but with a key difference. @Resource can inject dependencies by name rather than by type.
```
@Resource(name="mysqlDataSource")
private DataSource dataSource;
```
- `@Primary` annotation gives a bean a higher priority when multiple beans of the same type exist. When using autowiring by type (@Autowired), Spring will prefer to inject the bean marked with @Primary if it's available.
```
@Bean
@Primary
public ModelMapper modelMapper() {
   return new ModelMapper();
}
```

## 10. How many annotaitons we can use to inject a bean?
- `@Autowired` annotation marks a constructor, setter method, properties and Config() method as to be autowired that is injecting beans at runtime by Spring dependency injection.
- `@Resource` annotation is part of the Java Common Annotations (JSR-250) and serves a similar purpose as @Autowired in Spring but with a key difference. @Resource can inject dependencies by name rather than by type.
```
@Resource(name="mysqlDataSource")
private DataSource dataSource;
```
- `@Inject` is used to indicate that a class member (such as a field, a constructor, or a method) should be injected with a dependency provided by the container managing the class's lifecycle.
```
@Inject
public MyService(DependencyService dependencyService) {
   this.dependencyService = dependencyService;
}
```

## 11. Explain and compare differnet types of denpendency injection, their pros and cons, and use cases.
The four common ways of DI are:
1. **Constructor injection**: constructor parameter receives dependencies during bean construction
2. **Field injection**: allows direct injection into field declaration without constructor or method delegation. This method is not recommended.
3. **Setter injection**: uses Java setter method to inject dependency.
4. **Method injection**: allows setting one or many dependencies by one method, and for initialization work if needed, while receiving dependencies.  
Official Recommendation: It is good rule of thumb to use **Constructor** for mandatory dependencies and setter methods or configuration methods for optional dependencies. The Spring team generally advocates **Constructor** injection.

## 12. If we have multiple beans for one type, how to set one is primary? and how Spring IOC picks one bean to inject if no primary.
We can set a bean as primary with `@Primary` annotation:
```
@Bean
@Primary
public ModelMapper modelMapper() {
   return new ModelMapper();
}
```
If no primary bean is presented, Spring will check for the `@Qualifier` name. If no `@Qualifier` as well, Spring will raise an exception during autowiring process.

## 13. Compare BeanFactory and ApplicationContext in Spring framework?
### BeanFactory
It is a fundamental container that provides the basic functionality for managing beans. It is suitable to build standalone applications. It supports only Singleton and Prototype bean scopes and does not support annotations. we need to configure the properties in XML files only.   
BeanFactory will create a bean object when the getBean() method is called thus making it Lazy initialization.
### ApplicationContext
It is an advanced container that extends the BeanFactory that provides all basic functionality and adds some advanced features. It is suitable to build Web applications, integration with AOP modules, ORM and distributed applications. It supports all types of bean scopes such as Singleton, Prototype, Request, Session etc.  
It supports Annotation based configuration in Bean Autowiring. ApplicationContext loads all the beans and creates objects at the time of startup only thus making it Eager initialization.

## 14. Explain bean scope in Spring IOC? List bean scopes with explainations and code examples if possible.
- **Singleton**: is the default scope of a bean. Means one instance per application context, shared instance will be accessed by other components. It is used for beans that do not hold state or where the same state is to shared by all users or threads.
- **Prototype**: a new instance is created each time a bean is requested from the container. It is useful for beans to carry state that is specific to other user or thread thus can't be shared.
- **Request**: only valid in the context of web Spring application context for a single HTTP request. A new bean is created for each HTTP request.
- **Session**: only valid in the context of web Spring application context of an HTTP session. A new bean is created for each HTTP session.
- **Application**: context for the lifecycle of a servlet context. It is scoped at the application level.
- **Websocket**: context for the lifecycle of a web socket. It is scoped at the web socket level.  
There are two ways to define the bean scope
1. `@Scope()`
```
@Bean
@Scope("prototype")
public Bean bean(){// ...}
```
2. `@SessionScope`, `@RequestScope`...
```
@Bean
@SessionScope
public Bean bean(){// ...}
```

## 15. Configure a bean using xml. If bean has parameters/dependencies, how can we configure the bean?
```
<bean id="myDataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
    <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
    <property name="username" value="user"/>
    <property name="password" value="pass"/>
</bean>
```

## 16 Do Q15 without xml, use Springboot IOC annotations instead.
```
@Component
public class MyDatabaseComponent {

    private final DataSource dataSource;

    @Autowired
    public MyDatabaseComponent(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}
```
application.properties
```
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=user
spring.datasource.password=pass
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
```