## hw11

2. Compare Spring and Springboot? What are the benfits of Srpingboot? 

   >| **Spring**                                                   | **Spring Boot**                                      |
   >| ------------------------------------------------------------ | ---------------------------------------------------- |
   >| provides a Dependency Injection feature                      | provides autoconfiguration                           |
   >| doesn’t provide any server for testing (developers need to set it up manually) | provides embedded servers (such as Tomcat and Jetty) |
   >| needs a lot of a boilerplate code                            | doesn’t require a lot of boilerplate code            |
   >| doesn’t provide an in-memory database                        | provides several in-memory databases                 |
   >| doesn’t provide automation tools for defining dependencies   | handles the dependencies automatically               |
   >
   >Spring boot makes building the application much more efficient.

3. What is IOC and What is DI? 

   >IoC is a design principle where the control flow of the program is inverted
   >
   >The Container uses Dependency Injection(DI) to manage the components that make up the application. **Dependency Injection** is a design pattern used to implement IoC, allowing a program to follow the dependency inversion principle.

4. What is @CompnonentScan ? 

   >@CompnonentScan is used to tell spring where to find the annotated components

5. What is @SpringbootApplication ? 

   >@SpringbootApplication is the combination of @Configuration, @EnableAutoConfiguration and @ComponentScan. @Configuration , which declares a class as the source for bean definitions. @EnableAutoConfiguration , which allows the application to add beans using classpath definitions @ComponentScan , which directs Spring to search for components in the path specified

6. How many ways to define a bean? Provide code examples. 

   >@Component 
   >
   >```java
   >@Component
   >public class Car {
   >}
   >```
   >
   >@Bean
   >
   >```Java
   >@Configuration
   >public class AppConfig {
   >    @Bean
   >    public Car car() {
   >        return new Car();
   >    }
   >}
   >```
   >
   >XML
   >
   >```xml
   ><!-- applicationContext.xml -->
   ><beans xmlns="http://www.springframework.org/schema/beans"
   >       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   >       xsi:schemaLocation="http://www.springframework.org/schema/beans
   >       http://www.springframework.org/schema/beans/spring-beans.xsd">
   >
   >    <bean id="car" class="com.example.app.Car"/>
   ></beans>
   >```

7. What is default bean name for @Component and @Bean ? Also compare @Component and @Bean . 

   >@Component: uncapitalized non-qualified class name
   >
   >@Bean: method name
   >
   >Opt for `@Bean` when you need more control over bean instantiation, or when you need to configure beans that are not easily defined by class-only component scanning, such as when creating beans for third-party classes or when configuring complex dependencies.

8. Compare @component and @service , @repository , @controller ? 

   >**@Component** is the most generic Spring annotation, a generic stereotype for any Spring-managed component. `@Component` is used to denote a component where the specific role (Controller, Service, Repository) isn't applicable. 
   >
   >**@Service** is a specialization of `@Component`. It is used in the service layer and doesn't offer any additional behavior over `@Component`, but it provides better indication of the intended service layer semantics.
   >
   >**@Repository** is another specialization of `@Component`. It is used in the data access layer, directly tied with database operations. `@Repository` has an added benefit over `@Component` as it encapsulates storage, retrieval, and search behavior. Additionally, classes annotated with `@Repository` are eligible for Spring DataAccessException translation, meaning that Spring can convert SQL Exceptions into unchecked exceptions that are more meaningful within the context of an ORM/framework.
   >
   >**@Controller** is also a specialization of `@Component` used in the presentation layer, especially suitable for MVC applications. It indicates that the class serves the role of a controller in the Spring MVC (or Spring WebFlux) framework. Controllers typically have methods that handle HTTP requests and return responses.

9. Explain @Autowired , @Qualifier , @Resource and @Primary ? 

   >`@Autowired` is used to automatically inject dependencies into your Spring beans.
   >
   >`@Qualifier` is used to resolve the autowiring conflict, when there are multiple beans of the same type. It is used to specify which bean to inject by giving the bean's name or identifier.
   >
   >`@Resource` injects dependencies by name.
   >
   >If Spring finds multiple beans of the same type and only one of them is marked as `@Primary`, it will choose the `@Primary` bean for autowiring.

10. How many annotaitons we can use to inject a bean? 

    >@Autowire
    >
    >@Resource
    >
    >@Inject
    >
    >@Value
    >
    >@Lookup
    >
    >@Bean
    >
    >@Component

11. Explain and compare differnet types of denpendency injection, their pros and cons, and use cases. 

    >***Constructor injection***
    >
    >Pros:
    >
    >- Explicit contract: The constructor clearly defines required dependencies, promoting code clarity and maintainability.
    >- Enforced dependencies: Mandatory dependencies are enforced at object creation, preventing runtime errors due to missing dependencies.
    >- Testing support: Dependencies are explicitly passed, simplifying mocking for [unit testing](https://www.spiceworks.com/tech/devops/articles/what-is-unit-testing/).
    >
    >Cons:
    >
    >- Constructor clutter: Classes with many dependencies can lead to cluttered constructor signatures, potentially affecting readability.
    >- Testing challenges: Mocking constructors might be required for testing, adding slight complexity.
    >
    >***Setter injection*** 
    >
    >Pros:
    >
    >- Flexibility: Offers more flexibility for setting dependencies after object creation, potentially useful for dynamic configurations.
    >
    >Cons**:**
    >
    >- Implicit contract: Dependency declaration is less explicit than constructor injection, potentially reducing code clarity.
    >- Null checks: It is crucial to check for null before using the dependency, as setter methods might not be called during configuration, leading to potential runtime errors (NullPointerException).
    >
    >***Field injection***
    >
    >Pros:
    >
    >- Lifecycle flexibility: This method offers greater flexibility for injecting dependencies at different points in the object’s lifecycle, potentially useful for complex scenarios.
    >
    >Cons:
    >
    >- Complexity: This is the least common approach and can lead to more complex code due to the requirement for additional interfaces and methods.
    >- Rare use case**:** Method injection is often considered an over-engineering approach with limited practical applications.

12. If we have multiple beans for one type, how to set one is primary? and how Spring IOC picks one bean to inject if no primay. 

    >```java
    >@Configuration
    >public class AppConfig {
    >
    >    @Bean
    >    @Primary
    >    public MyService myPrimaryService() {
    >        return new MyService("Primary Service");
    >    }
    >
    >    @Bean
    >    public MyService mySecondaryService() {
    >        return new MyService("Secondary Service");
    >    }
    >}
    >```
    >
    >1. 如果只有⼀个impl,则默认⽤这个impl
    >2.  如果有多个impl, 则查看是否有@Qualifier 
    >3. 如果有多个impl, 且⽆@Qualifier, 按变量名(By Name) 
    >4. 如果有多个impl, 且⽆@Qualifier, 按变量名(By Name)不⾏， 则查看是否有@Primary (因为这个 是type level的) 
    >5. 若⽆，则报错 (NoUniqueBeanDefinitionException)

13. Compare BeanFactory and ApplicationContext in Spring framework? 

    >The BeanFactory provides the configuration framework and basic functionality, while the ApplicationContext adds enhanced capabilities to it
    >
    >|                         BeanFactory                          |                      ApplicationContext                      |
    >| :----------------------------------------------------------: | :----------------------------------------------------------: |
    >| It is a fundamental container that provides the basic functionality for managing beans. | It is an advanced container that extends the BeanFactory that provides all basic functionality and adds some advanced features. |
    >|       It is suitable to build standalone applications.       | It is suitable to build Web applications, integration with AOP modules, ORM and distributed applications. |
    >|    It supports only Singleton and Prototype bean scopes.     | It supports all types of bean scopes such as Singleton, Prototype, Request, Session etc. |
    >| It does not support Annotations. In Bean Autowiring, we need to configure the properties in XML file only. | It supports Annotation based configuration in Bean Autowiring. |
    >| This interface does not provides messaging (i18n or internationalization) functionality. | ApplicationContext interface extends MessageSource interface, thus it provides messaging (i18n or internationalization) functionality. |
    >| BeanFactory does not support Event publication functionality. | Event handling in the ApplicationContext is provided through the ApplicationEvent class and ApplicationListener interface. |
    >| In BeanFactory, we need to manually register BeanPostProcessors and BeanFactoryPostProcessors. | The ApplicationContext automatically registers BeanFactoryPostProcessor and BeanPostProcessor at startup. |
    >| BeanFactory will create a bean object when the getBean() method is called thus making it Lazy initialization. | ApplicationContext loads all the beans and creates objects at the time of startup only thus making it Eager initialization. |
    >| BeanFactory interface provides basic features only thus requires less memory. For standalone applications where the basic features are enough and when memory consumption is critical, we can use BeanFactory. | ApplicationContext provides all the basic features and advanced features, including several that are geared towards enterprise applications thus requires more memory. |

14.  Explain bean scope in Spring IOC? List bean scopes with explainations and code examples if possible. 

    >| Scope          | Description                                                  |
    >| -------------- | ------------------------------------------------------------ |
    >| singleton      | This scopes the bean definition to a single instance per Spring IoC container (default). |
    >| prototype      | This scopes a single bean definition to have any number of object instances. |
    >| request        | This scopes a bean definition to an HTTP request. Only valid in the context of a web-aware Spring ApplicationContext. |
    >| session        | This scopes a bean definition to an HTTP session. Only valid in the context of a web-aware Spring ApplicationContext. |
    >| global-session | This scopes a bean definition to a global HTTP session. Only valid in the context of a web-aware Spring ApplicationContext. |

15. Configure a bean using xml. If bean has parameters/dependencies, how can we configure the bean? 

    >Setters or Injecting Primitive Values
    >
    >```xml
    ><?xml version="1.0" encoding="UTF-8"?>
    ><beans xmlns="http://www.springframework.org/schema/beans"
    >       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    >       xsi:schemaLocation="
    >           http://www.springframework.org/schema/beans
    >           http://www.springframework.org/schema/beans/spring-beans.xsd">
    >
    >    <bean id="myService" class="com.example.MyService"/>
    >    <bean id="myService" class="com.example.MyService">
    >      <property name="myRepository" ref="myRepository"/>
    >      <!--<property name="serviceName" value="ExampleService"/>-->
    >  </bean>
    ></beans>
    >```
    >
    >```java
    >package com.example;
    >
    >public class MyService {
    >    private MyRepository myRepository;
    >
    >    // Setter method
    >    public void setMyRepository(MyRepository myRepository) {
    >        this.myRepository = myRepository;
    >    }
    >}
    >```
    >
    >Constructor
    >
    >```java
    >public class MyService {
    >    private MyRepository myRepository;
    >
    >    // Constructor
    >    public MyService(MyRepository myRepository) {
    >        this.myRepository = myRepository;
    >    }
    >}
    >```
    >
    >```xml
    ><bean id="myService" class="com.example.MyService">
    >    <constructor-arg ref="myRepository"/>
    ></bean>
    >```

16. Do Q15 without xml, use Springboot IOC annotations instead.

    >```java
    >@Service
    >public class BookService {
    >    private BookRepository bookRepository;
    >  	//@Autowired
    >    //private BookRepository bookRepository;
    >
    >    @Autowired
    >    public void setBookRepository(BookRepository bookRepository) {
    >        this.bookRepository = bookRepository;
    >    }
    >   	//@Autowired
    >    //public void setBookRepository(BookRepository bookRepository) {
    >      //  this.bookRepository = bookRepository;
    >    //}
    >}
    >```

    