# Hw11
## 1.  List all of the annotations you learned from class and homework to annotations.md (your own cheatsheet).
See [annotations.md](annotations.md)
## 2.  Compare Spring and Springboot? What are the benefits of springboot?
- Spring Boot builds on top of the Spring Framework. It is designed to simplify the bootstrapping and development of new Spring applications.
- Easier to use
  - Convention over Configuration: Reduces the need for extensive XML configuration or Java configuration.
  - Starter Dependencies: Simplifies dependency management by providing starter POMs that bundle commonly used dependencies. 
- Rapid Development
  - Embedded Servers: Allows developers to run their applications directly without needing to deploy to an external server, speeding up the development cycle.
  - Auto-Configuration: Automatically configures your application based on the included libraries, reducing boilerplate code.
- Testing Support:
  - Improved Testing: Comes with support for testing Spring Boot applications, including slices for testing specific layers of the application.
## 3.  What is IOC and What is DI?
### Inversion of Control (IoC)
- Inversion of Control is a design principle used to invert the control flow of a program. In traditional programming, the custom code has the control of the flow of the program, whereas, in IoC, the control is inverted. 
- The control of these responsibilities is handed over to the Spring IoC container. The container is responsible for instantiating, configuring, and managing the lifecycle of objects (beans).
- Use to increase modularity and make the code more decoupled and easier to manage.
### Dependency Injection (DI)
- It is a specific implementation of the IoC principle. It involves injecting the dependencies of a class from the outside rather than the class itself creating them.
- Common DI:
  - Constructor Injection
    ```java
    public class Service {
        private final Repository repository;
    
        public Service(Repository repository) {
            this.repository = repository;
        }
    }

    ```
  - Setter Injection 
  ```java
    public class Service {
        private Repository repository;

        public void setRepository(Repository repository) {
            this.repository = repository;
        }
    }

  ```
  - Field Injection
  ```java
    public class Service {
        @Autowired
        private Repository repository;
    }

    ```
## 4.  What is  @ComponentScan ?
- An annotation in the Spring Framework used to specify the base packages to scan for annotated components. This is an essential part of the Spring configuration that enables automatic discovery of Spring components such as @Component, @Service, @Repository, and @Controller.
- Used to allow Spring to scan the specified packages and register the beans with the Spring application context automatically
- Usually annotated with @Configuration
```java
@Configuration
@ComponentScan(basePackages = "com.example.myapp")
public class AppConfig {
    // Other bean definitions
}
```
## 5.  What is  @SpringbootApplication ?
- It is a combination of 3 annotations @Configuration, @EnableAutoConfiguration, and @ComponentScan
- It is used to mark a configuration class that declares one or more @Bean methods and also triggers auto-configuration and component scanning.
- Usually put in the main class
```java
@SpringBootApplication
public class MyApp {
    public static void main(String[] args) {
        SpringApplication.run(MyApp.class, args);
    }
}
```
## 6.  How many ways to define a bean? Provide code examples.
### Use @Bean in a @Configuration class
```java
@Configuration
public class AppConfig {
    @Bean
    public MyBean myBean() {
        return new MyBean();
    }
}

public class MyBean {
    public void doSomething() {
        System.out.println("Doing something in MyBean");
    }
}
```
### Using XML Configuration
```xml
<!-- applicationContext.xml -->
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans.xsd">
    
    <bean id="myXmlBean" class="com.example.MyXmlBean"/>
</beans>

```
```java
public class MyXmlBean {
    public void doSomething() {
        System.out.println("Doing something in MyXmlBean");
    }
}

```
### Use Java Configuration with @ComponentScan
```java
@Configuration
@ComponentScan(basePackages = "com.example")
public class AppConfig {
    // No explicit bean definitions needed, components will be scanned
}


// MyComponent.java
@Component
public class MyComponent {
  public void doSomething() {
    System.out.println("Doing something in MyComponent");
  }
}
```
### Using @Component and Stereotype Annotations
- Spring provides several stereotype annotations, including @Component, @Service, @Repository, and @Controller, to define beans.
```java

@Component
//@Service 
//@Repository 
//@Controller
public class Foo {
    public void doSomething() {
        System.out.println("Doing something");
    }
}

```
## 7.  What is default bean name for  @Component  and  @Bean ? Also compare  @Component  and  @Bean .
### @Component
- Mark a class as Spring managed component
- Requires @ComponentScan to find and register beans automatically
- The default bean name for a class annotated with @Component is the class name with the first letter in lowercase
```java
@Component
public class MyService {
    // Bean name will be "myService"
}

```
### @Bean
- Used to declare a single bean in the @Configuration class
- Does not require component scanning. Each bean is explicitly declared in a method.
- Offers more control of the configuration of beans
- Can be used to create and configure third-party classes.
- The default bean name for a method annotated with @Bean is the name of the method itself.
```java
@Configuration
public class AppConfig {
    @Bean
    public MyBean myBean() {
        return new MyBean();
    }
    // Bean name will be "myBean"
}
```

## 8.  Compare  @component  and  @service , @repository ,  @controller ?
### @Component
- A generic stereotype for any Spring-managed component.
- Can be used to annotate any class to make it a Spring bean.
- No specific additional behavior is associated with it beyond making the class a Spring bean.
```java
@Component
public class MyComponent {
    public void perform() {
        System.out.println("Performing task");
    }
}
```
### @Service
- A specialization of @Component indicating that the annotated class is a service component.
- Used for service layer components, which usually contain business logic.
- No specific additional behavior, but it provides better readability and clarity regarding the class's role in the application.
```java
@Service
public class MyService {
  public void executeService() {
    System.out.println("Executing service");
  }
}
```
### @Repository
-  A specialization of @Component indicating that the annotated class is a repository (or DAO).
- Used for data access layer components.
- In addition to making the class a Spring bean, it also provides exception translation, converting database-related exceptions into Spring's DataAccessException.
```java
@Repository
public class MyRepository {
  public void saveData() {
    System.out.println("Saving data");
  }
}
```
### @Controller
- A specialization of @Component indicating that the annotated class is a web controller.
- Used for presentation layer components, specifically to define web controllers in Spring MVC.
- Used in conjunction with Spring MVC to map web requests to handler methods.
```java
@Controller
public class MyController {
    @GetMapping("/foo")
    public String foo() {
        return "foo";
    }
}
```
## 9.  Explain  @Autowired ,  @Qualifier  ,  @Resource  and  @Primary ?
### @Autowired
- Used to automatically wire a bean to a class field, constructor, or setter method.
- By default, it wires by type. If multiple beans of the same type are available, an exception is thrown
```java
@Component
public class MyComponent {
  @Autowired
  private MyService myService;

  public void doSomething() {
    myService.performService();
  }
}

```
### @Qualifier
-  Used to resolve the ambiguity when multiple beans of the same type are available by specifying the exact bean to be injected.
- Works in conjunction with @Autowired to provide more fine-grained control over which bean should be injected.
```java
@Component
public class MyComponent {
    @Autowired
    @Qualifier("specificService")
    private MyService myService;

    public void doSomething() {
        myService.performService();
    }
}

//=============================================================
@Service("specificService")
public class SpecificService implements MyService {
  public void performService() {
    System.out.println("Specific Service");
  }
}

@Service("anotherService")
public class AnotherService implements MyService {
  public void performService() {
    System.out.println("Another Service");
  }
}

```
### @Resource
- annotation for dependency injection. It can be used similarly to @Autowired, but it wires by name by default.
```java
@Component
public class MyComponent {
    @Resource(name = "specificService")
    private MyService myService;

    public void doSomething() {
        myService.performService();
    }
}
```
### @Primary
- Indicates that a bean should be given preference when multiple candidates qualify for autowiring.
- Works with @Autowired to resolve ambiguity by marking one bean as the primary candidate for dependency injection.
```java
@Service
@Primary
public class PrimaryService implements MyService {
    public void performService() {
        System.out.println("Primary Service");
    }
}

@Service
public class SecondaryService implements MyService {
    public void performService() {
        System.out.println("Secondary Service");
    }
}

@Component
public class MyComponent {
    @Autowired
    private MyService myService;

    public void doSomething() {
        myService.performService(); // Will use PrimaryService
    }
}
```
## 10.  How many annotations we can use to inject a bean?
- @AutoWired: Automatically wires a bean by type. It can be used on fields, constructors, and setter methods.
- @Qualifier: Used in conjunction with @Autowired to specify which bean should be injected when multiple beans of the same type are present.
- @Resource: It injects a bean by name by default and can also inject by type. 
- @Inject: Works similarly to @Autowired, injecting by type. It does not have Spring-specific features like @Qualifier.
```java
@Component
public class MyComponent {
    @Inject
    private MyService myService;
}

```
## 11.  Explain and compare different types of dependency injection, their pros and cons, and use cases.
### Constructor Injection
- involves passing dependencies to a class through its constructor. This means that all dependencies are provided when the class is instantiated.
```java
@Component
public class MyComponent {
    private final MyService myService;

    @Autowired
    public MyComponent(MyService myService) {
        this.myService = myService;
    }

    public void doSomething() {
        myService.performService();
    }
}

```
- Dependencies are set once at the time of object creation and cannot be changed, promoting immutability.
- Makes unit testing easier since dependencies are explicit and can be provided via the constructor.
- The required dependencies are clear from the constructor parameters, making it obvious what the class needs to function.
- Can become verbose if there are many dependencies.
- Can be problematic if there are circular dependencies between classes.
### Setter Injection
-  involves providing dependencies to a class via setter methods after the object has been instantiated.
```java
@Component
public class MyComponent {
    private MyService myService;

    @Autowired
    public void setMyService(MyService myService) {
        this.myService = myService;
    }

    public void doSomething() {
        myService.performService();
    }
}
```
- Dependencies can be changed after object creation, allowing for more flexible configurations.
- Can be used to inject optional dependencies that may not be required for the class to function.
- The object can be in an invalid state if not all dependencies are set before usage.
- Allows dependencies to be changed, which can lead to mutable objects and potential side effects.
### Field Injection
- Field injection involves directly injecting dependencies into fields using annotations.
```java
@Component
public class MyComponent {
    @Autowired
    private MyService myService;

    public void doSomething() {
        myService.performService();
    }
}
```
- Reduces code as there are no need for constructors or setter methods for dependency injection.
- Simple to use and requires minimal setup.
- More difficult to test since dependencies are not visible in constructors or setters, making it harder to mock dependencies.
- Breaks encapsulation by making the dependencies directly accessible as fields.
- Typically relies on reflection, which can have performance implications and make debugging harder.
## 12.  If we have multiple beans for one type, how to set one is primary? and how Spring IOC picks one bean to inject if no primary.
- when there are multiple beans of the same type, one can use the @Qualifier annotation to specify which bean to inject. 
- If no bean is marked Qualifier, one can use the @Primary annotation to indicate which bean should be considered the primary candidate for autowiring.
- If none of @Qualifier and @Primary, spring will try match by name
- If none of these works, spring will throw (NoUniqueBeanDefinitionException)
## 13.  Compare BeanFactory and ApplicationContext in Spring framework?
### BeanFactory
- Root interface for accessing the Spring container. 
- Provides basic mechanisms for bean creation, retrieval, and management.
- Lazy Initialization: Beans are created only when they are requested, not at the time of container startup.
- No Built-in Support for Advanced Features: Lacks support for features like event propagation, declarative mechanisms to create a bean, and internationalization.
- Manual Configuration Required: Requires manual setup for features that are automatically available in ApplicationContext.
- Suitable for lightweight and performance-sensitive applications due to lazy initialization and minimal overhead.
```java
BeanFactory factory = new XmlBeanFactory(new ClassPathResource("beans.xml"));
MyBean myBean = (MyBean) factory.getBean("myBean");
```
### ApplicationContext
- More advanced container that builds on the BeanFactory interface.
- It provides additional features and capabilities, making it more suitable for enterprise applications.
- Eager Initialization: Beans are typically pre-instantiated at the time of container startup (except for lazy-init beans).
- Integration with Spring AOP: Out-of-the-box support for Spring AOP features.
- Supports advanced features such as 
  - Resource Loading: Provides a more flexible way to load resources. 
  - Context Hierarchy: Supports hierarchical contexts, allowing a parent context to be shared across multiple child contexts.
  - Event Propagation: Provides a mechanism to publish and listen to events.
- More suitable for complex applications where the overhead of pre-instantiating beans is acceptable given the advanced features provided.
```java
ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
MyBean myBean = (MyBean) context.getBean("myBean");
```
## 14.  Explain bean scope in Spring IOC?  List bean scopes with explanations and code examples if possible.
### Singleton
- Default in Spring
- Only one instance of the bean is created per Spring IoC container.
- The same instance is shared and reused throughout the container.
- For Stateless beans that are shared across multiple components
```java
@Component
public class SingletonBean {
    // Bean definition
}

@Configuration
public class AppConfig {
    @Bean
    public SingletonBean singletonBean() {
        return new SingletonBean();
    }
}
```
### Prototype Scope
- A new instance of the bean is created each time it is requested from the container.
- Not shared, each request results in a unique bean instance.
- For Stateful beans or beans that need to maintain state across different usage.
```java
@Component
@Scope("prototype")
public class PrototypeBean {
    // Bean definition
}

@Configuration
public class AppConfig {
    @Bean
    @Scope("prototype")
    public PrototypeBean prototypeBean() {
        return new PrototypeBean();
    }
}
```
### Request Scope (Web-aware scope)
- A new instance of the bean is created for each HTTP request.
- Each HTTP request has its own instance of the bean.
- For Beans that are needed per HTTP request, such as request-specific data.
```java
@Component
@Scope("request")
public class RequestScopedBean {
    // Bean definition
}

@Configuration
public class AppConfig {
    @Bean
    @Scope("request")
    public RequestScopedBean requestScopedBean() {
        return new RequestScopedBean();
    }
}
```
### Session Scope (Web-aware scope)
- A new instance of the bean is created for each HTTP session.
- Each HTTP session has its own instance of the bean.
- For Beans that need to store user session data.
```java
@Component
@Scope("session")
public class SessionScopedBean {
    // Bean definition
}

@Configuration
public class AppConfig {
    @Bean
    @Scope("session")
    public SessionScopedBean sessionScopedBean() {
        return new SessionScopedBean();
    }
}
```
### Application Scope (Web-aware scope)
- A single instance of the bean is created for the entire web application.
- Shared across all requests and sessions.
- Beans that need to maintain application-wide state.
```java
@Component
@Scope("application")
public class ApplicationScopedBean {
    // Bean definition
}

@Configuration
public class AppConfig {
    @Bean
    @Scope("application")
    public ApplicationScopedBean applicationScopedBean() {
        return new ApplicationScopedBean();
    }
}
```
### WebSocket Scope (Web-aware scope)
- A new instance of the bean is created for each WebSocket session.
- Each WebSocket session has its own instance of the bean.
- Beans that need to store WebSocket session data.
```java
@Component
@Scope("websocket")
public class WebSocketScopedBean {
    // Bean definition
}

@Configuration
public class AppConfig {
    @Bean
    @Scope("websocket")
    public WebSocketScopedBean webSocketScopedBean() {
        return new WebSocketScopedBean();
    }
}
```
## 15.  Configure a bean using xml. If bean has parameters/dependencies, how can we configure the bean?
- For simple bean we can just configure as following
```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- Simple bean definition -->
    <bean id="myBean" class="com.example.MyBean"/>
</beans>

```
- For bean that has parameters/dependencies we can add <property> to it
```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- Bean definition with property injection -->
    <bean id="myBean" class="com.example.MyBean">
        <property name="name" value="John Doe"/>
        <property name="myService" ref="myService"/>
    </bean>
</beans>
```
## 16.  Do Q15 without xml, use Springboot IOC annotations instead.
- For simple bean we can just configure as following
```java
@Component
public class MyBean {
  public void doSomething() {
    System.out.println("MyBean is doing something");
  }
}

```
- For bean that has parameters/dependencies we can add @Autowired and @Value to it
```java
// MyService class
@Component
public class MyService {
    public void serve() {
        System.out.println("Service is being served");
    }
}

// MyComponent class with field injection
@Component
public class MyComponent {
    @Value("${mycomponent.name}")
    private String name;

    @Autowired
    private MyService myService;

    public void doSomething() {
        System.out.println("Component name: " + name);
        myService.serve();
    }
}
```
In application.properties:
```
mycomponent.name=MyComponentName
```
