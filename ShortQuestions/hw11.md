
2. 
### Comparison Between Spring and Spring Boot

#### Overview

**Spring Framework** is a comprehensive framework for enterprise Java development, providing a wide range of functionalities including IoC, AOP, data access, web MVC, integration, and security.

**Spring Boot** is an extension of the Spring Framework that simplifies the development of stand-alone, production-ready Spring applications with features like auto-configuration, starter POMs, embedded servers, and production-ready tools.

#### Comparison

| Feature                     | Spring Framework                            | Spring Boot                                  |
|-----------------------------|---------------------------------------------|----------------------------------------------|
| **Configuration**           | Requires manual XML or Java-based config    | Auto-configuration reduces manual setup      |
| **Dependencies**            | Manually manage dependencies                | Starter POMs simplify dependency management  |
| **Application Type**        | Requires an external server                 | Stand-alone applications with embedded server|
| **Setup Complexity**        | Can be complex and verbose                  | Simplified and convention-based              |
| **Development Speed**       | Slower due to manual setup                  | Faster with auto-configuration and starters  |
| **Monitoring and Metrics**  | Requires additional setup                   | Built-in with Actuator                       |
| **Microservices Support**   | Supported but requires manual configuration | Optimized for microservices                  |

#### Benefits of Spring Boot

1. **Simplified Setup**:
    - **Auto-Configuration**: Automatically configures many aspects of the application based on the dependencies and settings, reducing the need for manual setup.
    - **Starter Dependencies**: Provides a set of predefined dependencies that make it easy to get started with various Spring projects.

2. **Rapid Development**:
    - **Embedded Servers**: Applications can be run directly from the command line or an IDE without needing an external server, facilitating faster development cycles.
    - **Minimal Configuration**: Reduces boilerplate code and configuration, allowing developers to focus on business logic.

3. **Microservices Ready**:
    - **Modularity**: Ideal for building microservices with minimal setup.
    - **Spring Cloud**: Works seamlessly with Spring Cloud for building scalable, resilient distributed systems.

4. **Production-Ready**:
    - **Actuator**: Provides a range of built-in endpoints for monitoring and managing applications (e.g., health checks, metrics).
    - **Externalized Configuration**: Simplifies managing different environments through external configuration.

5. **Community and Ecosystem**:
    - **Wide Adoption**: Extensive community support and a large ecosystem of tools and libraries.
    - **Integration**: Integrates well with other Spring projects and third-party tools.

3. 
- Inversion of Control (IoC) is a design principle in software engineering that inverts the flow of control in a system compared to traditional procedural programming. In traditional programming, the custom code calls library functions to perform tasks. In IoC, the framework or container manages the control flow and calls custom code when needed.
- Dependency Injection (DI) is a design pattern and a specific form of IoC where dependencies (i.e., objects that a class needs to perform its functions) are provided to the class by an external entity, typically a framework or container.

4. 
The @ComponentScan annotation in Spring is used to specify the base packages to scan for Spring components. It is part of the Spring framework's way of enabling automatic detection of Spring components, such as @Component, @Service, @Repository, and @Controller annotations, and registering them as beans in the Spring application context.

By default, @ComponentScan scans the package of the class with the annotation, but it can be customized to scan other packages as well.

5. 
The @SpringBootApplication annotation is a convenience annotation that combines several other annotations commonly used in Spring Boot applications. It serves as the entry point for a Spring Boot application and triggers the auto-configuration and component scanning features of Spring Boot.

Composition

The @SpringBootApplication annotation is a combination of the following three annotations:

- @Configuration: Indicates that the class can be used by the Spring IoC container as a source of bean definitions.
- @EnableAutoConfiguration: Tells Spring Boot to start adding beans based on classpath settings, other beans, and various property settings.
- @ComponentScan: Enables component scanning so that the web controller classes and other components you create will be automatically discovered and registered as beans in the Spring application context.

6. 
- Using @Component Annotation
   The @Component annotation is a generic stereotype for any Spring-managed component. Spring will automatically detect and register the class as a bean.
``` 
import org.springframework.stereotype.Component;

@Component
public class MyComponent {
public void doSomething() {
System.out.println("Doing something...");
}
}
```
- Using @Service, @Repository, and @Controller Annotations
   These annotations are specializations of @Component, used to indicate service, repository, and controller layers respectively.

```
import org.springframework.stereotype.Service;

@Service
public class MyService {
public void performService() {
System.out.println("Performing service...");
}
}

import org.springframework.stereotype.Repository;

@Repository
public class MyRepository {
public void save() {
System.out.println("Saving data...");
}
}

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@Controller
public class MyController {
@GetMapping("/hello")
public String sayHello() {
return "Hello, World!";
}
} 
```

- Using @Bean Annotation in a Configuration Class
   The @Bean annotation is used to explicitly declare a single bean, typically in a @Configuration class.

``` 
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig {

    @Bean
    public MyBean myBean() {
        return new MyBean();
    }
}

public class MyBean {
public void doSomething() {
System.out.println("Doing something...");
}
}
```
- Using XML Configuration
   Beans can also be defined in an XML configuration file.
``` 
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="myBean" class="com.example.MyBean"/>
</beans>
```

``` 
public class MyBean {
    public void doSomething() {
        System.out.println("Doing something...");
    }
}
```
- Using Java-based Configuration with @ComponentScan
When using Java-based configuration, you can enable component scanning to automatically detect and register beans annotated with @Component, @Service, @Repository, and @Controller.
``` 
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan(basePackages = "com.example")
public class AppConfig {
// Configuration code
} 
```
7. 
The default bean name for a class annotated with @Component is the name of the class with the first letter in lowercase. 

The default bean name for a method annotated with @Bean is the name of the method itself.

- @Component

Purpose: Used to annotate a class at the class level to indicate that it is a Spring component. It is a specialization of the @Component stereotype.

Detection: Detected during classpath scanning. Spring automatically detects classes annotated with @Component, @Service, @Repository, and @Controller during the component scanning process.

Default Bean Name: The default bean name is the class name with the first letter in lowercase.

Use Case: Suitable for automatic registration of beans, especially when the bean does not need any specific configuration or custom logic for creation.

- @Bean

Purpose: Used to annotate a method in a @Configuration class to indicate that it returns a bean to be managed by the Spring container.

Detection: Methods annotated with @Bean are detected when the @Configuration class is processed by Spring.

Default Bean Name: The default bean name is the name of the method.

Use Case: Suitable for explicit bean declaration, especially when the bean needs specific configuration, custom initialization logic, or depends on other beans.

8. 
### Summary of Differences Between `@Component`, `@Service`, `@Repository`, and `@Controller`

| Aspect               | `@Component`                             | `@Service`                               | `@Repository`                            | `@Controller`                            |
|----------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
| **Purpose**          | Generic stereotype annotation            | Indicates a service component            | Indicates a repository component         | Indicates a controller component         |
| **Layer**            | Any layer                                | Service layer                            | Data access layer                        | Presentation layer                       |
| **Additional Semantics** | None                                   | Semantics for business logic             | Exception translation for data access    | Semantics for handling web requests      |
| **Usage Example**    | Any Spring-managed component             | Service beans                            | DAO beans                                | Web controllers                          |
| **Default Bean Name**| Class name with first letter lowercase   | Class name with first letter lowercase   | Class name with first letter lowercase   | Class name with first letter lowercase   |

#### When to Use Each

- **Use `@Component`**: For any Spring-managed bean that doesnâ€™t fall into the service, repository, or controller categories.
- **Use `@Service`**: For service layer beans that contain business logic.
- **Use `@Repository`**: For data access layer beans (DAOs) that interact with the database. It also provides automatic exception translation.
- **Use `@Controller`**: For web controller beans that handle HTTP requests and responses in a Spring MVC application.

By using these specific annotations, you provide better semantic meaning to your code, which makes it easier to understand the role of each component in your application architecture. Additionally, some of these annotations provide additional features or behaviors, such as exception translation for `@Repository` or request handling for `@Controller`.


9. 
- The @Autowired annotation is used for automatic dependency injection in Spring. It can be applied to constructors, methods, fields, or other constructors to inject the dependencies.
- The @Qualifier annotation is used in conjunction with @Autowired to resolve ambiguity when multiple beans of the same type are present. It specifies which bean should be injected.
- The @Resource annotation is part of JSR-250 and can be used to inject a bean by name (and type if the name is not specified). It is a more general-purpose dependency injection annotation.
- The @Primary annotation is used to specify a default bean to be injected when multiple beans of the same type are available. It indicates that the annotated bean should be given preference when autowiring by type.

10. 
In Spring, there are several annotations you can use to inject a bean into another bean. These annotations support different types of dependency injection such as constructor injection, setter injection, and field injection.