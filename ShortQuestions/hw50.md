# HW17
1. list all the new annotations you learned to your annotations.md  
   see annotation.md [here](annotation.md)
2. Document the microservice architecture and components/tools/dependencies
    1. Components of Microservice Architecture
       a. Services  
       Individual Microservices: Each microservice is a small, autonomous service that focuses on a specific business capability. They are independently deployable, scalable, and replaceable.
       b. Data Management  
       Database per Service: Each microservice typically manages its own database, either shared or dedicated, to ensure loose coupling.
       c. Communication  
       Synchronous Communication: Often uses HTTP/REST or gRPC for request/response interactions.
       Asynchronous Communication: Employs message queues or event streams (e.g., Apache Kafka, RabbitMQ) for event-driven architecture.
       d. API Gateway  
       Unified Entry Point: Serves as the single point of entry into the system, routing requests to appropriate microservices, aggregating responses, and handling cross-cutting concerns like SSL termination, authentication, and rate limiting.
   2. Tools and Technologies
      a. Service Discovery  
      Eureka: Provides a central registry that microservices can use to find and communicate with each other.
      Consul: A tool for service discovery, configuration, and orchestration.
      b. Configuration Management  
      Spring Cloud Config: Centralized external configuration management backed by a version-controlled repository.
      Consul: Again, useful for storing and managing configurations.
      c. API Gateway  
      Zuul: Handles dynamic routing, monitoring, resiliency, and security.
      Spring Cloud Gateway: Provides a simple, yet effective way to route to APIs and provide cross-cutting concerns to them.
      d. Load Balancing  
      Ribbon: Client-side load balancer in the Netflix OSS suite.
      Nginx: Can be used as a load balancer and reverse proxy for microservices.
      e. Resilience and Fault Tolerance  
      Hystrix: Provides circuit-breaker capabilities to prevent failure cascades.
      Resilience4j: A newer alternative to Hystrix that is lightweight and built on functional programming principles.
      f. Monitoring and Tracing  
      Prometheus: Monitoring system with a time-series database for storing metrics.
      Grafana: For dashboards and visualizations.
      Zipkin: Distributed tracing system that helps troubleshoot latency issues in microservice architectures.
      g. Containerization  
      Docker: Provides consistent environments for microservices, encapsulating them and their dependencies in containers.
      Kubernetes: Orchestration tool for automating deployment, scaling, and management of containerized applications.
   3. Deployment and Continuous Integration/Continuous Deployment (CI/CD)
      Jenkins: Automation server used to build, test, and deploy applications.
      Spinnaker: Multi-cloud continuous delivery platform for releasing software changes with high velocity and confidence.
      GitLab CI: A single application for the entire software development lifecycle from project planning and source code management to CI/CD.
   4. Security
      OAuth2 and JWT: For secure authentication and authorization across services.
      Spring Security: Provides comprehensive security services for Java applications, especially useful in a Spring-based microservice setup.
   5. Data Management Tools
      Liquibase or Flyway: For database schema migration and version control.
      Elasticsearch: For full-text search capabilities across various microservices data.
      Documentation Practices
3. What are Resilience patterns? What is circuit breaker?
   > **resilience patterns** are strategies used to handle and recover from failures in a predictable and controlled manner. These patterns help ensure that a system remains functional and available even when parts of it fail
   
   > circuit breaker is a kind of Resilience patterns. If a system call results in an error, the **circuit breaker** is opened and does not allow any calls to pass through.
   
4. Read this article, then list the important questions, then write your answers https://www.interviewbit.com/microservices-interview-questions/#main-features-of-microservices
   * Write main components of Microservices.
      Some of the main components of microservices include:
        Containers, Clustering, and Orchestration
        IaC [Infrastructure as Code Conception]
        Cloud Infrastructure
        API Gateway
        Enterprise Service Bus
        Service Delivery
   * Name three common tools mostly used for microservices.
        Three common tools used for microservices include:
     Wiremock Docker Hystrix
   * What do you mean by Domain driven design?  
     DDD (Domain-Driven-Design) is basically an architectural style that is based on Object-Oriented Analysis Design approaches and principles. In this approach, the business domain is modeled carefully in software, without regard to how the system actually works. By interconnecting related components of the software system into a continuously evolving system, it facilitates the development of complex systems. There are three fundamental principles underlying it as shown below:

     - Concentrate on the core domain and domain logic.
     - Analyze domain models to find complex designs.
     - Engage in regular collaboration with the domain experts to improve the application model and address emerging domain issues.

5. how to do load balance in microservice? Write a long Summary by yourself.
   1. https://www.geeksforgeeks.org/load-balancer-system-design-interview-question/
   2. https://www.fullstack.cafe/blog/load-balancing-interview-questions
   
   > Imagine microservices as a bunch of small, independent workers in your app. Each one handles a different job. Load balancing is like the supervisor that directs traffic, making sure no single worker gets too bogged down. This way, tasks are completed faster and more efficiently. Load balancers minimize server response time and maximize throughput. Load balancer ensures high availability and reliability by sending requests only to online servers Load balancers do continuous health checks to monitor the server’s capability of handling the request. Depending on the number of requests or demand load balancers add or remove the number of servers.
    
    - To do load balance:
      1. DNS Load Balancing: This method is pretty straightforward. It uses DNS lookups to distribute requests by giving out different IP addresses. It’s simple but can sometimes run into issues with outdated cached data.
      2. Hardware and Software Load Balancers: You can use physical devices (hardware) or programs (software) to manage the traffic. Hardware is robust but pricey and a bit rigid. Software, like Nginx or HAProxy, is more flexible and great for cloud setups.
      3. Service Mesh Load Balancing: This is a newer, smarter way to handle things in microservices. Tools like Istio or Linkerd sit right in the communication network of your services and manage everything without changing your actual code. They can handle retries, failures, and route traffic intelligently.
      4. Cloud-Provider Load Balancers: If you’re using cloud services, they usually offer their own load balancers (like AWS ELB or Google Cloud Load Balancer). These are super integrated and handle scaling automatically, which is less hassle for you.
    - Each way of load balancing has its own strengths, and you might end up using more than one depending on your needs. For instance:

       - **Round Robin** is easy; it just passes each new request to the next server in line.
       - **Least Connections** method sends new tasks to the server handling the fewest connections, which can be more efficient.
       - **IP Hash** could be good for keeping user sessions on the same server.

6. How to do service discovery?
    1. Client-Side Discovery
    > In this pattern, the client is responsible for determining the network locations of available service instances and load balancing requests across them. This usually involves querying a service registry, where all service instances are registered with their current locations.
       
    How it works:
    
       Each service instance registers its location with a service registry at startup.
       When a service instance goes down, it's removed from the registry (either by the service itself or by a health monitoring component).
       When a client needs to use a service, it queries the registry, retrieves the available instances, and uses a load-balancing algorithm to select one and make a request.
    Tools:
    
       Eureka from Netflix OSS is a common choice for client-side discovery. Services register with Eureka and clients query Eureka to get service instances.

7. prepare your own answers for each questions https://www.interviewbit.com/kafka-interview-questions/#
   purpose-of-partitions-in-kafka
   1. Kafka Interview Questions for Freshers
   2. Kafka Interview Questions for Experienced
   3. MCQ on Kafka