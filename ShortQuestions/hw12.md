# Homework44

## Yirun Wang

### 2.  What is MVC pattern?

The MVC design pattern is a software architecture pattern that separates an application into three main components: Model, View, and Controller. 

**Model**:

- Represents the data and the business logic of the application.
- Manages the data, logic, and rules of the application.
- Responds to requests for information, usually from the view, and responds to instructions to change state (usually from the controller).

**View**:

- Represents the presentation layer (UI) of the application.
- Displays data from the model to the user.
- Sends user commands to the controller.
- Updates its display based on changes in the model.

**Controller**:

- Acts as an intermediary between the model and the view.
- Receives input from the view (usually user input).
- Processes the input, possibly making calls to model objects to update the data.
- Updates the view with the new data from the model.

![](https://media.geeksforgeeks.org/wp-content/uploads/20240219101004/MVC-Design-Pattern-.webp)

**User Interaction**: The user interacts with the view, such as clicking a button or entering text into a form.

**View to Controller**: The view sends the user input to the controller.

**Controller to Model**: The controller processes the input, updates the model.

**Model Update**: The model updates its state.

**Model to View**: The view gets updated based on the changes in the model, reflecting the updated data to the user.

### 3. What is Front-Controller?

The front controller design pattern means that all requests that come for a resource in an application will be handled by a single handler and then dispatched to the appropriate handler for that type of request. 

Manages common functionalities like authentication, authorization, logging, and request validation.

![image-20240712180340786](/Users/yirun/Library/Application Support/typora-user-images/image-20240712180340786.png)

- **Controller :** The controller is the initial contact point for handling all requests in the system. The controller may delegate to a helper to complete authentication and authorization of a user or to initiate contact retrieval.
- **View:**A view represents and displays information to the client. The view retrieves information from a model. Helpers support views by encapsulating and adapting the underlying data model for use in the display.
- **Dispatcher:** A dispatcher is responsible for view management and navigation, managing the choice of the next view to present to the user, and providing the mechanism for vectoring control to this resource.
- **Helper :** A helper is responsible for helping a view or controller complete its processing. Thus, helpers have numerous responsibilities, including gathering data required by the view and storing this intermediate model, in which case the helper is sometimes referred to as a value bean.

### 4. What is DispatcherServlet? please decribe how it works.

The DispatcherServlet is the front controller in Spring web applications, responsible for handling all incoming HTTP requests and dispatching them to appropriate handlers such as controllers and view resolvers. 

![image-20240714023626275](/Users/yirun/Library/Application Support/typora-user-images/image-20240714023626275.png)

1. **Entry Point for Requests:**

At the heart of a Spring Boot web application lies the `DispatcherServlet`. Upon receiving an HTTP request, this servlet acts as the gateway, intercepting the incoming call and initiating the process of handling the request. It serves as the central hub for managing the flow of requests and responses.

2. **Web Application Context:**

The `DispatcherServlet` operates within the context of the larger Spring application context. This context is essentially a container for managing beans, including controllers, services, and other components. The servlet uses this context to locate and invoke the appropriate components for handling the incoming request.

3. **Handler Mapping: Determining the Handler**

One of the crucial responsibilities of the `DispatcherServlet` is to consult the `HandlerMapping`. This mapping is responsible for determining which controller (handler) should process the incoming request based on factors such as the request URL, request method, or other parameters.

So once the handle mapper maps this request to this particular handler mapper then the handler mapper will return particular controller(handler) details to the dispatcher servlet.

4. **Handler Adapter: Bridging the Interface Gap**

Controllers in a Spring application might have different method signatures. The `HandlerAdapter` comes into play to bridge the gap between the varying interfaces of controllers. It ensures that the chosen handler can effectively process the request by adapting it to a standardized interface, allowing for a unified approach to request handling.

The Dispatcher servlet needs the assistance of a `HandlerAdapter` to invoke the method (handler) with the correct parameters.

5. **Handler Execution: Processing Business Logic**

With the handler and adapter in sync, the `DispatcherServlet` invokes the chosen controller method. This is where the application's business logic resides. Developers define how the application should respond to the client's request, whether it involves retrieving data from a database, performing computations, or orchestrating other activities.

6. **View Resolution: Preparing the Response**

Once the handler has processed the request and generated a result, the `DispatcherServlet` engages the `ViewResolver`. This component resolves the logical view name returned by the handler to an actual view implementation. The resolved view is crucial in generating the appropriate response format, be it HTML, JSON, or another content type.

For RESTful services producing JSON responses, the concept of traditional view resolution is typically not applicable. The focus is on returning data directly from the controller, and the response format is determined by the media type specified in the request header (e.g., `application/json`). In such cases, the role of view resolution is minimal, and the emphasis is on the serialization of data to produce the desired response format. Spring Boot utilizes `HttpMessageConverter`s, particularly `MappingJackson2HttpMessageConverter`, to convert the returned object (e.g., a POJO) into JSON format.

7. **Sending the Response:**

With the view in hand, the `DispatcherServlet` proceeds to send the response back to the client. This marks the culmination of the request handling process. The client receives the generated content, whether it's a rendered web page or a data payload, based on the actions performed by the controller.

### 5. What is JSP and What is ModelAndView? (please google to have a basic knowlege)

JSP, Jakarta Server Pages. It is a server-side technology which is used for creating web applications. It is used to create dynamic web content. JSP consists of both HTML tags and JSP tags. It allows developers to embed Java code directly into HTML pages, enabling the creation of interactive and data-driven web applications.

**ModelAndView** is a class in the Spring MVC framework that encapsulates both the model data and the view name to be rendered. It is a key component in the MVC (Model-View-Controller) design pattern used by Spring MVC.

This interface allows us to pass all the information required by Spring MVC in one return:

**Model**:

- The model contains the data that will be displayed in the view. It is typically a collection of attributes (key-value pairs) that the view can use to render the response.

**View**:

- The view is the representation of the model data, typically in the form of a web page (e.g., JSP, Thymeleaf). The view name is resolved by a `ViewResolver` to an actual view template.

In Spring MVC, a controller method typically returns a `ModelAndView` object. This object combines the model data with the view name, allowing the `DispatcherServlet` to handle both the data and the presentation seamlessly.

```java
@GetMapping("/goToViewPage")
public ModelAndView passParametersWithModelAndView() {
    ModelAndView modelAndView = new ModelAndView("view/viewPage");
    modelAndView.addObject("message", "Baeldung");
    return modelAndView;
}

```



### 6. Could you please google any other servlets(理解多少是多少，不要花太多时间，知道servlet的名字就行。) 

**HttpServlet**

It provides methods specifically designed to handle HTTP-specific functionality, such as handling GET, POST, PUT, DELETE, and other HTTP methods.

```java
@WebServlet("/example")
public class ExampleServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) 
            throws ServletException, IOException {
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        out.println("<html><body>");
        out.println("<h1>Hello, this is a GET response!</h1>");
        out.println("</body></html>");
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) 
            throws ServletException, IOException {
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        String name = request.getParameter("name");
        out.println("<html><body>");
        out.println("<h1>Hello, " + name + "! This is a POST response!</h1>");
        out.println("</body></html>");
    }
}
```



**GenericServlet**

**`GenericServlet`** is an abstract class provided by the Java Servlet API that implements the `Servlet` interface. It is designed to make it easier to write generic servlets that handle any type of request, not just HTTP-specific requests. 

`GenericServlet` is protocol-independent and can be used to create servlets for other protocols as well.

### 7.  How many web servers do you know?(Tomcat, Jetty, Jboss)

- Tomcat

  **Type**: Open-source, Java Servlet Container

  **Purpose**: Primarily for running Java Servlets and JavaServer Pages (JSP)

  - Lightweight and fast

  - Integrates well with various Java EE frameworks

  - Extensible via various connectors and modules

- Nginx

  **Type**: Open-source, High-performance HTTP server, Reverse proxy server

  **Purpose**: Load balancing, serving static content, reverse proxying*

  - High concurrency and low resource usage : Very popular for high-traffic websites

  - Load balancing and reverse proxy capabilities

  - Caching for static content

  - SSL/TLS termination

  - Supports WebSocket, HTTP/2, and gRPC

  - Extensible with third-party modules

- Jetty

  **Type**: Open-source, Java-based HTTP server and Servlet container

  **Purpose**: Lightweight web server and servlet container for Java applications

  - Lightweight and flexible

  - Embeddable in Java applications: Often used for  purposes

  - Supports HTTP/2, WebSocket, and asynchronous I/O

  - Scalable and suitable for cloud deployments

  - Modular architecture allows fine-grained customization

- Jboss(WildFly)

  **Type**: Open-source, Java EE application server

  **Purpose**: Full Java EE implementation for enterprise applications

  - Full support for Java EE standards (EJB, JPA, JMS, etc.)

  - Robust clustering and high availability

  - Management and monitoring tools

  - Modular and flexible architecture

  - Strong integration with Red Hat's middleware and tools

  - Support for cloud-native and microservices architectures (WildFly Swarm)



*reverse proxy: 

A **reverse proxy** is a type of proxy server that retrieves resources on behalf of a client from one or more servers. These resources are then returned to the client as if they originated from the proxy server itself. It acts as an intermediary for requests from clients seeking resources from servers.