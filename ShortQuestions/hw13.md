1. List all of the annotations you learned from class and homework to annotaitons.md

2.  Explain TLS, PKI, certificate, public key, private key, and signature.
    - TLS: Transport Layer Security
      - is a protocol that ensures privacy between communication applications and users on the internet.
    - PKI: Public Key Infrastructure
      - is a framework for create, manage, distribute, use, store and revoke certificates and manage public-key encryption.
    - Certificate
      - is a diginal document that uses a digital signature to bind a public key with identity-information.
      - such as name of a person or an organization, the addresss.
    - Public Key
      - one of the two keys used in asymmetric encryption algorithm. used to encyrpt data.
      - holds by users
    - Private Key
      - another half of key used in asymmetric encryption algorithm. kept secret, decrypt data
      - holds by server
    - Signature
      - validate data integrity and sender authentity.
      - a cryptographic value that is calculated from the data and a private key.
      - used to verify the authenticity and integrity of a message.
      - when the message is signed with a private key, anyone with the corespoding public key can verify that message.
      

3.  list all http status codes that related to authentication and authorization failures.
    - 401 Unauthorized
      The request has not been applied because it lacks valid authentication credentials for the target resource.
      The client must authenticate itself to get the requested response.
    - 403 Forbidden
      The server understood the request but refuses to authorize it.
      The client does not have permission to access the requested resource, even if authenticated.
    - 407 Proxy Authentication Required
      Similar to 401 Unauthorized, but it indicates that the client must first authenticate itself with the proxy.
      The client needs to authenticate with a proxy server.
    
4.  Compare authentication and authorization?
    - Authentication
      - authentication is the process of verifying the identity of a user or entity.
    - Authorization
      - is the process of determining a authenticated user or entity has permission to access a specific resource.
    
5.  What is HTTP Session?
    - is a mechanism used to persist user data across multiple HTTP requests.
    - make HTTP be stateful.
    - Definition: An HTTP session is a server-side storage of information that persists across multiple requests from the same client during a browsing session.
    - Purpose: To maintain state and data about a user or client's interaction with a web application, enabling the server to remember the user’s activities and preferences.
    - Mechanism: When a client logs in or starts a session, the server generates a unique session ID, which is sent to the client and stored (often in a cookie). This session ID is sent with each subsequent request to associate the request with the server-side session data.
    
6.  What is Cookie?
   - a small piece of data sent from website server and stored on user's device by their web browers.
   - Cookies are used to remember information about hte user, like the preference, login status, session information.

7.  What is the difference between Session and Cookie?
    
    | Feature            | Cookies                                 | Sessions                                              |
    |--------------------|-----------------------------------------|-------------------------------------------------------|
    | Storage Location   | User side                               | server side                                           |
    | Size limit         | limited to 4kb                          | no strict size limit, depends on server configuration |
    | Security           | less scecure, can be change             | more secure, reduce exposure to client-side attacks   |
    | Communication      | Sent with every HTTP request            | identified by a seesionID                             |
    | Performance Impact | Minimal overhead since cookie are small | can be heavier on the server side as data grows       |

8.  How do we use session and cookie to keep user information across the the application?
    ####  Login Process
    
    1. User Logs In:
    
    - The user submits their login credentials (username and password) via an HTTP POST request.
    
    1. Server Authenticates User:
    
    - The server verifies the credentials. If valid, it creates a session and assigns a unique session ID.
    
    1. Store Session Data:
    
    - The server stores user-specific data (e.g., user ID, role) in the session storage, associated with the session ID.
    
    1. Set Session ID Cookie:
    
    - The server sends an HTTP response setting a cookie containing the session ID (e.g., `Set-Cookie: JSESSIONID=abc123`).
    
    
    
    #### Subsequent Requests
    
    1. Client Sends Request with Session ID Cookie:
    
    - For each subsequent request, the client’s browser includes the session ID cookie (e.g., `Cookie: JSESSIONID=abc123`).
    
    1. Server Retrieves Session Data:
    
    - The server reads the session ID from the cookie, retrieves the session data from the session storage, and processes the request accordingly.
    
9.  What is JWT?
    - JSON Web Token, is an open standerd for security transimitting information between parties as a JSON object.
    - commonly used for authentication and authorization in web applications, allowing the servers to verify the identity fo a client and grant access to protected resources.
    - inlucing three parts. header, payload and signature
      - header: The header typically consists of two parts: the type of token (JWT) and the signing algorithm being used (such as HMAC SHA256 or RSA).
      ```
      {
        "alg": "HS256",
        "typ": "JWT"
        }
      ```
      - payload: The payload contains the claims, which are statements about an entity (typically, the user) and additional data.
      ```
      {
        "sub": "1234567890",         // Subject (user identifier)
        "name": "John Doe",          // User's name
        "admin": true,               // Boolean claim indicating admin status
        "roles": ["user", "admin"],  // Array of roles assigned to the user
        "email": "john.doe@example.com",  // User's email address
        "exp": 1641025200,           // Expiration time (Unix timestamp)
        "iat": 1641021600,           // Issued at (Unix timestamp)
        "iss": "https://example.com", // Issuer
        "aud": ["https://api.example.com", "https://app.example.com"]  // Audience
        }
      
      ```
      - Sinature
        - To create the signature part, you have to take the encoded header, the encoded payload, a secret, the algorithm specified in the header, and sign that.
    
10.  What is the spring security filter?
     - An authentication and access control framework for Java applications
     - provide a flexible and modular way to handle authentication and authorization
     - Contains filter chain that composed of multiple filters that handle various security concerns.
     - Filters:
       - UsernamePasswordAuthenticationFilter: Handles authentication based on username and password.
       - BasicAuthenticationFilter: Processes HTTP Basic Authentication credentials.
       - BearerTokenAuthenticationFilter: Extracts and validates JWT tokens for stateless authentication.
       - CsrfFilter: Protects against Cross-Site Request Forgery (CSRF) attacks.
       - SecurityContextPersistenceFilter: Loads the SecurityContext for the request, holding the authentication information.
       - ExceptionTranslationFilter: Handles any AccessDeniedException or AuthenticationException thrown within the filter chain.
       - FilterSecurityInterceptor: Performs authorization checks by invoking an AccessDecisionManager to decide whether a request is allowed to proceed.
     
11.  Explain how JWT works
     
     JWT (JSON Web Token) is a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity-protected with a Message Authentication Code (MAC) and/or encrypted.
     
     1. Token Structure:

     - A JWT consists of three parts: the header, payload, and signature.
     
     - These parts are encoded in Base64Url and separated by dots (`.`).
     
       ```java
       eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
       ```
     
       
     
     2. Header:
     
     - The header typically consists of two parts: the type of the token (JWT) and the signing algorithm being used (e.g., HMAC SHA256 or RSA).
     
       ```java
       {
         "alg": "HS256",
         "typ": "JWT"
       }
       ```
     
     3. Payload:
     
     - The payload contains the claims. Claims are statements about an entity (typically, the user) and additional data.
     
       ```java
       {
         "sub": "1234567890",
         "name": "John Doe",
         "iat": 1516239022
       }
       ```
     
     4. Signature:
     
        - To create the signature part, you have to take the encoded header, the encoded payload, a secret, and the algorithm specified in the header, and sign that.
        - For example, if you want to use the HMAC SHA256 algorithm, the signature will be created in the following way:
     
        
### How JWT Authentication Works

1. Client Authentication:
  - The client sends a login request with their credentials (e.g., username and password) to the authentication server.
  - eg. 
```http
POST /login
{
  "username": "user",
  "password": "password"
}
```

2. Server Validates Credentials:
  - The server verifies the credentials. If valid, it creates a JWT containing the user information and any additional claims needed for the application.
  - eg. 
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

Payload:
```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022,
  "exp": 1516249022
}
```

Signature:
```
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```

3. Server Returns JWT:
  - The server sends the JWT back to the client.
  - eg. 
```http
HTTP/1.1 200 OK
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
}
```


4. Client Stores JWT:
  - The client stores the JWT (typically in local storage, session storage, or a cookie).

5. Client Requests with JWT:
  - For subsequent requests to protected routes or resources, the client includes the JWT in the HTTP Authorization header.
  - eg:
```http
GET /protected
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

6. Server Validates JWT:
  - The server extracts the JWT from the Authorization header.
  - It verifies the token's signature to ensure it has not been tampered with and checks the token's claims (e.g., expiration time, issuer, subject).
  - If the token is valid, the server processes the request. If not, it rejects the request (e.g., with a 401 Unauthorized status).
        
    
12. Explain how do we store sensitive user information such as password and credit card number in DB?
    - Salt Algorithm
      - in database, save hash and salt,  hash(password + salt)
        - irreversible, only (password + salt) = hash, from hash and salt, cannot decode to get password
      - Bcrypt: can generate random salt
        - bcrypt(password) = bcrypt(password)

13. Compare UserDetailService, AuthenticationProvider, AuthenticationManager, AuthenticationFilter?(把这几
    个名字看熟悉也行)

    - UserDetailsService:
      - Purpose: Fetches user details from a data source.
      - Role: Provides `UserDetails` for a given username.
      - Position in Workflow: Invoked by `AuthenticationProvider`.
    - AuthenticationProvider:
      - Purpose: Validates user credentials.
      - Role: Authenticates the user and returns an `Authentication` object.
      - Position in Workflow: Invoked by `AuthenticationManager`.
    - AuthenticationManager:
      - Purpose: Manages the authentication process.
      - Role: Delegates authentication to configured `AuthenticationProvider` instances.
      - Position in Workflow: Central component in the authentication process.
    - AuthenticationFilter:
      - Purpose: Intercepts HTTP requests to extract authentication data.
      - Role: Extracts credentials and initiates authentication.
      - Position in Workflow: Entry point in the HTTP request processing pipeline.

    These components work together to implement a robust authentication system in Spring Security, each with a specific responsibility in the process.

14. What is the disadvantage of Session? how to overcome the disadvantage?
    - disadvantage
        - server side storage
        - scalability concerns (it is stateful)
        - performance impact
        - session management overhead
    - improve
      - stateless authentication (JWT)
      - add cache
      - implement session expiry and clean up mechanism

15. how to get value from application.properties in Spring security?
    - using @Value annotation
    ```
    // application.properties
       security.jwt.secret=your_secret_key_here
       
    // get data
       @Value("${security.jwt.secret}")
       private String jwtSecret;
    ```

16. What is the role of configure(HttpSecurity http) and configure(AuthenticationManagerBuilder auth)?
    - ways to configure different aspects of security in the application.
    - configure(HttpSecurity http
      - part of WebSecurityConfigurerAdapter
      -  such as authorization rules, login/logout configurations, CSRF protection, session management, etc.
      ```
      @Configuration
      @EnableWebSecurity
       public class SecurityConfig extends WebSecurityConfigurerAdapter {
      
       @Override
       protected void configure(HttpSecurity http) throws Exception {
           http
               .authorizeRequests()
                   .antMatchers("/public/**").permitAll()
                   .antMatchers("/admin/**").hasRole("ADMIN")
                   .anyRequest().authenticated()
                   .and()
               .formLogin()
                   .loginPage("/login")
                   .defaultSuccessUrl("/dashboard")
                   .permitAll()
                   .and()
               .logout()
                   .logoutUrl("/logout")
                   .logoutSuccessUrl("/login?logout")
                   .permitAll();
       }
       }
      ```
    - configure(AuthenticationManagerBuilder auth)
      - also part of WebSecurityConfigurerAdapter
      - It defines where user information is stored (e.g., in-memory, database) and how authentication is performed (e.g., using LDAP, JDBC).
      ```
       @Configuration
       @EnableWebSecurity
       public class SecurityConfig extends WebSecurityConfigurerAdapter {
       
           @Autowired
           private UserDetailsService userDetailsService;
       
           @Override
           protected void configure(AuthenticationManagerBuilder auth) throws Exception {
               auth
                   .userDetailsService(userDetailsService)
                   .passwordEncoder(passwordEncoder());
           }
       
           @Bean
           public PasswordEncoder passwordEncoder() {
               return new BCryptPasswordEncoder();
           }
       }
      
      ```

17. What is Spring security authentication and authorization?
    - Authentication verifies the identity of the user.
    - Authorization determines what actions or resources the authenticated user is permitted to access.
#### Authentication:

1. AuthenticationManager:
  - The central interface for authentication. It delegates authentication requests to a list of `AuthenticationProvider` instances.

2. AuthenticationProvider:
  - Responsible for authenticating a user. It can have different implementations (e.g., in-memory, JDBC, LDAP) and supports multiple authentication mechanisms.
  - Example:
    ```java
    public class CustomAuthenticationProvider implements AuthenticationProvider {
        @Override
        public Authentication authenticate(Authentication authentication) throws AuthenticationException {
            String username = authentication.getName();
            String password = (String) authentication.getCredentials();
            // Logic to authenticate user (e.g., checking username and password)
            // Return an Authentication object if successful
        }
    
        @Override
        public boolean supports(Class<?> authentication) {
            return UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication);
        }
    }
    ```

3. UserDetailsService:
  - A core interface to load user-specific data. It is typically used to fetch user details from a database.
  - Example:
    ```java
    public class CustomUserDetailsService implements UserDetailsService {
        @Override
        public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
            // Logic to fetch user details from database
            return new User(username, password, authorities);
        }
    }
    ```

4. Authentication Filter:
  - Filters such as `UsernamePasswordAuthenticationFilter` intercept login requests and initiate the authentication process.
  - Example:
    ```java
    public class CustomAuthenticationFilter extends UsernamePasswordAuthenticationFilter {
        @Override
        public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
            String username = request.getParameter("username");
            String password = request.getParameter("password");
            return getAuthenticationManager().authenticate(new UsernamePasswordAuthenticationToken(username, password));
        }
    }
    ```

5. Security Configuration:
  - Configuration class to set up authentication.
  - Example:
    ```java
    @Configuration
    @EnableWebSecurity
    public class SecurityConfig extends WebSecurityConfigurerAdapter {
        @Autowired
        private CustomUserDetailsService userDetailsService;
        @Autowired
        private CustomAuthenticationProvider customAuthenticationProvider;
    
        @Override
        protected void configure(AuthenticationManagerBuilder auth) throws Exception {
            auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());
            auth.authenticationProvider(customAuthenticationProvider);
        }
    
        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http.authorizeRequests()
                .anyRequest().authenticated()
                .and()
                .formLogin().loginPage("/login").permitAll()
                .and()
                .logout().permitAll();
        }
    
        @Bean
        public PasswordEncoder passwordEncoder() {
            return new BCryptPasswordEncoder();
        }
    }
    ```

### Authorization

1. GrantedAuthority:
  - Represents an authority granted to the user. Usually corresponds to a role (e.g., ROLE_USER, ROLE_ADMIN).
  - Example:
    ```java
    List<GrantedAuthority> authorities = new ArrayList<>();
    authorities.add(new SimpleGrantedAuthority("ROLE_USER"));
    ```

2. Access Decision Manager:
  - Decides whether a user has access to a specific resource based on the authorities they possess and the configuration of the application.
  - Default implementation checks all `AccessDecisionVoter` instances.

3. Security Interceptor:
  - Intercepts method invocations and web requests to enforce security constraints.
  - Example: `FilterSecurityInterceptor` for web requests.

4. @PreAuthorize and @Secured:
  - Annotations to secure methods.
  - Example:
    ```java
    @Service
    public class MyService {
        @PreAuthorize("hasRole('ROLE_ADMIN')")
        public void adminMethod() {
            // Method logic
        }
    
        @Secured("ROLE_USER")
        public void userMethod() {
            // Method logic
        }
    }
    ```

5. Expression-Based Access Control:
  - Allows the use of complex security expressions in the configuration.
  - Example:
    ```java
    @Configuration
    @EnableWebSecurity
    public class SecurityConfig extends WebSecurityConfigurerAdapter {
        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http.authorizeRequests()
                .antMatchers("/admin/").access("hasRole('ROLE_ADMIN')")
                .antMatchers("/user/").access("hasRole('ROLE_USER')")
                .anyRequest().authenticated();
        }
    }
    ```
18. Reading, 泛读一下即可，自己觉得是重点的，可以多看两眼。https://www.interviewbit.com/spring-security-i
    nterview-questions/#is-security-a-cross-cutting-concern
    1.  1-12
    2.  17 - 30