## 2. Explain TLS, PKI, certificate, public key,private key, and signature.
### TLS
a cryptographic protocol designed to provide secure communication over a computer network. It's widely used to secure connections between web browsers and servers. TLS ensures data privacy and integrity between the communicating applications. The primary goals of TLS includes: **Encryption**, **Authentication**, and **Integrity**
### PKI
a framework for managing digital keys and certificates. It enables secure data exchange and authentication over untrusted networks, such as the internet. The key components of PKI include:
1. Certificate Authority (CA): A trusted entity that issues and verifies digital certificates.
2. Registration Authority (RA): Acts as a mediator between the user and the CA, verifying the user's identity before a certificate is issued.
3. Digital Certificates: Electronic documents that use a digital signature to bind a public key with an identity.
4. Public and Private Keys: A pair of cryptographic keys used for encryption and decryption.
### Certificate
A digital certificate is an electronic document used to prove the ownership of a public key. Certificates contain information about the key, the identity of its owner, and the digital signature of an entity that has verified the certificateâ€™s contents. They are used to establish trust in secure communications.
### Public Key
The public key is part of a cryptographic key pair used in asymmetric encryption. It can be freely distributed and is used to encrypt data. The public key is paired with a private key, which is kept secret by the owner.

### Private Key
The private key is the other half of the cryptographic key pair used in asymmetric encryption. It is kept secret and is used to decrypt data that was encrypted with the corresponding public key. The private key is also used to create digital signatures.

### Signature
A digital signature is a cryptographic value that is calculated from the data and a secret key known only by the signer (the private key). Digital signatures provide authenticity, integrity, and non-repudiation. When a message is signed, the recipient can verify the signature using the sender's public key to ensure the message was not altered and was indeed sent by the claimed sender.

## 3. list all http status codes that related to authentication and authorization failures.
1. `401 Unauthorized` - the request has not been applied because it lacks valid authentication credentials for the target resource.
2. `403 Forbidden` - the server understood the request but refuses to authorize it.
3. `407 Proxy Authentication Required` - the client must first authenticate itself with the proxy.

## 4. Compare authentication and authorization?
Authentication is for confirming the identity of the user or system, authorization is to grant or deny access to resources based on permissions and policies.  
Authentication happens before anthorization. A user must first prove their identity (authentication) before the system checks their permission(authorization). Authentication focuses on verifying identity, while authorization focuses on granting access to resources.  
Authentication involves user credentials, whereas authorization involves permissions and policies.  
Authentication results in a binary decision (authenticated or not), while authorization results in a decision based on access rights (permitted or denied).

## 5. What is HTTP session?
An HTTP session is a sequence of network request-response transactions between a client (typically a web browser) and a server. The concept of an HTTP session is crucial for maintaining stateful interactions over the inherently stateless HTTP protocol. 

## 6. What is Cookie?
Cookie is a small piece of data that a server sends to a user's web browser. The browser may store the cookie and send it back to the same server with subsequent requests. Cookies are used to remember information about the user and their interactions with the site, helping to maintain stateful communication over the stateless HTTP protocol.

## 7. What is the difference between Session and Cookie?
1. Storage Location:  
**Session**: Stored on the server.  
**Cookie**: Stored on the client-side (in the user's web browser).
2. Lifetime:   
**Session**: Typically lasts for the duration of the user's visit (session). Ends when the user closes the browser or logs out, or when the session times out on the server.  
**Cookie**: Can be session cookies (deleted when the browser is closed) or persistent cookies (remain on the user's device for a specified period or until deleted).
3. Data Storage and Size:  
**Session**: Can store larger amounts of data because the data is stored on the server.  
**Cookie**: Can store limited amounts of data (typically up to 4KB).
4. Security:  
**Session**: More secure because the data is stored on the server and only the session ID is exposed to the client.  
**Cookie**: Less secure because the data is stored on the client's device and is vulnerable to client-side attacks like cross-site scripting (XSS).
5. Use Cases:  
**Session**: Ideal for storing sensitive or larger amounts of user-specific data, such as user authentication states, shopping carts, and user preferences.  
**Cookie**: Ideal for storing small pieces of data that need to persist between sessions, such as user preferences, tracking data, and login states (e.g., "remember me" functionality).
6. Setting and Retrieval:  
**Session**: Created and managed by the server. The server generates a session ID and sends it to the client, usually in a cookie. The server retrieves the session data using the session ID.  
**Cookie**: Set by the server using the Set-Cookie header in the HTTP response, or by client-side scripts. Retrieved by the server from the Cookie header in HTTP requests.

## 8. How do we use session and cookie to keep user information across the application?
1. User Logs In: The server authenticates the user and creates a session. The session ID is stored in a cookie.
2. User Navigates the Application: The browser sends the session ID cookie with each request. The server uses the session ID to retrieve user information from the session store.
3. User Logs Out: The server invalidates the session.
The session ID cookie is deleted or invalidated.

## 9. What is JWT
JSON Web Token (JWT) is a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is used as the payload of the token, which is then signed to ensure the token's integrity and authenticity.  
Key Components:
1. Header: The header typically consists of two parts: the type of the token (JWT) and the signing algorithm being used (e.g., HMAC SHA256 or RSA).
   ```
   {
   "alg": "HS256",
   "typ": "JWT"
   }
   ```
2. Payload: The payload contains the claims, which are statements about an entity (typically, the user) and additional metadata.
There are three types of claims: registered, public, and private claims.
   - Registered Claims: Predefined claims that are not mandatory but recommended to provide a set of useful, interoperable claims (e.g., iss for issuer, exp for expiration time).
   - Public Claims: Custom claims that can be defined to share information between parties.
   - Private Claims: Custom claims created to share information specific to the users and application.
   ```
   {
   "sub": "1234567890",
   "name": "John Doe",
   "admin": true
   }
   ```
3. Signature: To create the signature part, you have to take the encoded header, the encoded payload, a secret, the algorithm specified in the header, and sign that.
   ```
   Copy code
   HMACSHA256(
   base64UrlEncode(header) + "." + base64UrlEncode(payload),
   secret)
   ```

## 10. What is the spring security filter?
Spring Security is a powerful and highly customizable authentication and access-control framework for Java applications, particularly those using the Spring framework. One of the core components of Spring Security is the filter chain, which is a series of filters that process HTTP requests and responses to provide security functionalities such as authentication, authorization, and protection against common security threats.  
Key Concepts:  
1. Filter Chain:  
A series of filters configured to apply to incoming requests.
Each filter performs a specific security-related task and then passes the request to the next filter in the chain.
2. DelegatingFilterProxy:  
A special filter provided by Spring Security that delegates the actual filtering work to a bean defined in the Spring application context. It allows integrating the Spring Security filter chain with the servlet container's filter mechanism.
3. Common Filters:  
   - UsernamePasswordAuthenticationFilter: Handles form-based login by processing credentials (username and password) and creating an authentication token.
   - BasicAuthenticationFilter: Handles HTTP Basic Authentication.
   - JwtAuthenticationFilter: Custom filter for handling JWT-based authentication.
   - ExceptionTranslationFilter: Catches security-related exceptions and translates them into HTTP responses.
   - SecurityContextPersistenceFilter: Manages the SecurityContext, ensuring it is properly populated and cleaned up with each request.
   - FilterSecurityInterceptor: Intercepts requests to secure resources and enforces access control based on configured security rules.
4. Security Filter Chain Configuration:  
Defined in a Spring Security configuration class, usually annotated with @EnableWebSecurity.
Filters are added and configured in the configure(HttpSecurity http) method.

## 11. Explain how JWT works
1. Client Authentication:  
The client sends credentials (e.g., username and password) to the server.
The server verifies the credentials and, if valid, generates a JWT.
2. Token Creation:  
The server creates the JWT, which includes the header, payload, and signature.
The token is then sent back to the client.
3. Token Storage:  
The client stores the JWT (typically in local storage or a cookie).
4. Subsequent Requests:  
For subsequent requests, the client includes the JWT in the Authorization header using the Bearer schema.
5. Token Verification:  
The server verifies the JWT by checking the signature and the token's claims (e.g., expiration time).

## 12. Explain how do we store sensitive user information such as password and credit card number in DB?
- Password: Utilize Hashing algorithm specifically designed for securely storing passwords, such as bcrypt, Argon2, or PBKDF2. Avoid using general-purpose hash functions like MD5 or SHA-1, which are not secure for password storage. And add salt to the hashed password. 
- Credit card: Use tokenization to replace sensitive data with a unique identifier (token). The actual credit card number is stored in a secure, separate vault, and only the token is stored in the database. This reduces the risk of exposing sensitive data if the database is compromised. Use encryption: If tokenization is not used, credit card numbers should be encrypted using strong encryption algorithms like AES (Advanced Encryption Standard) before storing them in the database.

## 13. Compare UserDetailService, AuthenticationProvider, AuthenticationManager, AuthenticationFilter. 
- UserDetailsService: Loads user-specific data, typically from a database. Provides UserDetails objects that contain user information.
- AuthenticationProvider: Performs actual authentication by verifying user credentials and creating Authentication objects.
- AuthenticationManager: Manages authentication by delegating requests to configured AuthenticationProvider instances.
- AuthenticationFilter: Intercepts HTTP requests, extracts credentials, and passes them to the AuthenticationManager for authentication.

## 14. What is the disadvantage of Session? how to overcome the disadvantage?
1. Server-side storage: Sessions are stored on the server, which can lead to scalability issues. As the number of users increases, the memory usage on the server also increases.
   - Overcome: Use distributed session management systems like Redis or Memcached to store session data. These systems can distribute the load across multiple servers and provide high availability.
2. Statefulness: Sessions make web applications stateful, which can complicate load balancing and failover scenarios.
   - Overcome: Implement sticky sessions (session affinity) where a user's requests are always directed to the same server. Alternatively, use a shared session store like Redis to ensure all servers can access the session data.
3. Security Risks: Session IDs can be intercepted and hijacked if not properly secured.
   - Overcome: Use HTTPS to encrypt the session ID in transit. Implement secure, HttpOnly, and SameSite attributes for session cookies to protect against XSS and CSRF attacks. Regularly regenerate session IDs to minimize the risk of session fixation attacks.

## 15. how to get value from application.properties in Spring security?
1. Use `@Value` annotation
   ```
   @Value("${security.jwt.secret}")
      private String jwtSecret;
   ```
2. Use `@ConfigurationProperties` annotation
   ```
   @Component
   @ConfigurationProperties(prefix = "security.jwt")
   public class JwtProperties {
      // ...
   }
   ```

## 16. What is the role of configure(HttpSecurity http) and configure(AuthenticationManagerBuilder auth)?
- `configure(HttpSecurity http)`: is used to configure security for HTTP requests. It allows you to define which endpoints are secured, what authentication mechanisms are used, how session management is handled, and other web security configurations.
- `configure(AuthenticationManagerBuilder auth)`: is used to configure the authentication mechanism. It allows you to set up user details services, authentication providers, and other authentication-related configurations.

## 17. What is Spring security authentication and authorization?
- Authentication: In Spring Security, this involves checking the credentials (such as username and password) provided by a user.
- Authorization: the process of determining if a user has the necessary permissions to access a resource or perform an action. In Spring Security, this involves checking the roles and authorities granted to a user.