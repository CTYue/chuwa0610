#Chuwa Homework 13 MingHao(Howard) Lee 

## 1. List all of the annotations you learned from class and homework to annotaitons.md

## 2. Explain TLS, PKI, certificate, public key, private key, and signature.
### TLS (Transport Layer Security)

- **Purpose**: Secures communication over a computer network.
- **Function**: Encrypts data to ensure privacy and data integrity.

### PKI (Public Key Infrastructure)

- **Purpose**: Manages digital certificates and public-key encryption.
- **Components**: Certificate Authority (CA), Registration Authority (RA), digital certificates.

### Certificate

- **Purpose**: Verifies the identity of the certificate holder.
- **Contains**: Public key, information about the owner, CA signature.

### Public Key

- **Purpose**: Encrypts data and verifies digital signatures.
- **Visibility**: Shared openly.

### Private Key

- **Purpose**: Decrypts data and creates digital signatures.
- **Visibility**: Kept secret.

### Signature

- **Purpose**: Ensures the authenticity and integrity of a message.
- **Creation**: Generated using the sender's private key.

## 3. list all http status codes that related to authentication and authorization failures.
1. **401 Unauthorized**

   - **Meaning**: The request requires user authentication. The client must authenticate itself to get the requested response.
   - **Typical Use**: Used when authentication is required and has failed or has not yet been provided.

2. **403 Forbidden**

   - **Meaning**: The server understood the request but refuses to authorize it. The client does not have access rights to the content.
   - **Typical Use**: Used when the user does not have the necessary permissions for the resource, even if they are authenticated.


## 4. Compare authentication and authorization?
### Authentication

- **Purpose**: Verifies the identity of a user or entity.
- **Process**: User provides credentials (e.g., username and password).
- **Outcome**: Confirms if the user is who they claim to be.

### Authorization

- **Purpose**: Determines the permissions and access rights of an authenticated user.
- **Process**: Checks user's permissions against the requested action/resource.
- **Outcome**: Grants or denies access to resources or actions based on permissions.

### Key Differences

- **Focus**: Authentication is about identity; Authorization is about permissions.
- **Sequence**: Authentication occurs before authorization.



## 5. What is HTTP Session?

- **Definition**: A sequence of network request-response transactions between a client and server.
- **Purpose**: Maintains stateful interaction in a stateless HTTP protocol.
- **Implementation**: Often managed using session IDs stored in cookies, URL parameters, or hidden form fields.
- **Usage**: Tracks user activity, stores user data (e.g., login status, preferences), and supports secure transactions.


## 6. What is Cookie?
- **Definition**: A small piece of data stored on the client's browser.
- **Purpose**: Maintains stateful information across multiple HTTP requests.
- **Components**:
  - **Name**: The identifier for the cookie.
  - **Value**: The data stored in the cookie.
  - **Domain**: Specifies the domain the cookie is associated with.
  - **Path**: Specifies the URL path the cookie is valid for.
  - **Expiration**: The date and time when the cookie expires.
  - **Secure**: Indicates if the cookie should only be sent over HTTPS.
  - **HttpOnly**: Prevents access to the cookie via JavaScript for security.
- **Usage**: Session management (e.g., login sessions), personalization (e.g., user preferences), and tracking (e.g., analytics).


## 7. What is the difference between Session and Cookie?
### Session
- **Storage Location**: Server-side.
- **Lifetime**: Typically lasts until the user logs out or the session expires.
- **Security**: More secure as data is stored on the server.
- **Usage**: Stores sensitive information like user authentication status.

### Cookie
- **Storage Location**: Client-side (browser).
- **Lifetime**: Can persist for a set duration or until the browser is closed.
- **Security**: Less secure as data is stored on the client.
- **Usage**: Stores less sensitive data like user preferences and session IDs.


## 8. How do we use session and cookie to keep user information across the the application?
### Session

1. **User Logs In**: Server creates a session and stores user information (e.g., user ID).
2. **Session ID**: Server generates a unique session ID.
3. **Store Session ID**: Server sends the session ID to the client in a cookie.
4. **Subsequent Requests**: Client sends the session ID cookie with each request.
5. **Retrieve Information**: Server uses the session ID to retrieve user information from server-side storage.

### Cookie

1. **Set Cookie**: Server sets a cookie with user information (e.g., user preferences).
2. **Store Data**: Data is stored directly in the cookie on the client's browser.
3. **Subsequent Requests**: Client sends the cookie with each request.
4. **Read Cookie**: Server reads the cookie data to retrieve user information.

### Combined Usage

- **Session**: Use for sensitive data and authentication (server-side).
- **Cookie**: Use for non-sensitive data like user preferences (client-side).


## 9. What is JWT?
### Definition

A compact, URL-safe token for securely transmitting information between parties as a JSON object.

### Structure

Consists of three parts:
1. **Header**: Specifies the token type (JWT) and the signing algorithm (e.g., HMAC, RSA).
2. **Payload**: Contains claims (e.g., user information, permissions).
3. **Signature**: Verifies the token's integrity using the header and payload.

### Purpose

Provides a way to securely transmit information and validate the authenticity of the token.

### Usage

- **Authentication**: Commonly used for user authentication.
- **Authorization**: Grants access to resources based on encoded permissions.
- **Information Exchange**: Safely transmits information between parties.

### Benefits

- **Stateless**: Does not require server-side sessions.
- **Scalable**: Easily distributed across servers.
- **Secure**: Signed to ensure data integrity and authenticity.

### Flow

1. **User Logs In**: Server generates a JWT with user information.
2. **Send JWT**: Server sends the JWT to the client.
3. **Store JWT**: Client stores the JWT (e.g., in local storage or cookies).
4. **Subsequent Requests**: Client sends the JWT with each request.
5. **Verify JWT**: Server verifies the JWT's signature and decodes the payload to retrieve user information.


## 10. What is the spring security filter?

### Definition

A component in the Spring Security framework that processes HTTP requests and responses to enforce security rules.

### Purpose

Manages authentication, authorization, and other security-related tasks.

### Position

Intercepts requests before they reach the application’s endpoints.

### Key Components

1. **Filter Chain**: A series of filters that apply security policies.
2. **Filters**:
   - **UsernamePasswordAuthenticationFilter**: Handles form-based login.
   - **BasicAuthenticationFilter**: Manages HTTP Basic Authentication.
   - **BearerTokenAuthenticationFilter**: Processes JWT or OAuth2 Bearer Tokens.
   - **SecurityContextPersistenceFilter**: Stores security context information across requests.
   - **ExceptionTranslationFilter**: Handles security exceptions.

### Flow

1. **Incoming Request**: Passes through the filter chain.
2. **Authentication**: Filters check if the user is authenticated.
3. **Authorization**: Filters verify if the authenticated user has the required permissions.
4. **Proceed**: Request proceeds to the application if security checks pass, otherwise, an appropriate response (e.g., error) is returned.

### Usage

- **Configuration**: Filters are configured in the `WebSecurityConfigurerAdapter` or using `SecurityFilterChain`.
- **Customization**: Custom filters can be added to extend or replace default behavior.


## 11. Explain how JWT works
### Structure
1. **Header**: Contains the type of token (JWT) and the signing algorithm (e.g., HMAC SHA256).
2. **Payload**: Contains claims, which are statements about an entity (typically, the user) and additional data.
3. **Signature**: Ensures the token hasn’t been altered. It is created by signing the header and payload with a secret key or a public/private key pair.

### Steps
1. **User Authentication**:
    - **Login Request**: User submits login credentials (e.g., username and password).
    - **Authentication**: Server verifies the credentials.
    - **JWT Creation**: Upon successful authentication, the server creates a JWT with user details and signs it with a secret key.

2. **Sending JWT**:
    - **Token Transmission**: The server sends the JWT back to the client, typically in the HTTP response.
    - **Storage**: The client stores the JWT, usually in local storage or a cookie.

3. **Subsequent Requests**:
    - **Attach JWT**: Client includes the JWT in the HTTP header (`Authorization: Bearer <token>`) for subsequent requests.
    - **Verify JWT**: Server verifies the JWT's signature and checks its validity (e.g., expiration).

4. **Access Resources**:
    - **Authorization**: Server checks the claims in the JWT to determine if the user has the necessary permissions to access the requested resource.
    - **Response**: If valid, the server processes the request and responds; otherwise, it returns an appropriate error (e.g., 401 Unauthorized).

### Benefits
- **Stateless**: No need for server-side session storage.
- **Scalable**: Easily distributed across different servers.
- **Secure**: Signed and optionally encrypted to ensure integrity and confidentiality.

### Example Flow
1. **Login**:
    - User logs in.
    - Server verifies credentials and issues a JWT.

2. **Storage**:
    - Client stores the JWT.

3. **Request with JWT**:
    - Client sends a request with the JWT in the header.
    - Server verifies and decodes the JWT.
    - Server processes the request based on the claims in the JWT.


## 12. Explain how do we store sensitive user information such as password and credit card number in DB?
### Passwords

**Hashing:**
- **Purpose:** Converts the password into a fixed-length string that cannot be easily reversed.
- **Algorithm:** Use strong hashing algorithms like bcrypt, Argon2, or PBKDF2.
- **Example:** `bcrypt` hashes the password with a salt, making it more secure.

**Salting:**
- **Purpose:** Adds a unique, random string to each password before hashing to prevent rainbow table attacks.
- **Process:** Generate a salt for each password, concatenate it with the password, and then hash the result.
- **Storage:** Store the salt alongside the hashed password in the database.

### Credit Card Numbers

**Encryption:**
- **Purpose:** Converts plaintext credit card numbers into ciphertext, which can only be decrypted with a specific key.
- **Algorithm:** Use strong encryption algorithms like AES (Advanced Encryption Standard).
- **Key Management:** Store encryption keys securely using a key management service (KMS) or hardware security module (HSM).

**Tokenization:**
- **Purpose:** Replaces credit card numbers with a unique identifier (token) that can be mapped back to the original number.
- **Process:** Use a tokenization service to generate tokens for credit card numbers.
- **Storage:** Store tokens in the database instead of actual credit card numbers.

### Best Practices

**Secure Storage:**
- **Hashing:** Never store plaintext passwords. Always use hashing with a salt.
- **Encryption:** Encrypt sensitive data like credit card numbers.
- **Environment:** Ensure the database is secure and accessible only by authorized services.

**Key Management:**
- **Rotation:** Regularly rotate encryption keys.
- **Access Control:** Restrict access to keys to only those who need it.

**Compliance:**
- **Standards:** Follow industry standards like PCI-DSS for credit card information.
- **Regulations:** Adhere to regulations such as GDPR for handling personal data.

**Monitoring and Auditing:**
- **Logs:** Keep logs of access to sensitive information.
- **Alerts:** Set up alerts for unauthorized access attempts.


## 13. Compare UserDetailService, AuthenticationProvider, AuthenticationManager, AuthenticationFilter?(把这几个名字看熟悉也行)
### UserDetailsService
- **Purpose:** Loads user-specific data.
- **Key Role:** Retrieves user details (e.g., username, password, roles) from a data source.
- **Usage:** Implemented to fetch user information during authentication.

### AuthenticationProvider
- **Purpose:** Processes authentication requests.
- **Key Role:** Verifies user credentials and creates an `Authentication` object.
- **Usage:** Customizable to support different authentication mechanisms (e.g., username/password, OAuth).

### AuthenticationManager
- **Purpose:** Manages authentication process.
- **Key Role:** Delegates authentication requests to a list of `AuthenticationProvider`s.
- **Usage:** Central interface for handling authentication.

### AuthenticationFilter
- **Purpose:** Intercepts HTTP requests for authentication.
- **Key Role:** Captures credentials from the request (e.g., login form, headers) and forwards them to the `AuthenticationManager`.
- **Usage:** Configured to trigger authentication for specific endpoints.

### Key Points
- **UserDetailsService:** Fetches user information.
- **AuthenticationProvider:** Validates credentials and generates authentication tokens.
- **AuthenticationManager:** Orchestrates authentication by delegating to providers.
- **AuthenticationFilter:** Captures and initiates authentication requests.

## 14. What is the disadvantage of Session? how to overcome the disadvantage?
### Disadvantages of Session

1. **Scalability Issues:**
   - **Problem:** Difficult to scale across multiple servers.
   - **Solution:** Use centralized session stores like Redis or Memcached.

2. **Statefulness:**
   - **Problem:** Complicates scaling and deployment.
   - **Solution:** Use stateless authentication methods like JWT (JSON Web Tokens).

3. **Security Risks:**
   - **Problem:** Vulnerable to session hijacking or fixation.
   - **Solution:** Use HTTPS, regenerate session IDs on login, and set secure and HttpOnly flags on cookies.

4. **Resource Consumption:**
   - **Problem:** Consumes server memory and resources.
   - **Solution:** Implement session expiration and cleanup mechanisms.

### Overcoming Session Disadvantages

- **Centralized Session Store:**
  - **Description:** Store sessions in Redis or Memcached.
  - **Benefit:** Facilitates horizontal scaling.

- **Stateless Authentication (JWT):**
  - **Description:** Use JWT to store authentication data in the token.
  - **Benefit:** Removes the need for server-side session storage.

- **Enhanced Security Practices:**
  - **Description:** Use HTTPS, regenerate session IDs, set secure and HttpOnly flags.
  - **Benefit:** Protects against hijacking and fixation.

- **Resource Management:**
  - **Description:** Set session timeouts and clean up expired sessions.
  - **Benefit:** Reduces server load and frees up resources.


## 15. how to get value from application.properties in Spring security?
### Accessing Values from `application.properties` in Spring

1. **Using `@Value` Annotation**
   - **Purpose:** Injects property value directly into a Spring bean.
   - **Example:**
     ```java
     @Value("${property.name}")
     private String propertyValue;
     ```

2. **Using `@ConfigurationProperties` Annotation**
   - **Purpose:** Binds properties to a POJO.
   - **Example:**
     ```java
     @ConfigurationProperties(prefix = "prefix")
     public class MyProperties {
         private String propertyName;
         // getters and setters
     }
     ```

3. **Using `Environment` Interface**
   - **Purpose:** Accesses properties programmatically.
   - **Example:**
     ```java
     @Autowired
     private Environment env;

     public void someMethod() {
         String propertyValue = env.getProperty("property.name");
     }
     ```
### Example in Spring Security Configuration

#### Using `@Value`

```java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Value("${security.jwt.secret}")
    private String jwtSecret;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // Use jwtSecret here
    }
}
```
#### Using `@ConfigurationProperties`
```java
@Configuration
@EnableConfigurationProperties(SecurityProperties.class)
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    private final SecurityProperties securityProperties;

    public SecurityConfig(SecurityProperties securityProperties) {
        this.securityProperties = securityProperties;
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        String jwtSecret = securityProperties.getJwt().getSecret();
        // Use jwtSecret here
    }
}

@ConfigurationProperties(prefix = "security")
public class SecurityProperties {
    private JwtProperties jwt = new JwtProperties();

    public static class JwtProperties {
        private String secret;
        // getters and setters
    }

    // getters and setters
}
```
#### Using `Environment`
```java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    private Environment env;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        String jwtSecret = env.getProperty("security.jwt.secret");
        // Use jwtSecret here
    }
}
```

## 16. What is the role of configure(HttpSecurity http) and configure(AuthenticationManagerBuilder auth)?
### `configure(HttpSecurity http)`

- **Purpose**: Configures security for HTTP requests.

- **Key Roles**:
  - **URL Authorization**: Defines which URLs are secured and who can access them.
  - **Form Login**: Configures login form details (e.g., login URL, success handler).
  - **Session Management**: Manages session settings (e.g., session fixation, session concurrency).
  - **CSRF Protection**: Enables/disables Cross-Site Request Forgery protection.
  - **Exception Handling**: Configures how security exceptions are handled.
  - **HTTP Basic/Digest Authentication**: Configures basic or digest authentication.

- **Example**:

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests()
            .antMatchers("/public/**").permitAll()
            .anyRequest().authenticated()
            .and()
        .formLogin()
            .loginPage("/login")
            .permitAll()
            .and()
        .logout()
            .permitAll();
}
```
### `configure(AuthenticationManagerBuilder auth)`

- **Purpose**: Configures authentication mechanisms.

- **Key Roles**:
  - **In-Memory Authentication**: Defines users and roles in-memory.
  - **JDBC Authentication**: Configures authentication using a database.
  - **LDAP Authentication**: Sets up authentication using LDAP.
  - **Custom Authentication Provider**: Adds custom authentication logic.

- **Example**:

```java
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth
        .inMemoryAuthentication()
            .withUser("user").password("{noop}password").roles("USER")
            .and()
            .withUser("admin").password("{noop}admin").roles("ADMIN");
}
```
### Summary

- `configure(HttpSecurity http)`: Manages HTTP request security (URLs, login, session, CSRF, etc.).
- `configure(AuthenticationManagerBuilder auth)`: Manages authentication setup (in-memory, JDBC, LDAP, custom providers).

## 17. What is Spring security authentication and authorization?
### Authentication

- **Purpose**: Verifies the identity of a user.
- **Process**:
  - **Credentials**: User provides credentials (e.g., username and password).
  - **Verification**: Spring Security checks credentials against a data source.
  - **Result**: On success, an `Authentication` object is created and stored in the security context.
- **Key Components**:
  - `AuthenticationManager`: Manages authentication process.
  - `AuthenticationProvider`: Performs the actual verification.
  - `UserDetailsService`: Loads user-specific data.

### Authorization

- **Purpose**: Determines the access rights of an authenticated user.
- **Process**:
  - **Role/Permission Check**: Validates if the authenticated user has the necessary roles/permissions.
  - **Access Decision**: Grants or denies access to requested resources.
- **Key Components**:
  - `AccessDecisionManager`: Makes the final access control decision.
  - `@PreAuthorize`, `@Secured`: Annotations for method-level security.
  - **URL Configuration**: Secures web endpoints (e.g., `http.authorizeRequests()`).

### Summary

- **Authentication**: Verifies user identity (e.g., login).
- **Authorization**: Controls access to resources based on roles/permissions.


## 18. Reading, 泛读一下即可，自己觉得是重点的，可以多看两眼。 [https://www.interviewbit.com/spring-security-interview-questions/#is-security-a-cross-cutting-concern](https://www.interviewbit.com/spring-security-interview-questions/#is-security-a-cross-cutting-concern)
    1. 1-12
    2. 17 - 30
