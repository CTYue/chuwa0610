# HW13
## 1.  List all of the annotations you learned from class and homework to annotaitons.md
See [annotations.md](annotations.md)
## 2.  Explain TLS, PKI, certificate, public key, private key, and signature.
### TLS (Transport Layer Security)
- A cryptographic protocol designed to provide secure communication over a computer network.
- Ensures privacy, data integrity, and authentication between two communicating applications.
### PKI (Public Key Infrastructure)
- a framework that manages digital keys and certificates. 
- Create, manage, distribute, use, store and revoke certificates and manage public-key encryption.
- Allows secure data exchange and authentication through cryptographic keys.
### Certificates
- a digital document that binds a public key to an entity's identity (like a person or organization).
- Ensure that the public key belongs to the named entity, enabling secure communication and authentication.
- Contains: 
  - public keys
  - Subject: holder information
  - Issuer: issuer information
  - Serial number: unique identifier of each certificate
  - ...
### Public Key
- A public key is a cryptographic key that can be shared openly and is used in asymmetric encryption.
- Encrypt data that can only be decrypted by the corresponding private key.
- Verify digital signatures created with the corresponding private key.
### Private Key
- A private key is a cryptographic key that must be kept secret.
- Decrypt data encrypted with the corresponding public key.
- Create digital signatures that can be verified by the corresponding public key.
### Signature
- A digital signature is a cryptographic value that is computed from data and a private key.
- Verifies the identity of the entity that created the signature.
- Ensures that the data has not been altered since the signature was created.
## 3.  list all http status codes that related to authentication and authorization failures.
Sure! Here is a list of HTTP status codes related to authentication and authorization failures:

### 401 Unauthorized
  - The request has not been applied because it lacks valid authentication credentials for the target resource.
  -  The client must authenticate itself to get the requested response.

### 403 Forbidden
  - The server understood the request but refuses to authorize it.
  - The client does not have permission to access the requested resource, even if authenticated.

### 407 Proxy Authentication Required
  - Similar to 401 Unauthorized, but it indicates that the client must first authenticate itself with the proxy.
  -  The client needs to authenticate with a proxy server.

## 4.  Compare authentication and authorization?
Authentication and authorization are two distinct concepts in the field of security, though they often work together to protect resources and control access. Here's a detailed comparison:

### Authentication
- Definition: Authentication is the process of verifying the identity of a user or system.
- Purpose: To ensure that the entity requesting access is who it claims to be.
- Mechanism: Typically involves credentials such as usernames and passwords, biometric data, tokens, or certificates.
- Examples:
  - Logging in to a website using a username and password.
  - Using a fingerprint or facial recognition to unlock a smartphone.
  - Providing an API key to access a web service.
- Questions Answered: "Who are you?"

### Authorization
- Definition: Authorization is the process of determining what an authenticated user or system is allowed to do.
- Purpose: To control access to resources and actions based on the entity's permissions.
- Mechanism: Often involves access control lists (ACLs), role-based access control (RBAC), or policy-based access control.
- Examples:
  - Allowing a logged-in user to access their own account details but not someone else's.
  - Granting an admin user the ability to delete records while a regular user can only view them.
  - Restricting certain API endpoints to users with specific roles.
- Questions Answered: "What are you allowed to do?"

## 5.  What is HTTP Session?
Let's delve into each concept and compare them:

### HTTP Session
- Definition: An HTTP session is a server-side storage of information that persists across multiple requests from the same client during a browsing session.
- Purpose: To maintain state and data about a user or client's interaction with a web application, enabling the server to remember the user’s activities and preferences.
- Mechanism: When a client logs in or starts a session, the server generates a unique session ID, which is sent to the client and stored (often in a cookie). This session ID is sent with each subsequent request to associate the request with the server-side session data.

## 6.  What is Cookie?

### Cookie
- Definition: A cookie is a small piece of data sent from a web server and stored on the client’s computer by the web browser. Cookies are used to remember information about the client between HTTP requests.
- Purpose: To store data on the client side to maintain stateful information across different pages and sessions.
- Mechanism: When a server sends a cookie to the client, the client stores it and includes the cookie in subsequent requests to the server, allowing the server to recognize the client and retrieve stored information.

## 7.  What is the difference between Session and Cookie?
### Cookie
- Data is stored on the client side, within the browser.
- Can have a specified expiration time. Some cookies (persistent cookies) can remain on the client device until they expire or are deleted by the user.
-  Less secure because data is stored on the client and can be more easily intercepted or manipulated. Secure cookies and HttpOnly flags can mitigate some risks.
- Limited in size (usually around 4KB per cookie). Browsers also limit the number of cookies that can be stored per domain.
-  Faster since data is stored and managed on the client side, but too many cookies can slow down client-side performance.
### Session
- Data is stored on the server side. The client only stores a session identifier (usually in a cookie).
- Typically lasts until the user logs out, the session expires, or the browser is closed (depending on server configuration).
- Generally considered more secure because sensitive data is stored on the server. If a session ID is intercepted, it can potentially be hijacked, but no sensitive data is exposed directly.
-  Limited only by server capacity. Typically, sessions can store more data because the server manages the storage.
- Can be slower if server-side storage is not optimized or if there are too many sessions, leading to increased server load.
## 8.  How do we use session and cookie to keep user information across the application?

#### Login Process
1. User Logs In:
  - The user submits their login credentials (username and password) via an HTTP POST request.
2. Server Authenticates User:
  - The server verifies the credentials. If valid, it creates a session and assigns a unique session ID.
3. Store Session Data:
  - The server stores user-specific data (e.g., user ID, role) in the session storage, associated with the session ID.
4. Set Session ID Cookie:
  - The server sends an HTTP response setting a cookie containing the session ID (e.g., `Set-Cookie: JSESSIONID=abc123`).

#### Subsequent Requests
1. Client Sends Request with Session ID Cookie:
  - For each subsequent request, the client’s browser includes the session ID cookie (e.g., `Cookie: JSESSIONID=abc123`).
2. Server Retrieves Session Data:
  - The server reads the session ID from the cookie, retrieves the session data from the session storage, and processes the request accordingly.

## 9.  What is JWT?
### JWT (JSON Web Token)
- an open standard (RFC 7519) for securely transmitting information between parties as a JSON object
- Structure of JWT
  - A JWT consists of three parts, separated by dots (.):
  - Header: Contains metadata about the token, including the type of token (JWT) and the signing algorithm used (e.g., HMAC SHA256 or RSA).
  - Payload: Contains the claims. Claims are statements about an entity (typically, the user) and additional data. There are three types of claims:
    - Registered claims: Predefined claims that are not mandatory but recommended (e.g., iss for issuer, exp for expiration time, sub for subject).
    - Public claims: Custom claims that are agreed upon by parties using the JWT.
    - Private claims: Custom claims created to share information between parties that agree on using them.
  - Signature: Created by taking the encoded header, the encoded payload, a secret, and the algorithm specified in the header. It ensures the token's integrity and authenticity.
- Example of a JWT
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c 
Header: {"alg": "HS256", "typ": "JWT"}
Payload: {"sub": "1234567890", "name": "John Doe", "iat": 1516239022}
Signature: HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)
```
## 10.  What is the spring security filter?
- An authentication and access control framework for Java applications
- provide a flexible and modular way to handle authentication and authorization
- Contains filter chain that composed of multiple filters that handle various security concerns.
- Filters:
  - UsernamePasswordAuthenticationFilter: Handles authentication based on username and password.
  - BasicAuthenticationFilter: Processes HTTP Basic Authentication credentials.
  - BearerTokenAuthenticationFilter: Extracts and validates JWT tokens for stateless authentication.
  - CsrfFilter: Protects against Cross-Site Request Forgery (CSRF) attacks.
  - SecurityContextPersistenceFilter: Loads the SecurityContext for the request, holding the authentication information.
  - ExceptionTranslationFilter: Handles any AccessDeniedException or AuthenticationException thrown within the filter chain.
  - FilterSecurityInterceptor: Performs authorization checks by invoking an AccessDecisionManager to decide whether a request is allowed to proceed. 
## 11.  Explain how JWT works
JWT (JSON Web Token) is a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity-protected with a Message Authentication Code (MAC) and/or encrypted.

### How JWT Works

1. Token Structure:
  - A JWT consists of three parts: the header, payload, and signature.
  - These parts are encoded in Base64Url and separated by dots (`.`).

   Example:
   ```
   eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
   ```

2. Header:
  - The header typically consists of two parts: the type of the token (JWT) and the signing algorithm being used (e.g., HMAC SHA256 or RSA).
  - Example:
    ```json
    {
      "alg": "HS256",
      "typ": "JWT"
    }
    ```

3. Payload:
  - The payload contains the claims. Claims are statements about an entity (typically, the user) and additional data.
  - Example:
    ```json
    {
      "sub": "1234567890",
      "name": "John Doe",
      "iat": 1516239022
    }
    ```

4. Signature:
  - To create the signature part, you have to take the encoded header, the encoded payload, a secret, and the algorithm specified in the header, and sign that.
  - For example, if you want to use the HMAC SHA256 algorithm, the signature will be created in the following way:
    ```
    HMACSHA256(
      base64UrlEncode(header) + "." +
      base64UrlEncode(payload),
      secret)
    ```

### How JWT Authentication Works

1. Client Authentication:
  - The client sends a login request with their credentials (e.g., username and password) to the authentication server.
  - eg. 
```http
POST /login
{
  "username": "user",
  "password": "password"
}
```

2. Server Validates Credentials:
  - The server verifies the credentials. If valid, it creates a JWT containing the user information and any additional claims needed for the application.
  - eg. 
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

Payload:
```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022,
  "exp": 1516249022
}
```

Signature:
```
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```

3. Server Returns JWT:
  - The server sends the JWT back to the client.
  - eg. 
```http
HTTP/1.1 200 OK
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
}
```


4. Client Stores JWT:
  - The client stores the JWT (typically in local storage, session storage, or a cookie).

5. Client Requests with JWT:
  - For subsequent requests to protected routes or resources, the client includes the JWT in the HTTP Authorization header.
  - eg:
```http
GET /protected
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

6. Server Validates JWT:
  - The server extracts the JWT from the Authorization header.
  - It verifies the token's signature to ensure it has not been tampered with and checks the token's claims (e.g., expiration time, issuer, subject).
  - If the token is valid, the server processes the request. If not, it rejects the request (e.g., with a 401 Unauthorized status).
## 12.  Explain how do we store sensitive user information such as password and credit card number in DB?
- Password
  - Hashing: 
    - Convert the password into a fixed-length string using a cryptographic hash function.
    - Hashes are designed to be irreversible, making it difficult for attackers to retrieve the original password.
    - Use a strong and secure hashing algorithm like bcrypt, scrypt, or Argon2.
  - Salting:
    - Add a unique, random value (salt) to each password before hashing.
    - Salting ensures that even if two users have the same password, their hashes will be different. 
  - Pepper:
    - Add a secret value (pepper) to the password before hashing.
- Credit Card
  - Encryption
    - Use encryption to protect credit card numbers.
    - Encryption ensures that even if the database is compromised, the data remains unreadable without the decryption key.
  - Tokenization
    - Replace sensitive data with a non-sensitive equivalent (token) that has no exploitable value.
    - Tokenization reduces the risk of exposing sensitive information.
    - Tokens can be mapped back to the original data only through a secure tokenization system.

## 13.  Compare UserDetailService, AuthenticationProvider, AuthenticationManager, AuthenticationFilter?(把这几个名字看熟悉也行)

- UserDetailsService:
  - Purpose: Fetches user details from a data source.
  - Role: Provides `UserDetails` for a given username.
  - Position in Workflow: Invoked by `AuthenticationProvider`.

- AuthenticationProvider:
  - Purpose: Validates user credentials.
  - Role: Authenticates the user and returns an `Authentication` object.
  - Position in Workflow: Invoked by `AuthenticationManager`.

- AuthenticationManager:
  - Purpose: Manages the authentication process.
  - Role: Delegates authentication to configured `AuthenticationProvider` instances.
  - Position in Workflow: Central component in the authentication process.

- AuthenticationFilter:
  - Purpose: Intercepts HTTP requests to extract authentication data.
  - Role: Extracts credentials and initiates authentication.
  - Position in Workflow: Entry point in the HTTP request processing pipeline.

These components work together to implement a robust authentication system in Spring Security, each with a specific responsibility in the process.
## 14.  What is the disadvantage of Session? how to overcome the disadvantage?
Sessions in web applications are widely used to maintain state and user information across multiple requests. However, they come with certain disadvantages. Let's explore these disadvantages and how to overcome them.

### Disadvantages of Sessions

1. Scalability Issues:
  - Problem: Sessions are typically stored in server memory. As the number of users grows, the memory usage on the server increases, which can lead to performance degradation and limits scalability.
  - Solution: Use distributed session management solutions such as:
    - Session Replication: Store sessions across multiple servers. This can be achieved using technologies like Hazelcast, Redis, or memcached.
    - Stateless Sessions: Use JWT (JSON Web Token) for stateless authentication, which stores session data on the client side instead of the server side.

2. Server Dependency:
  - Problem: If sessions are stored on a single server, users may lose their session if the server goes down.
  - Solution: Implement session replication or clustering, where sessions are shared across multiple servers. Alternatively, use an external session store like Redis or a database to persist sessions.

3. Security Risks:
  - Problem: Session IDs can be intercepted by attackers, leading to session hijacking.
  - Solution:
    - Use HTTPS to encrypt data in transit, protecting session IDs from being intercepted.
    - Implement secure cookies (HttpOnly and Secure flags) to protect session cookies from XSS attacks.
    - Implement session timeouts and regeneration of session IDs after login to minimize the risk of hijacking.
    - Use CSRF tokens to protect against cross-site request forgery attacks.

4. Resource Consumption:
  - Problem: Sessions consume server resources, particularly memory, which can impact the performance of the application.
  - Solution: Optimize session management by:
    - Implementing session timeouts to free up resources used by inactive sessions.
    - Storing only essential data in the session and minimizing the size of session objects.

5. Load Balancing Challenges:
  - Problem: When using load balancing, it can be challenging to ensure that requests from the same user are routed to the same server (session stickiness).
  - Solution:
    - Use a shared session store (e.g., Redis, database) to make sessions accessible to all servers in the cluster.
    - Implement sticky sessions (session affinity) at the load balancer level to route requests from the same user to the same server.


## 15.  how to get value from application.properties in Spring security?
- We can use @Value annotation to inject values from the application.properties file into Spring-managed beans. 
```properties
security.jwt.secret=mySecretKey
security.jwt.expiration=86400

```
```java
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@Configuration
public class Foo{

    @Value("${security.jwt.secret}")
    private String jwtSecret;

    @Value("${security.jwt.expiration}")
    private int jwtExpirationInMs;
    
}

```
## 16.  What is the role of configure(HttpSecurity http) and configure(AuthenticationManagerBuilder auth)?
- `configure(HttpSecurity http)`:
  - Role: Defines security policies for HTTP requests.
  - Key Configurations: URL authorization, login/logout configurations, CSRF protection, session management, exception handling, etc.

- `configure(AuthenticationManagerBuilder auth)`:
  - Role: Configures authentication mechanisms.
  - Key Configurations: In-memory authentication, JDBC authentication, LDAP authentication, custom authentication providers, etc.

## 17.  What is Spring security authentication and authorization?

#### Authentication:

1. AuthenticationManager:
  - The central interface for authentication. It delegates authentication requests to a list of `AuthenticationProvider` instances.

2. AuthenticationProvider:
  - Responsible for authenticating a user. It can have different implementations (e.g., in-memory, JDBC, LDAP) and supports multiple authentication mechanisms.
  - Example:
    ```java
    public class CustomAuthenticationProvider implements AuthenticationProvider {
        @Override
        public Authentication authenticate(Authentication authentication) throws AuthenticationException {
            String username = authentication.getName();
            String password = (String) authentication.getCredentials();
            // Logic to authenticate user (e.g., checking username and password)
            // Return an Authentication object if successful
        }

        @Override
        public boolean supports(Class<?> authentication) {
            return UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication);
        }
    }
    ```

3. UserDetailsService:
  - A core interface to load user-specific data. It is typically used to fetch user details from a database.
  - Example:
    ```java
    public class CustomUserDetailsService implements UserDetailsService {
        @Override
        public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
            // Logic to fetch user details from database
            return new User(username, password, authorities);
        }
    }
    ```

4. Authentication Filter:
  - Filters such as `UsernamePasswordAuthenticationFilter` intercept login requests and initiate the authentication process.
  - Example:
    ```java
    public class CustomAuthenticationFilter extends UsernamePasswordAuthenticationFilter {
        @Override
        public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
            String username = request.getParameter("username");
            String password = request.getParameter("password");
            return getAuthenticationManager().authenticate(new UsernamePasswordAuthenticationToken(username, password));
        }
    }
    ```

5. Security Configuration:
  - Configuration class to set up authentication.
  - Example:
    ```java
    @Configuration
    @EnableWebSecurity
    public class SecurityConfig extends WebSecurityConfigurerAdapter {
        @Autowired
        private CustomUserDetailsService userDetailsService;
        @Autowired
        private CustomAuthenticationProvider customAuthenticationProvider;

        @Override
        protected void configure(AuthenticationManagerBuilder auth) throws Exception {
            auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());
            auth.authenticationProvider(customAuthenticationProvider);
        }

        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http.authorizeRequests()
                .anyRequest().authenticated()
                .and()
                .formLogin().loginPage("/login").permitAll()
                .and()
                .logout().permitAll();
        }

        @Bean
        public PasswordEncoder passwordEncoder() {
            return new BCryptPasswordEncoder();
        }
    }
    ```

### Authorization

1. GrantedAuthority:
  - Represents an authority granted to the user. Usually corresponds to a role (e.g., ROLE_USER, ROLE_ADMIN).
  - Example:
    ```java
    List<GrantedAuthority> authorities = new ArrayList<>();
    authorities.add(new SimpleGrantedAuthority("ROLE_USER"));
    ```

2. Access Decision Manager:
  - Decides whether a user has access to a specific resource based on the authorities they possess and the configuration of the application.
  - Default implementation checks all `AccessDecisionVoter` instances.

3. Security Interceptor:
  - Intercepts method invocations and web requests to enforce security constraints.
  - Example: `FilterSecurityInterceptor` for web requests.

4. @PreAuthorize and @Secured:
  - Annotations to secure methods.
  - Example:
    ```java
    @Service
    public class MyService {
        @PreAuthorize("hasRole('ROLE_ADMIN')")
        public void adminMethod() {
            // Method logic
        }

        @Secured("ROLE_USER")
        public void userMethod() {
            // Method logic
        }
    }
    ```

5. Expression-Based Access Control:
  - Allows the use of complex security expressions in the configuration.
  - Example:
    ```java
    @Configuration
    @EnableWebSecurity
    public class SecurityConfig extends WebSecurityConfigurerAdapter {
        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http.authorizeRequests()
                .antMatchers("/admin/").access("hasRole('ROLE_ADMIN')")
                .antMatchers("/user/").access("hasRole('ROLE_USER')")
                .anyRequest().authenticated();
        }
    }
    ```

## 18.  Reading, 泛读一下即可，自己觉得是重点的，可以多看两眼。https://www.interviewbit.com/spring-security-interview-questions/#is-security-a-cross-cutting-concern
- 1-12
- 17 - 30