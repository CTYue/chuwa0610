# Homeword 45

## Yirun Wang

### 2. Explain TLS, PKI, certificate, publickey, privatekey, and signature.

**TLS - Transport Layer Security**

TLS is a protocol used for secure communication over a computer network. It is the successor to SSL (Secure Sockets Layer). TLS provides data encryption, data integrity, and authentication, and is widely used in HTTPS, email, and other network services.

**PKI - Public Key Infrastructure** 

Public Key Infrastructure (PKI) is a set of technologies and standards used to create, manage, distribute, use, store, and revoke digital certificates. PKI uses asymmetric encryption, involving a pair of keys (public and private), to ensure the security and authenticity of communications.

**Certificate**

A digital certificate is an electronic document issued by a Certificate Authority (CA) to prove ownership of a public key. The certificate contains the public key, owner information, and the CA’s digital signature. 

**Public Key**

A public key is part of an asymmetric encryption system and can be distributed publicly. It is used to encrypt data or verify digital signatures. Only the corresponding private key can decrypt data encrypted with the public key or generate a valid signature that can be verified with the public key.

**Private Key**

A private key is the other part of an asymmetric encryption system and must be kept secret. It is used to decrypt data or create digital signatures. The private key and public key work together to ensure secure communication.

**Signature**

A digital signature is a piece of data generated using a private key, used to verify the authenticity and integrity of a message or document. The recipient uses the sender’s public key to verify the signature, confirming that the message is indeed from the sender and has not been tampered with.

### 3. list all http status codes that related to authentication and authorization failures.

**401 Unauthorized**:

This status code indicates that the request has not been applied because it lacks valid authentication credentials for the target resource. 

**403 Forbidden**:

This status code indicates that the server understood the request but refuses to authorize it. A server that wishes to make public why the request has been forbidden can describe that reason in the response payload (if any).

**407 Proxy Authentication Required：**

This status code is similar to 401 Unauthorized, but it indicates that the client must first authenticate itself with the proxy. The proxy must return a Proxy-Authenticate header field containing a challenge applicable to the proxy for the requested resource.

Scenario: 

- A large corporation that uses a proxy server to control and monitor internet access for all employees. To access the internet, employees must authenticate themselves with the proxy server using their corporate credentials.

- An employee opens their web browser and tries to access an external website. 

- The proxy server checks if the employee's browser has already provided valid authentication credentials. Since this is the first request or previous credentials have expired, the proxy server determines that the request lacks valid authentication credentials.

- The proxy server responds to the employee's browser with a `407 Proxy Authentication Required` status code. This response includes a `Proxy-Authenticate` header indicating the authentication method(s) supported by the proxy.

- Upon receiving the 407 response, the employee's browser prompts them to enter their corporate username and password.

- The employee enters their corporate credentials, which the browser then sends to the proxy server.
- The proxy server validates the provided credentials. If the credentials are correct, the proxy server forwards the original request.
- The external website responds to the proxy server, which then relays the response back to the employee's browser. The employee can now access the website.

### 4. Compare authentication and authorization?

**Authentication is the process of verifying the identity of a user, device, or entity.** 

Methods to determine can be: 

- **Username and Password:** The most common form of authentication.
- **Biometrics:** Fingerprints, facial recognition, retinal scans.
- **Tokens:** Smart cards, hardware tokens.
- **Multi-factor Authentication (MFA):** Combines two or more authentication methods.
- **Certificates:** Digital certificates used in public key infrastructure (PKI).

**Authorization is the process of determining whether an authenticated user has permission to access a specific resource or perform a specific action.**

Methods:

**Access Control Lists (ACLs):** Specify which users or system processes are granted access to objects.

**Role-Based Access Control (RBAC):** Permissions are assigned to roles, and users are assigned roles.

**Attribute-Based Access Control (ABAC):** Permissions are based on attributes (e.g., user attributes, resource attributes).

**Policies:** Defined rules that determine access rights.

### 5. What is HTTP Session?

An HTTP session is a temporary information exchange between a server and a client.

It is a sequence of network request-response transactions that are initiated by the client using *TCP* or an alternative protocol on a specific port.

- Establishing a connection

  The client establishes the HTTP connection with the server using *TCP* or *QUIC* on one of the ports that the server is using to listen for HTTP connections.

  HTTP connections are stateless, so the server does not retain information about the user to be used in the case of multiple HTTP requests.

- Sending a request

  Once the connection is established, the user-agent can send the request. 

- Interpreting the response

  The server processes the request, sending back its answer, providing a status code and appropriate data.

### 6. What is Cookie?

A cookie is a small piece of data that a server sends to a user's web browser. The browser may store it and send it back with subsequent requests to the same server. Cookies are used to remember information about the user, enabling personalized experiences and maintaining session state across multiple requests.

Types of Cookies:

**Session Cookies**:

- **Lifetime**: Temporary; they are deleted once the browser is closed.
- **Purpose**: Maintain session state for a user during their visit to a website (e.g., keeping a user logged in while they navigate between pages).

**Persistent Cookies**:

- **Lifetime**: Remain on the user's device for a set period or until manually deleted.
- **Purpose**: Remember user preferences, login details, or tracking user behavior over time.

**First-Party Cookies**:

- **Source**: Set by the website the user is visiting.
- **Purpose**: Improve user experience, such as remembering login status or language preferences.

**Third-Party Cookies**:

- **Source**: Set by a domain different from the one the user is visiting, often used by advertisers and social media platforms.
- **Purpose**: Track users across different sites for advertising purposes.

Example of a Cookie in HTTP response header:

```css
HTTP/1.1 200 OK
Content-Type: text/html
Set-Cookie: session_id=abc123; Domain=example.com; Path=/; Expires=Wed, 21 Oct 2025 07:28:00 GMT; Secure; HttpOnly; SameSite=Strict

```

### 7. What is the difference between Session and Cookie?

**Session:**

- **Stored on the server side**. A session ID is stored on the client side, typically in a cookie, to reference the session data on the server.
- **Temporary and tied to the user's current visit.** Typically expires when the user closes their browser, although server-side configurations can extend session lifetimes.
- Sessions can also have a timeout period defined on the server, after which they expire automatically.
- **Larger storage capacity.** Generally used to store larger amounts of data securely since it's stored on the server.
- **More secure and suitable for sensitive data.** Only a session ID is exposed to the client, minimizing the risk of sensitive data being accessed or manipulated by the user.
- Commonly used for user authentication, shopping carts, and storing user preferences during a single visit.

**Cookie:**

- **Stored on the client side**, within the user's web browser.
- Can have a defined expiration date, which can make them **persistent** (lasting across browser sessions) **or temporary** (deleted when the browser is closed).
- If no expiration date is set, the cookie will be a session cookie, which expires when the browser is closed.
- Typically around 4KB per cookie. Browsers also have limits on the total number of cookies they can store per domain.
- **Less secure and suitable for small, non-sensitive data.** Less secure as they are stored on the client side and can be accessed and manipulated by the user or by malicious scripts (unless flagged as `HttpOnly`).
- **Limited storage capacity.** Commonly used for remembering login credentials, tracking user behavior, and storing user preferences.

### 8. How do we use session and cookie to keep user information across the the application?

When a browser request a web page, the server create a cookie and return it to the browser as part of the response. The browser then store that cookie in the user’s computer.

Cookies have a expired date that’s set by the server, when that date come, the cookie will be deleted from the user’s browser.

The browser send back that cookie each time it request a web page from that server.

Browsers generally accept only 20 cookie from each site, and 300 cookies in total.

When a user logs into the website, a session is created. In this session, you can created variable called “session variable” that store data in a key/value format ( like cookies ). 

The generated session ID is then sent to the user’s browser and stored as a cookie, while the session data is stored on the server-side.

Now, when the browser send a request to the server, it’ll send the cookies with the request. The server will receive the cookie from the incoming request and retrieve the value of the session ID. Afterwards, the server will search for the session and retrieve all the data stored within it once it is found.

### 9. What is JWT?

A JSON Web Token (JWT) is a compact, URL-safe token that is used to securely transmit information between parties as a JSON object.

JWTs are commonly used for authentication and authorization purposes in web applications.

A JWT consists of three parts, separated by dots ('.'):

1. **Header**
2. **Payload**
3. **Signature**

It looks like

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
.
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ
.
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

```

### 10. Explain how JWT works

**Authentication**:

- When a user logs in, the server validates the user's credentials and generates a JWT.

- The JWT is sent to the client and stored locally (e.g., in local storage or a cookie).

- For subsequent requests, the client includes the JWT in the HTTP header (typically in the `Authorization` header using the `Bearer` schema).

  ```
  Authorization: Bearer <token>
  ```

- The server receives the JWT, verifies its integrity, and extracts the user information from the payload.

**Authorization**:

- JWTs can include information about the user's roles and permissions.
- The server can use this information to grant or deny access to resources based on the user's permissions.

How to generate a JWT

```js
const jwt = require('jsonwebtoken');

const payload = {
  sub: "1234567890",
  name: "John Doe",
  iat: Math.floor(Date.now() / 1000) // Issued at time
};

const secret = 'your-256-bit-secret';

const token = jwt.sign(payload, secret, { algorithm: 'HS256' });

console.log(token);

```

Verify a JWT

```js
const token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c';

jwt.verify(token, secret, (err, decoded) => {
  if (err) {
    console.error('Invalid token:', err);
  } else {
    console.log('Decoded token:', decoded);
  }
});

```

### 11. What is the spring security filter?

These filters are part of the Spring Security filter chain, which is a series of servlet filters that intercept requests and responses to perform tasks such as authentication, authorization, session management, and more.

The Spring Security filter chain is typically configured in the `web.xml` file or through Java configuration.

- **`UsernamePasswordAuthenticationFilter`**: Processes requests to authenticate users based on username and password credentials.
- **`FilterSecurityInterceptor`**: Enforces access control rules for protected resources based on user roles and permissions.
- **`ConcurrentSessionFilter`**: Controls the maximum number of sessions a user can have concurrently.
- **`SessionManagementFilter`**: Manages session creation, invalidation, and tracking.
- **`CsrfFilter`**: Prevents Cross-Site Request Forgery (CSRF) attacks by validating tokens.
- **`LogoutFilter`**: Handles user logout requests.

### 12. Explain how do we store sensitive user information such as password and credit card number in DB?

1. Password Storage

   **Hashing**: Store passwords using a strong hashing algorithm like bcrypt, Argon2, or PBKDF2. Hashing converts the password into a fixed-length string using a one-way mathematical function, making it computationally difficult to reverse the hash to obtain the original password.

   Example using bcrypt in Java with Spring Security:

```java
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}
```

​		**Salting**: Use a unique salt (random value) for each password before hashing. Salting prevents attackers from using precomputed hash tables (rainbow tables) to crack passwords efficiently.

​		**Access Control**

2. Credit Card

   In most cases, it's recommended not to store credit card numbers unless absolutely necessary.

   **Encryption**: If you must store credit card numbers, encrypt them using strong encryption algorithms (AES-256, for example) with proper key management practices.

   Example of encrypting data using JCE (Java Cryptography Extension):

   ```java
   // Encrypt data
   Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
   cipher.init(Cipher.ENCRYPT_MODE, secretKey);
   byte[] encryptedData = cipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8));
   ```

   **Tokenization**: Use tokenization services provided by payment processors to store tokens instead of actual credit card numbers. Tokens are used for transactions without exposing sensitive data in your database.

   **Access Control**

### 13. Compare UserDetailService, AuthenticationProvider, AuthenticationManager, AuthenticationFilter?

- UserDetailService

Provides a way for Spring Security to retrieve user details (username, password, roles, etc.) from a data source (usually a database).

Typically used to integrate with a database or any other user repository to fetch user details during authentication.

```java
public interface UserDetailsService {
    UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
}

```

- AuthenticationProvider

Performs authentication based on provided credentials (usually username and password).

Validates credentials and builds an authenticated `Authentication` object if successful.

Can be customized to support different authentication mechanisms (e.g., LDAP, custom databases).

Typically used to handle specific authentication logic (e.g., custom validation rules).

```java
public interface AuthenticationProvider {
    Authentication authenticate(Authentication authentication) throws AuthenticationException;
    boolean supports(Class<?> authentication);
}

```

- AuthenticationManager

Manages authentication by delegating authentication requests to one or more `AuthenticationProvider` implementations.

Coordinates authentication providers and validates credentials.

Centralizes authentication logic and manages the authentication process.

Responsible for invoking `AuthenticationProvider` instances to authenticate a user.

```java
public interface AuthenticationManager {
    Authentication authenticate(Authentication authentication) throws AuthenticationException;
}

```

- **AuthenticationFilter**

A servlet filter provided by Spring Security for processing form-based authentication requests.

Intercepts login requests (`/login` endpoint by default) and validates credentials.

Automatically configured by Spring Security when using form-based login.

Invokes `AuthenticationManager` to authenticate users based on provided credentials.

```java
public class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter {
    // Implementation details...
}
```

### 14. What is the disadvantage of Session? how to overcome the disadvantage?

-  Sessions require server-side storage and processing, which can increase the load on the server and reduce scalability.

- **Scalability Concerns:** 

  Sessions typically rely on server-side storage, which can become a bottleneck as the application scales horizontally (adding more servers). Ensuring session data consistency across servers in a distributed environment can be complex.

- **Session Fixation Attacks**:

  Session fixation occurs when an attacker sets a user's session ID to a known value, potentially compromising the user's session security. Preventing such attacks requires careful session management practices, including session ID regeneration on authentication.

Solutions:

**Token-Based Authentication**: Using tokens (like JSON Web Tokens, JWT) for authentication and authorization, which are stateless and can be validated without server-side storage.

**Database or Cache Storage**: Using persistent storage (like databases or distributed caches) for session data to improve scalability and reliability.

**Session Encryption and Integrity**: Encrypting session data and ensuring its integrity during transmission and storage to prevent tampering and unauthorized access.

**Short-lived Sessions**: Implementing short-lived sessions and providing mechanisms for users to log out manually to reduce the risk of session-related attacks.

**Stateless Design**: Designing applications to be stateless where possible, reducing reliance on sessions for maintaining application state.

### 15. how to get value from application.properties in Spring security?

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Value("${myapp.security.admin.username}")
    private String adminUsername;

    @Value("${myapp.security.admin.password}")
    private String adminPassword;

    @Value("${myapp.security.jwt.secret}")
    private String jwtSecret;

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
            .withUser(adminUsername)
            .password("{noop}" + adminPassword) // {noop} for plain text password (not recommended for production)
            .roles("ADMIN");
    }

    // Other security configurations...

}

```



### 16. What is the role of configure(HttpSecurity http) and configure(AuthenticationManagerBuilder auth)?

In Spring Security, `configure(HttpSecurity http)` and `configure(AuthenticationManagerBuilder auth)` are two crucial methods that you override in your security configuration class (`WebSecurityConfigurerAdapter`) to customize the security settings for your application.

- **configure(HttpSecurity http)**

The `configure(HttpSecurity http)` method is used to configure how **HTTP requests** should be secured. It allows you to define which URL paths should be secured, what authentication methods are required, and what access rules should be applied.

**Authorization Rules**: Specify which URL paths are accessible to which roles or users (`permitAll()`, `hasRole()`, etc.).

**Form-based Login Configuration**: Configure login form details (`loginPage()`, `permitAll()`, etc.).

**Logout Configuration**: Define logout behavior (`logoutUrl()`, `logoutSuccessUrl()`, etc.).

**Cross-Site Request Forgery (CSRF) Protection**: Enable or customize CSRF protection (`csrf()`, `csrfTokenRepository()`, etc.).

**Exception Handling**: Configure how to handle authentication failures or access denied situations (`exceptionHandling()`).

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests()
            .antMatchers("/public/**").permitAll() // Allow public access
            .anyRequest().authenticated() // Require authentication for all other requests
            .and()
        .formLogin()
            .loginPage("/login") // Custom login page URL
            .permitAll() // Allow access to the login page
            .and()
        .logout()
            .logoutUrl("/logout") // Custom logout URL
            .permitAll(); // Allow access to the logout URL
}

```

- **configure(AuthenticationManagerBuilder auth)**

The `configure(AuthenticationManagerBuilder auth)` method is used to configure how Spring Security performs **authentication**. It allows you to specify the authentication mechanism, such as in-memory authentication, JDBC authentication, LDAP authentication, or custom authentication providers.

**Authentication Provider Setup**: Configure authentication providers (`auth.inMemoryAuthentication()`, `auth.jdbcAuthentication()`, etc.).

**User Details Service Configuration**: Set up a custom `UserDetailsService` for retrieving user details (`auth.userDetailsService()`).

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private CustomUserDetailsService customUserDetailsService;

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(customUserDetailsService);
    }

    // Other security configurations...
}

```

`auth.userDetailsService(customUserDetailsService)` sets up Spring Security to use `CustomUserDetailsService` for loading user details during authentication.

The CustomUserDetailsService:

```java
@Service
public class CustomUserDetailsService implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username);
        if (user == null) {
            throw new UsernameNotFoundException("User not found with username: " + username);
        }
        return new org.springframework.security.core.userdetails.User(
            user.getUsername(), user.getPassword(), getAuthorities(user));
    }

    private Set<GrantedAuthority> getAuthorities(User user) {
        Set<GrantedAuthority> authorities = new HashSet<>();
        // Add authorities based on roles or permissions of the user
        user.getRoles().forEach(role -> {
            authorities.add(new SimpleGrantedAuthority(role.getName()));
            role.getPermissions().forEach(permission ->
                authorities.add(new SimpleGrantedAuthority(permission.getName())));
        });
        return authorities;
    }
}

```

**Password Encoding**: Specify the password encoder (`auth.passwordEncoder()`).

```java
@Autowired
public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
    auth
        .inMemoryAuthentication()
            .withUser("user").password("{noop}password").roles("USER")
            .and()
        .withUser("admin").password("{noop}admin").roles("ADMIN");
}

```



### 17. What is Spring security authentication and authorization?

- Authentication:

**Identity Verification**: Validates the identity of users through credentials such as username/password, tokens, certificates, etc.

**Principal**: Represents the authenticated identity (e.g., `UserDetails` object containing username, roles).

**Authentication Providers**: Components that perform the actual authentication process based on provided credentials.

Authentication Providers typically implement the `AuthenticationProvider` interface in Spring Security. 

`DaoAuthenticationProvider` (using a `UserDetailsService`), `LdapAuthenticationProvider` (for LDAP authentication), and `JwtAuthenticationProvider` (for JWT token authentication).

- Authorization:

**Access Control**: Defines rules and policies to grant or deny access to resources based on roles, permissions, or other criteria.

**Role-based Access Control (RBAC)**: Assigns users to roles, with each role having certain permissions.

**Permission-based Access Control**: Grants access based on specific permissions assigned to users.

**Method-level Security**: Secures individual methods or endpoints based on roles or permissions.

**Global Security Configurations**: Define access rules for entire applications or specific URL patterns.