## 3. What is the Aspect Oriented Programming, explain it with detailed use cases?
AOP uses aspects in programming. It can be defined as the breaking of code into different modules, also known as modularisation, where the aspect is the key unit of modularity. Aspects enable the implementation of crosscutting concerns such as- transaction, logging not central to business logic without cluttering the code core to its functionality. It does so by adding additional behaviour that is the advice to the existing code. For example- Security is a crosscutting concern, in many methods in an application security rules can be applied, therefore repeating the code at every method, define the functionality in a common class and control were to apply that functionality in the whole application.  
Spring uses proxy based mechanism i.e. it creates a proxy Object which will wrap around the original object and will take up the advice which is relevant to the method call. Proxy objects can be created either manually through proxy factory bean or through auto proxy configuration in the XML file and get destroyed when the execution completes. Proxy objects are used to enrich the Original behaviour of the real object.
### Use Cases
1. Logging: Automatically log method entry, exit, and exceptions across various layers of the application (e.g., service, repository).
   ```
   @Aspect
   public class LoggingAspect {
      private static final Logger logger = LoggerFactory.getLogger(LoggingAspect.class);

      @Before("execution(* com.example.service.*.*(..))")
      public void logBefore(JoinPoint joinPoint) {
         logger.info("Entering method: " + joinPoint.getSignature().getName());
      }

      @After("execution(* com.example.service.*.*(..))")
      public void logAfter(JoinPoint joinPoint) {
         logger.info("Exiting method: " + joinPoint.getSignature().getName());
      }

      @AfterThrowing(pointcut = "execution(* com.example.service.*.*(..))", throwing = "error")
      public void logException(JoinPoint joinPoint, Throwable error) {
         logger.error("Exception in method: " + joinPoint.getSignature().getName(), error);
      }
   }

   ```
2. Transaction Management: Automatically manage transactions by starting a transaction before a method execution and committing/rolling back after method execution based on the outcome.
   ```
   @Aspect
   @Component
   public class TransactionAspect {
      @Autowired
      private PlatformTransactionManager transactionManager;

      @Around("execution(* com.example.service.*.*(..))")
      public Object manageTransaction(ProceedingJoinPoint joinPoint) throws Throwable {
         TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());
         Object result;
         try {
               result = joinPoint.proceed();
               transactionManager.commit(status);
         } catch (Throwable ex) {
               transactionManager.rollback(status);
               throw ex;
         }
         return result;
      }
   }

   ```
3. Security: Enforce security checks before executing sensitive methods to ensure the user has the necessary permissions.
   ```
   @Aspect
   @Component
   public class SecurityAspect {
      @Before("execution(* com.example.service.*.*(..)) && @annotation(com.example.security.Secure)")
      public void checkSecurity(JoinPoint joinPoint) throws Throwable {
         // Check if the user has the necessary permissions
         // Throw an exception if the check fails
      }
   }

   ```
4. Caching: Implement caching logic to store method results and return cached results for subsequent calls to improve performance.
   ```
   @Aspect
   @Component
   public class CachingAspect {
      private final Map<String, Object> cache = new ConcurrentHashMap<>();

      @Around("execution(* com.example.service.*.*(..)) && @annotation(com.example.cache.Cacheable)")
      public Object cacheMethod(ProceedingJoinPoint joinPoint) throws Throwable {
         String key = generateKey(joinPoint);
         if (cache.containsKey(key)) {
               return cache.get(key);
         }
         Object result = joinPoint.proceed();
         cache.put(key, result);
         return result;
      }

      private String generateKey(ProceedingJoinPoint joinPoint) {
         // Generate a unique key based on method signature and parameters
         return joinPoint.getSignature().toString() + Arrays.toString(joinPoint.getArgs());
      }
   }

   ```

## 4. What are the advantages and disadvantages of Spring AOP?
### Advantages
- Separation of Concerns: Spring AOP allows you to separate cross-cutting concerns (such as logging, transaction management, security) from the business logic. This results in cleaner and more maintainable code.
- Code Reusability: Common functionality can be defined once in an aspect and reused across multiple points in an application. This reduces code duplication.
- Centralized Control: Centralizes the management of cross-cutting concerns, making it easier to modify and control them across the application.
## Disadvantages
- Complexity: Introducing AOP can add a layer of complexity to the application. Developers need to understand how AOP works and how aspects interact with the application.
- Performance Overhead: Applying aspects, especially when using @Around advice, can introduce performance overhead due to additional method invocations and processing.

## 5. Explain following concept in your own words, you may include code snippet as part of your answer.
1. Aspect: An aspect is a module that manages the cross-cutting concerns, which include logging, security and transaction management. Those cross-cutting concerns are not part of the main features of a program. However, they provide support to the main program and make sure it runs smoothly.
   ```
   // Aspect class can be defined by @Aspect annotation.
   // An aspect class should contains advice methods
   @Aspect
   public class LoggingAspect {

      @Before("execution(* com.example.demo.*.*(..))")
      public void logBefore() {
         System.out.println("Before method execution");
      }
   }
   ```
2. Join Point: a join point is a specific point during the execution of a program such as a method call, constructor invocation, or field access, where an aspect can be plugged in.
   ```
   @Aspect
   class Logging { 
   
      // Passing a JoinPoint Object 
      // into parameters of the method 
      // with the annotated advice 
      // enables to print the information 
      /// when the advice is executed 
      // with the help of toString() method 
      // present in it. 
   
      @Before("execution(public void com.aspect.ImplementAspect.aspectCall())") 
      public void loggingAdvice1(JoinPoint joinpoint) 
      { 
         System.out.println("Before advice is executed"); 
         System.out.println(joinpoint.toString()); 
      } 
   } 
   ```
3. Pointcut: pointcut defines where an aspect's advice should be applied in the codebase. It selects specific join points in the application.
   ```
   @Aspect
   class Logging { 
   
      // pointcut() is a dummy method 
      // required to hold @Pointcut annotation 
      // pointcut() can be used instead of writing line 1 
      // whenever required, as done in line 4. 
      // This prevents a repetition of code. 
   
      @Pointcut("execution(public void com.aspect.ImplementAspect.aspectCall())") // line 1 
      public void pointCut() 
      { 
      } 
   
      // pointcut() is used to avoid repetition of code 
      @Before("pointcut()") 
      public void loggingAdvice1() 
      { 
         System.out.println("Before advice is executed"); 
      } 
   } 
   ```
4. Advice: advice is the action taken by an aspect at a particular join point. It is the actual code that implements the cross-cutting concern. Advice also includes these following types:
   - Before: Executed before a join point (e.g., a method call).
   - After: Executed after a join point, regardless of its outcome.
   - AfterReturning: Executed after a join point completes normally.
   - AfterThrowing: Executed if a method exits by throwing an exception.
   - Around: Surrounds a join point, allowing the advice to perform actions before and after the join point executes. It can also control whether the join point executes at all.

   ```
   @Aspect
   class Logging { 
   
      // Implementing all the five pieces of advice 
      // to execute AfterThrowing advice enter integer value as 1. 
   
      // **Before** 
      @Before("execution(public void com.aspect.ImplementAspect.aspectCall())") 
      public void loggingAdvice1() 
      { 
         System.out.println("Before advice is executed"); 
      } 
   
      // **After** 
      @After("execution(public void com.aspect.ImplementAspect.aspectCall())") 
      public void loggingAdvice2() 
      { 
         System.out.println("Running After Advice."); 
      } 
   
      // **Around** 
      @Around("execution(public void com.aspect.ImplementAspect.myMethod())") 
      public void loggingAdvice3() 
      { 
         System.out.println("Before and After invoking method myMethod"); 
      } 
   
      // **AfterThrowing** 
      @AfterThrowing("execution(" public void com.aspect.ImplementAspect.aspectCall()) 
      ") 
         public void
         loggingAdvice4() 
      { 
         System.out.println("Exception thrown in method"); 
      } 
   
      // **AfterRunning** 
      @AfterReturning("execution(public void com.aspect.ImplementAspect.myMethod())") 
      public void loggingAdvice5() 
      { 
         System.out.println("AfterReturning advice is run"); 
      } 
   } 
   ```

## 6. How do we declare a pointcut, can we declare it without annotating an empty method? Name some expressions to do it.
We can declare a pointcut with an annotation method:
   ```
   @Aspect
   public class LoggingAspect {

      @Pointcut("execution(* com.example.service.*.*(..))")
      public void serviceMethods() {
         // This method is empty because it only serves as a pointcut reference
      }

      @Before("serviceMethods()")
      public void logBeforeServiceMethods(JoinPoint joinPoint) {
         System.out.println("Logging before method: " + joinPoint.getSignature().getName());
      }
   }
   ```
To declare a pointcut without annotating an empty method, we can do it directly in advice annotations:
   ```
   @Aspect
   public class LoggingAspect {

      @Before("execution(* com.example.service.*.*(..))")
      public void logBeforeServiceMethods(JoinPoint joinPoint) {
         System.out.println("Logging before method: " + joinPoint.getSignature().getName());
      }
   }

   ```
Pointcut expressions:   
1. Execution: `@Pointcut("execution(* com.example.service.*.*(..))")`
2. Within: `@Pointcut("within(com.example.service..*)")`
3. Args: `@Pointcut("args(java.io.Serializable)")`
4. This and Target: `@Pointcut("this(com.example.service.MyService)")`, `@Pointcut("target(com.example.service.MyService)")`
5. Annotation: `@Pointcut("@annotation(org.springframework.transaction.annotation.Transactional)")`
6. Bean: `@Pointcut("bean(*Controller)")`

## 7. Compare different types of advices in Spring AOP.
- Before: Executed before a join point (e.g., a method call).
- After: Executed after a join point, regardless of its outcome.
- AfterReturning: Executed after a join point completes normally.
- AfterThrowing: Executed if a method exits by throwing an exception.
- Around: Surrounds a join point, allowing the advice to perform actions before and after the join point executes. It can also control whether the join point executes at all.

## 9. Spring WebFlux vs StreamAPI + CompletableFuture, why use Spring WebFlux over the other?
1. Scalability: WebFlux's non-blocking I/O and reactive streams support make it highly scalable, allowing you to handle many more concurrent connections with fewer resources.
2. Reactive Ecosystem: WebFlux is part of the larger reactive ecosystem in Spring, which includes Project Reactor, making it easier to build complex reactive applications.
3. Declarative Approach: The declarative and composable nature of WebFlux's APIs makes it easier to write and maintain complex asynchronous workflows.
4. Integration: WebFlux integrates seamlessly with other Spring projects, providing a comprehensive solution for building full-featured web applications.
5. Handling Backpressure: WebFlux provides built-in support for backpressure, ensuring that your application can handle varying loads and prevent resource exhaustion.

## 10. When to use Spring Batch? please provide detailed exaples with business context.
Spring Batch is a powerful framework for batch processing, designed to handle the processing of large volumes of data in a reliable, efficient, and scalable manner. It provides reusable functions essential for processing large datasets, including logging/tracing, transaction management, job processing statistics, job restart, and more.
Spring Batch can bu used in:
1. Data Migration: A company is moving data from an old legacy system to a new database schema or from one database type to another (e.g., from MySQL to PostgreSQL).
2. ETL (Extract, Transform, Load) Processes: An organization needs to extract data from multiple sources (e.g., databases, files), transform it according to business rules, and load it into a data warehouse for analytics.
3. Financial Data Processing: A financial institution needs to process daily transactions, generate reports, and reconcile accounts.
4. Generating Reports: An e-commerce company needs to generate daily sales reports and email them to management.

## 11. How does Spring Batch work? you may include code snippet as part of your answer.
Spring Batch work flow inclues:
1. Job: Represents the entire batch process. A job consists of multiple steps.
2. Step: A single phase of a job. Each step typically involves reading, processing, and writing data.
3. ItemReader: Reads data from a source (e.g., file, database).
4. ItemProcessor: Processes or transforms the data.
5. ItemWriter: Writes the data to a destination (e.g., file, database).
6. JobRepository: Stores the metadata about the batch jobs (e.g., job execution status).
7. JobLauncher: Starts a job execution.  
Item processor
   ```
   @Component
   public class PersonItemProcessor implements ItemProcessor<Person, Person> {
      @Override
      public Person process(Person person) throws Exception {
         person.setFirstName(person.getFirstName().toUpperCase());
         person.setLastName(person.getLastName().toUpperCase());
         return person;
      }
   }

   @Configuration
   @EnableBatchProcessing
   public class BatchConfiguration {

      @Bean
      public FlatFileItemReader<Person> reader() {
         return new FlatFileItemReaderBuilder<Person>()
                  .name("personItemReader")
                  .resource(new ClassPathResource("people.csv"))
                  .delimited()
                  .names("firstName", "lastName")
                  .fieldSetMapper(new BeanWrapperFieldSetMapper<>() {{
                     setTargetType(Person.class);
                  }})
                  .build();
      }

      @Bean
      public JdbcBatchItemWriter<Person> writer(DataSource dataSource) {
         return new JdbcBatchItemWriterBuilder<Person>()
                  .itemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider<>())
                  .sql("INSERT INTO person (first_name, last_name) VALUES (:firstName, :lastName)")
                  .dataSource(dataSource)
                  .build();
      }

      @Bean
      public Job importUserJob(JobBuilderFactory jobBuilderFactory, Step step1) {
         return jobBuilderFactory.get("importUserJob")
                  .incrementer(new RunIdIncrementer())
                  .flow(step1)
                  .end()
                  .build();
      }

      @Bean
      public Step step1(StepBuilderFactory stepBuilderFactory, FlatFileItemReader<Person> reader,
                        PersonItemProcessor processor, JdbcBatchItemWriter<Person> writer) {
         return stepBuilderFactory.get("step1")
                  .<Person, Person>chunk(10)
                  .reader(reader)
                  .processor(processor)
                  .writer(writer)
                  .build();
      }
   }
   ```

## 12. How can we schedule a Spring Batch Job?
We can use `@Scheduled` annotation with `@EnableScheduling`.
   ```
   @Component
   @EnableScheduling
   public class BatchScheduler {

      @Autowired
      private JobLauncher jobLauncher;

      @Autowired
      private Job importUserJob;

      @Scheduled(cron = "0 0 * * * ?") // This cron expression means every hour
      public void runJob() throws Exception {
         JobParameters params = new JobParametersBuilder()
                  .addLong("time", System.currentTimeMillis())
                  .toJobParameters();
         jobLauncher.run(importUserJob, params);
      }
   }
   ```

## 13. What is cron expression
Cron expressions are used to configure instances of CronTrigger, a subclass of org.quartz.Trigger. A cron expression is a string consisting of six or seven subexpressions (fields) that describe individual details of the schedule.
| Name         | Required | Allowed Values      | Allowed Special Characters      |
|--------------|----------|---------------------|---------------------------------|
| Seconds      | Y        | 0-59                | , - * /                         |
| Minutes      | Y        | 0-59                | , - * /                         |
| Hours        | Y        | 0-23                | , - * /                         |
| Day of month | Y        | 1-31                | , - * ? / L W C                 |
| Month        | Y        | 0-11 or JAN-DEC     | , - * /                         |
| Day of week  | Y        | 1-7 or SUN-SAT      | , - * ? / L C #                 |
| Year         | N        | empty or 1970-2099  | , - * /                         |

## 14. Explain Spring task?
Spring Task is a part of the Spring Framework that provides support for scheduling tasks and managing task execution. It is built on top of the java.util.concurrent package and provides a powerful and flexible way to schedule tasks, execute them asynchronously, and manage their execution.  
Key Components:
1. TaskScheduler: Provides scheduling capabilities to execute tasks at specified times or intervals.
2. TaskExecutor: Provides asynchronous execution of tasks.
3. `@Scheduled`: Annotation to mark methods to be executed on a scheduled basis.
4. `@Async`: Annotation to mark methods to be executed asynchronously.
   ```
   // Schedule a task
   @Component
   public class ScheduledTasks {

      @Scheduled(fixedRate = 5000)
      public void scheduleTaskWithFixedRate() {
         System.out.println("Fixed rate task - " + System.currentTimeMillis() / 1000);
      }

      @Scheduled(fixedDelay = 5000)
      public void scheduleTaskWithFixedDelay() {
         System.out.println("Fixed delay task - " + System.currentTimeMillis() / 1000);
      }

      @Scheduled(cron = "0 0 * * * ?")
      public void scheduleTaskWithCronExpression() {
         System.out.println("Cron expression task - " + System.currentTimeMillis() / 1000);
      }
   }
   ```

## 15. What is Filter and any filter example?
A filter is an object that performs filtering tasks on either the request to a resource (a servlet or static content), or on the response from a resource, or both. Filters are typically used to perform tasks such as logging, authentication, authorization, input validation, and more.  
Example: A logging filter
   ```
   public class LoggingFilter implements Filter {

      private static final Logger logger = Logger.getLogger(LoggingFilter.class.getName());

      @Override
      public void init(FilterConfig filterConfig) throws ServletException {
         // Initialization code if necessary
      }

      @Override
      public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
               throws IOException, ServletException {
         logger.info("Request received at " + request.getRemoteAddr());
         chain.doFilter(request, response);
         logger.info("Response sent to " + request.getRemoteAddr());
      }

      @Override
      public void destroy() {
         // Cleanup code if necessary
      }
   }
   ```

## 16. What is the Interceptor? What we can do with interceptor?
An interceptor in Spring is a component that allows you to intercept HTTP requests and responses, providing a way to perform operations before or after the request is processed by a controller. Interceptors are often used for logging, authentication, authorization, performance monitoring, and modifying requests or responses.  
Key Points about Interceptors
- HandlerInterceptor: In Spring, interceptors are typically implemented using the HandlerInterceptor interface.
- Lifecycle Methods: Interceptors have methods that allow you to perform actions at different points in the request lifecycle:
   - preHandle: Called before the handler (controller) method is invoked.
   - postHandle: Called after the handler method is invoked, but before the view is rendered.
   - afterCompletion: Called after the complete request has finished.

## 17. In Interceptor, What is preHandle? What is postHandle?
- preHandle: Called before the handler (controller) method is invoked.
- postHandle: Called after the handler method is invoked, but before the view is rendered.

## 18. What is Swagger, why do we need it? What does it do except "documentation"?
Swagger is an open-source framework for designing, building, documenting, and consuming RESTful web services. It simplifies the development and consumption of APIs by providing tools for automatic generation of API documentation, client SDK generation, and API testing. Swagger has been integrated into the OpenAPI Initiative, which standardizes how REST APIs are described.  
We need swagger to understand the API endpoints better. Because sometimes documentation of the API endpoints might be outdated. Swagger is always updated with the code.  
Besides documentation, swagger also offers:
1. Interactive API Exploration and Testing: Allows developers and testers to interact with the API directly from the browser. They can send requests and see responses without writing any client code.
2. Client SDK Generation: Generates client libraries in various programming languages (e.g., Java, Python, JavaScript) based on the OpenAPI specification.
3. Server Stub Generation: generates server stubs, which provide the basic framework for implementing the API on the server side.

