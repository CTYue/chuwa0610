# HW14

**2. what is selenium?**

It’s a test tool used for automating web browsers. Which can be used in Cross-Browser Testing.

**3. what is cucumber?**

Used in Behavior Driven Development. BDD is a development approach that encourages collaboration between developers, and non-technical or business participants in a software project. Cucumber uses a language called Gherkin, which is designed to be readable and understandable by everyone on the project. 

**4. what is JMeter?**

Used in load and performance testing. Including HTTP and HTTPS, SOAP and REST, FTP etc.

1. **What is the lifecircle of Junit?** 
    
    **@BeforeAll**: Similar to @BeforeClass but with more flexibility. It doesn’t need to be static if the test class is annotated with @TestInstance(Lifecycle.PER_CLASS).
    
    **@BeforeEach**: Similar to @Before, this runs before each test method.
    
    **@Test**: Continues to mark methods that JUnit should treat as tests.
    
    **@AfterEach**: Like @After, it runs after each test method to clean up.
    
    **@AfterAll**: Similar to @AfterClass, but also more flexible in terms of instance lifecycle
    

**6. Is @BeforeAll method should be Class level(static)?** 

Yes, @BeforeAll should be called only once in the entire tests execution cycle, so it must be declared static.

**7. What is Mockito? and what is its limitations? what kind of tools can give help?** 

Mockito is a mocking framework which used in unit testing. The framework allows developers to isolate the unit work by replacing the dependencies with mock objects and specifying the behavior and expectations upfront.

**8. What is @Mock and what is @InjectMocks?** 

@Mock annotation is used to declare and create mock instances of dependencies within the test class.

@InjectMocks annotation is used to automatically inject mock fields into the tested object. 

**9. What is the stubbing (define behaviors)?**

Stubbing is the process of defining the behavior of mock objects. It involves setting up expectations on mocks—specifying what should happen when specific methods are called. 

**10. what is Mockito ArgumentMatchers**

ArgumentMatchers provide flexible conditions when specifying interactions in stubbing or verification. Instead of hard-coding specific arguments in method calls, ArgumentMatchers allow you to abstract away from the exact values and focus on the nature or type of the arguments.

**11. what is Hamcrest Matchers**

Hamcrest is a framework for writing matcher objects in Java, allowing for declarative style matching rules in tests, which can make the tests more readable and error messages more understandable. 

**12. do you know @spy? what is difference between @spy and @Mock?**

The @Spy annotation in Mockito is used to create a spy instance of a class. Spies are fundamentally different from mocks in that a spy represents a real object with all its normal behavior intact, but it also allows for selectively overriding some methods for testing purposes. 

The @Mock annotation creates a mock instance of the class. Unlike a spy, a mock does not retain any of the original class behavior. 

Use @Mock when you want to create a completely controlled environment where every operation is specified.

Opt for @Spy when you need to use the actual functionality of an object but override or verify specific behaviors.

**13. What is assertion?**

Assertion is a statement that checks whether a condition is true or false. 

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class AssertTest {
    @Test
    void addition() {
        assertEquals(5, 2 + 3, "Addition should work");
    }
}
```

**14. If you have developed a new feature, how many types of tests for this feature? and what kind of tests are written by you? what is the purpose of each type of tests?**

1. Unit tests:  validate each piece of the software 
2. Intergration tests: check how different modules or services work together. 
3. Functional tests: testing the feature to ensure it conforms to the specified requirements. 
4. System tests: System testing assesses the complete and fully integrated software product to evaluate the system’s compliance with its specified requirements.
5. Performance tests: Performance testing is done to ensure that the system performs adequately under significant loads.
6. Security Tests: Security testing uncovers vulnerabilities, threats, and risks in a software application and prevents malicious attacks from intruders.
7. User Acceptance Testing: UAT is conducted to ensure the system meets the needs and requirements of its users.