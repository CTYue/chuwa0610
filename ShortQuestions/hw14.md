## hw14

2. Briefly reading: https://www.techgeeknext.com/spring-boot/spring-aop-interview-questions 

3. What is the Aspect Oriented Programming, explain it with detailed use cases? 

   >*Aspect-oriented programming (AOP) is a programming technique that supports the separation of* **cross-cutting concerns** *in order to increase modularity.*

4. What are the advantages and disadvantages of Spring AOP? 

   >##### Advantages of Spring AOP
   >
   >1. It is easy to configure.
   >2. Spring AOP is implemented in pure Java, so separate compilation unit or separate class loader are not required.
   >3. It utilizes Spring's IOC container for dependency injection.
   >4. Can create aspects using `@AspectJ` annotation based or using XML based.
   >5. It integrates cross-cutting concerns into the classes,.
   >
   >##### Disadvantages of Spring AOP
   >
   >1. Debugging the AOP framework-based application code is a little challenge.
   >2. Only methods with a public visibility will be recommended, not those with a private, protected, or default visibility.
   >3. Aspects cannot be advised by other aspects. This is because once a class is marked as an aspect (using XML or annotation), Spring prevents it from being auto-proxied.

5. Explain following concept in your own words, you may include code snippet as part of your answer. 

   1. Aspect 

      >*An aspect is a* **cross-cutting module that combines advice and pointcuts**. A standard class tagged with the `@Aspect` annotation can be used to implement an aspect.

   2. PointCut 

      >*A pointcut is an* **expression** *that chooses one or more join points at which advice is given. Pointcuts can be defined using* **expressions or patterns**. It supports a number of expressions that correspond to the join points. 

   3. JoinPoint 

      >*A join point is a place in the application where an* **AOP aspect** is applied. It could also be a specific advice execution instance. A join point in AOP can be a method execution, exception handling, changing the value of an object variable, and so on

   4. Advice 

      >The advice is an action which we take before or after the method execution. In the Spring AOP framework, there are five types of advice: **before**, **after**, **after-returning**, **after-throwing**, and **around advice**. Advice is taken at a specific join point.

6. How do we declare a pointcut, can we declare it without annotating an empty method? Name some expressions to do it. 

   >```java
   >@Pointcut("execution(* com.example.service.*.*(..))")    
   >public void serviceLayerExecution(){}
   >```
   >
   >Yes, you can declare a pointcut in Spring AOP without having to annotate an empty method. While the empty method approach is a common practice for clarity and reusability of pointcut expressions, Spring AOP also allows inline pointcut expressions directly in the advice annotations. This means you can specify the pointcut expression directly where you define your advice, such as with `@Before`, `@After`, `@AfterReturning`, `@AfterThrowing`, or `@Around`.
   >
   >```java
   >@Aspect
   >@Component
   >public class LoggingAspect {
   >
   >    // Inline pointcut expression in Before advice
   >    @Before("execution(* com.example.service.*.*(..))")
   >    public void logBeforeServiceMethod(JoinPoint joinPoint) {
   >        System.out.println("Before executing method: " + joinPoint.getSignature().getName());
   >    }
   >}
   >```

7. Compare different types of advices in Spring AOP. 

   >| Type of Advice  | When it Executes                          | Common Use Cases                       |
   >| --------------- | ----------------------------------------- | -------------------------------------- |
   >| Before          | Before the method execution               | Validation, security, logging          |
   >| After Returning | After the method returns normally         | Data modification, logging             |
   >| After Throwing  | After the method throws an exception      | Exception handling, alerts, logging    |
   >| After (Finally) | After the method execution (like finally) | Resource cleanup, logging              |
   >| Around          | Around the method invocation              | Transactions, complex condition checks |

8. Reading: https://www.javainuse.com/spring/sprbatch_interview 

9. Spring WebFlux vs Stream API+CompletableFuture, why use Spring WebFlux over the other? 

   >1. **Model for Reactive Streams**: WebFlux offers a more comprehensive model for working with reactive streams that inherently supports backpressure, a mechanism that helps prevent overloading consumers in a data stream. This is essential in scenarios with fluctuating data flow rates.
   >2. **Framework-Level Support for Reactivity**: Spring WebFlux provides deep support for reactive programming across web servers, databases, and messaging systems, which can simplify the development of end-to-end reactive applications.
   >3. **Better Resource Efficiency**: WebFluxâ€™s non-blocking nature allows it to handle more requests with fewer threads, reducing the need for hardware resources as compared to traditional servlet-based models, which can be more resource-intensive when scaling up.
   >4. **Integrated Ecosystem**: For applications already using the Spring ecosystem, WebFlux integrates more naturally with other Spring projects (like Spring Data Reactive Repositories, Spring Security Reactive, etc.) than piecing together separate solutions with Stream API and `CompletableFuture`.
   >5. **Use Case Suitability**: If your application is heavily I/O-bound, involving many slow I/O operations or live data streams (like live sport scores, stock prices, etc.), WebFlux is designed to handle these use cases more efficiently.

10. When to use Spring Batch? please provide detailed exaples with business context. 

    >Consider an environment where users have to do a lot of batch processing. This will be quite different from a typical web application which has to work 24/7. But in classic environments it's not unusual to do the heavy lifting for example during the night when there are no regular users using your system. Batch processing includes typical tasks like reading and writing to files, transforming data, reading from or writing to databases, create reports, import and export data and things like that. Often these steps have to be chained together or you have to create more complex workflows where you have to define which job steps can be run in parallel or have to be run sequentially etc. That's where a framework like Spring Batch can be very handy. Spring Boot Batch provides reusable functions that are essential in processing large volumes of records, including logging/tracing, transaction management, job processing statistics, job restart, skip, and resource management. It also provides more advanced technical services and features that will enable extremely high-volume and high performance batch jobs though optimization and partitioning techniques.Simple as well as complex, high-volume batch jobs can leverage the framework in a highly scalable manner to process significant volumes of information.

11. How does Spring Batch work? you may include code snippet as part of your answer. 

    >- **step -** A Step that delegates to a Job to do its work. This is a great tool for managing dependencies between jobs, and also to modularise complex step logic into something that is testable in isolation. The job is executed with parameters that can be extracted from the step execution, hence this step can also be usefully used as the worker in a parallel or partitioned execution.
    >- **ItemReader -** Strategy interface for providing the data. Implementations are expected to be stateful and will be called multiple times for each batch, with each call to read() returning a different value and finally returning null when all input data is exhausted. Implementations need not be thread-safe and clients of a ItemReader need to be aware that this is the case. A richer interface (e.g. with a look ahead or peek) is not feasible because we need to support transactions in an asynchronous batch.
    >- **ItemProcessor -** Interface for item transformation. Given an item as input, this interface provides an extension point which allows for the application of business logic in an item oriented processing scenario. It should be noted that while it's possible to return a different type than the one provided, it's not strictly necessary. Furthermore, returning null indicates that the item should not be continued to be processed.
    >- **ItemStreamWriter -** Basic interface for generic output operations. Class implementing this interface will be responsible for serializing objects as necessary. Generally, it is responsibility of implementing class to decide which technology to use for mapping and how it should be configured. The write method is responsible for making sure that any internal buffers are flushed. If a transaction is active it will also usually be necessary to discard the output on a subsequent rollback. The resource to which the writer is sending data should normally be able to handle this itself.
    >
    >https://www.javainuse.com/spring/batchtaskchunk

12. How can we schedule a Spring Batch Job? 

    >Spring Batch can be scheduled using Cron Job.
    >
    >https://www.javainuse.com/spring/springbootbatchtaskscheduler

13. What is the cron expression? 

    >A cron expression is *a string consisting of six or seven subexpressions (fields) that describe individual details of* the schedule.

14. Explain Spring task? 

    >https://javabetter.cn/springboot/springtask.html

15. What is Filter and any filter example? 

    >https://segmentfault.com/a/1190000039996829

16. What is the Interceptor? What we can do with interceptor? 

    >https://segmentfault.com/a/1190000039996829

17. In Interceptor, What is preHandle? What is postHandle? 

    >The `preHandle` method is called before the actual handler (controller) is executed.
    >
    >The `postHandle` method is called after the handler method is executed but before the view is rendered.

18. What is Swagger, why do we need it? What does it do except "documentation"?

    >**Swagger** is a set of open-source tools built around the OpenAPI Specification that can help design, build, document, and consume RESTful web services. It provides a powerful interface for both developers and end-users, facilitating clear and effective communication about the capabilities of a service without requiring direct access to the source code.
    >
    >**Client SDK Generation**: Swagger tools can automatically generate client libraries (SDKs) in multiple programming languages, which can accelerate client-side development.
    >
    >**Design & Specification**: Before writing any code, you can use Swagger tools to design the API and define its expected behavior using the YAML or JSON formats. This helps in conceptualizing and refining the API specification.
    >
    >**Server Stub Generation**: From an API specification, Swagger can generate server stubs in various programming languages, which is a starting point for implementing the API logic.
    >
    >**Testing**: Swagger provides testing tools which can be used to perform integration tests on the APIs.