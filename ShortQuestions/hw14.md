# Chuwa Homework 14 MingHao(Howard) Lee 
## 1. List all of the annotations you learned from class and homework to annotaitons.md
`@Aspect` annotation can be used to implement an aspect.
Aspects are mostly used to enable cross-cutting concerns like logging, profiling, caching, and transaction management.

`@Configuration`
- Indicates a class is a source of bean definitions for the Spring IoC container.
- Used to define beans and configuration settings within a Java class.
- Often paired with `@Bean` annotated methods.

`@EnableAspectJAutoProxy`
- Enables support for handling components marked with AspectJ's `@Aspect` annotation.
- Tells Spring to automatically create proxies for beans annotated with Spring AOP annotations.
- Facilitates weaving of cross-cutting concerns like logging and transaction management.

### Creating Aspects with `@Aspect`

1. Define an Aspect:
   - Use the `@Aspect` annotation to mark a class as an aspect.
   - This class will contain methods that define cross-cutting concerns, such as logging or transaction management.

2. Register with Spring:
   - Use the `@Component` annotation to register the aspect class as a bean in the Spring container.
   - This allows Spring to manage the aspect and apply it to the appropriate join points (places in the code where the aspect should be applied).

### Key Steps:

- Annotate the class with `@Aspect` to define it as an aspect.
- Annotate the same class with `@Component` to ensure it is picked up by Spring's component scanning and managed as a Spring bean.

### Example Outline:

- Define an aspect class.
- Use advice annotations within the aspect class, such as `@Before`, `@After`, `@Around`, to specify when the cross-cutting concern should be executed in relation to the join point.

## 2. Briefly reading: [Spring AOP Interview Questions](https://www.techgeeknext.com/spring-boot/spring-aop-interview-questions)

## 3. What is the Aspect Oriented Programming, explain it with detailed use cases?
Aspect about AOP is a **cross-cutting module that combines advice and pointcuts**.
A standard class tagged with the `@Aspect` annotation can be used to implement an aspect.

Aspects are mostly used to enable cross-cutting concerns like logging, profiling, caching, and transaction management.


## 4. What are the advantages and disadvantages of Spring AOP?
### Advantages of Spring AOP
1. It is easy to configure.
2. Spring AOP is implemented in pure Java, so separate compilation unit or separate class loader are not required.
3. It utilizes Spring's IOC container for dependency injection.
4. Can create aspects using `@AspectJ` annotation based or using XML based.
5. It integrates cross-cutting concerns into the classes.

### Disadvantages of Spring AOP
1. Debugging the AOP framework-based application code is a little challenge.
2. Only methods with a public visibility will be recommended, not those with a private, protected, or default visibility.
3. Aspects cannot be advised by other aspects. This is because once a class is marked as an aspect (using XML or annotation), Spring prevents it from being auto-proxied.


## 5. Explain following concept in your own words, you may include code snippet as part of your answer.
### 1. Aspect 
#### Definition:
- An aspect is a module that encapsulates a concern that cuts across multiple classes or modules. It contains the code for cross-cutting concerns like logging, transaction management, or security.
```java
@Aspect
@Component
public class LoggingAspect {

    @Before("execution(* com.example.service.*.*(..))")
    public void logBefore(JoinPoint joinPoint) {
        System.out.println("Logging before method: " + joinPoint.getSignature().getName());
    }
}
```
### 2. PointCut 
#### Defination: 
- A pointcut defines a set of join points where an advice should be executed. It is a preficate that matches join points
  and determines whethe the advice should be applied.
```Java
@Aspect
@Component
public class LoggingAspect {

    @Pointcut("execution(* com.example.service.*.*(..))")
    public void serviceMethods() {
        // Pointcut expression matching all methods in the service package
    }

    @Before("serviceMethods()")
    public void logBefore(JoinPoint joinPoint) {
        System.out.println("Logging before method: " + joinPoint.getSignature().getName());
    }
}
```
### 3. JoinPoint 
#### Defination: 
- A join points is a pecific point in the execution of a program, such as the execution of a method or the handing of an exception.
  Join points are the points where an aspect can be applied.

```Java
  @Aspect
@Component
public class LoggingAspect {

    @Before("execution(* com.example.service.*.*(..))")
    public void logBefore(JoinPoint joinPoint) {
        System.out.println("Logging before method: " + joinPoint.getSignature().getName());
        // Additional information about the join point can be accessed here
    }
}
```
  
### 4. Advice
#### Defination: 
- Advice is the action taken by an aspect at a particular join point.
  Different types of advice include `@Before`, `@After`, `@Around`, `@AfterReturning`, and `@AfterThrowing`.
```Java
@Aspect
@Component
public class LoggingAspect {

    @Before("execution(* com.example.service.*.*(..))")
    public void logBefore(JoinPoint joinPoint) {
        System.out.println("Logging before method: " + joinPoint.getSignature().getName());
    }

    @After("execution(* com.example.service.*.*(..))")
    public void logAfter(JoinPoint joinPoint) {
        System.out.println("Logging after method: " + joinPoint.getSignature().getName());
    }

    @Around("execution(* com.example.service.*.*(..))")
    public Object logAround(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println("Logging around method: " + joinPoint.getSignature().getName());
        Object result = joinPoint.proceed();
        System.out.println("Logging around after method: " + joinPoint.getSignature().getName());
        return result;
    }
}
```
#### Summary:

- **Aspect**: Module encapsulating a cross-cutting concern.
- **PointCut**: Predicate that matches join points to apply advice.
- **JoinPoint**: Specific point in the execution of a program where advice can be applied.
- **Advice**: Action taken by an aspect at a particular join point, such as logging or security checks.

## 6. How do we declare a pointcut, can we declare it without annotating an empty method? Name some expressions to do it.
### Key Points:

- **Pointcut Declaration**: A pointcut can be declared using the `@Pointcut` annotation.
- **Empty Method**: Common practice is to annotate an empty method with `@Pointcut` to name and reuse the pointcut.
- **Direct Use**: Alternatively, pointcut expressions can be directly included in advice annotations without a separate method.

## Examples of Pointcut Expressions:

1. **Execution**:
   - Matches method execution.
   - `execution(* com.example.service.*.*(..))`

2. **Within**:
   - Matches join points within certain types.
   - `within(com.example.service..*)`

3. **This**:
   - Matches join points where the bean reference is an instance of the given type.
   - `this(com.example.service.ServiceInterface)`

4. **Target**:
   - Matches join points where the target object is an instance of the given type.
   - `target(com.example.service.ServiceInterface)`

5. **Args**:
   - Matches join points where the arguments are instances of the given types.
   - `args(java.lang.String, ..)`

## Example of Direct Use:

```java
@Before("execution(* com.example.service.*.*(..))")
public void logBefore(JoinPoint joinPoint) {
    System.out.println("Logging before method: " + joinPoint.getSignature().getName());
}

```


## 7. Compare different types of advices in Spring AOP.
### Types of Advices in Spring AOP

1. **Before Advice**:
   - Executes before the join point method.
   - Syntax: `@Before("pointcutExpression")`
   - Use case: Logging, security checks.

2. **After (Finally) Advice**:
   - Executes after the join point method completes, regardless of its outcome.
   - Syntax: `@After("pointcutExpression")`
   - Use case: Resource cleanup, logging.

3. **After Returning Advice**:
   - Executes after the join point method successfully completes.
   - Syntax: `@AfterReturning(pointcut="pointcutExpression", returning="returnValue")`
   - Use case: Post-processing of returned data.

4. **After Throwing Advice**:
   - Executes if the join point method exits by throwing an exception.
   - Syntax: `@AfterThrowing(pointcut="pointcutExpression", throwing="exception")`
   - Use case: Error handling, logging exceptions.

5. **Around Advice**:
   - Surrounds the join point method, allows to control method execution.
   - Syntax: `@Around("pointcutExpression")`
   - Use case: Performance monitoring, transaction management, modifying method execution.


## 8. Reading: [Spring Batch Interview](https://www.javainuse.com/spring/sprbatch_interview)

## 9. Spring WebFlux vs Stream API + CompletableFuture, why use Spring WebFlux over the other?

#### Spring WebFlux:
- **Reactive Programming**: Designed for reactive programming using the Reactor library.
- **Non-blocking I/O**: Handles multiple concurrent requests efficiently using non-blocking I/O.
- **Backpressure Support**: Manages backpressure, controlling the flow of data.
- **Scalability**: High scalability for handling large numbers of requests simultaneously.
- **Declarative API**: Provides a declarative API for building reactive applications.

#### Stream API + CompletableFuture:

- **Stream API**: Processes collections of data in a functional style.
- **CompletableFuture**: Handles asynchronous computations, offering non-blocking operations.
- **Combined Usage**: Useful for performing parallel operations on collections and chaining asynchronous tasks.
- **Limited Scalability**: Better suited for CPU-bound tasks rather than high-concurrency I/O-bound tasks.
- **Manual Backpressure**: Requires manual handling of backpressure and flow control.

### Why Use Spring WebFlux?

#### Key Points:

- **Reactive Framework**: Built specifically for reactive and asynchronous applications.
- **Efficiency**: Optimized for high concurrency with non-blocking I/O.
- **Ease of Use**: Provides built-in support for handling backpressure and flow control.
- **Scalability**: Superior for applications requiring high scalability and concurrent request handling.
- **Integrated**: Seamlessly integrates with the Spring ecosystem, offering a unified programming model.

Spring WebFlux is preferred for applications demanding high concurrency, scalability, and reactive programming capabilities, making it more suitable for modern, high-performance web applications compared to the traditional Stream API + CompletableFuture combination.


## 10. When to use Spring Batch? please provide detailed examples with business context.
### When to Use Spring Batch

#### Key Points:

- **Large Data Processing**: Efficiently processes large volumes of data.
- **Batch Jobs**: Executes jobs with multiple steps, including reading, processing, and writing data.
- **Scheduling**: Schedules and manages periodic or scheduled batch processing.
- **Transaction Management**: Ensures consistent state and handles transaction management and rollback.
- **Monitoring and Restart**: Provides robust monitoring, logging, and restart capabilities for batch jobs.

#### Detailed Examples with Business Context:

1. **Data Migration**:
   - **Scenario**: Migrating data from legacy systems to new databases.
   - **Business Context**: A bank needs to migrate customer data from an old system to a new one
   -                       while ensuring data integrity and consistency.

2. **Report Generation**:
   - **Scenario**: Generating periodic reports based on accumulated data.
   - **Business Context**: A retail company generates monthly sales reports by aggregating daily
   -                       transaction data to analyze sales trends and inventory requirements.

3. **ETL (Extract, Transform, Load)**:
   - **Scenario**: Extracting data from various sources, transforming it, and loading it into a data warehouse.
   - **Business Context**: A healthcare provider extracts patient data from multiple systems,
   -                       cleans and standardizes it, and loads it into a centralized data warehouse for analytics.

4. **Data Cleansing**:
   - **Scenario**: Cleaning and standardizing data before analysis.
   - **Business Context**: An e-commerce company processes customer data to remove duplicates,
   -                       correct errors, and standardize formats for better marketing analysis.

5. **Billing and Invoicing**:
   - **Scenario**: Generating monthly invoices for customers.
   - **Business Context**: A utility company processes usage data to generate accurate monthly invoices for its customers.

6. **File Processing**:
   - **Scenario**: Processing large files of data (e.g., CSV, XML).
   - **Business Context**: A logistics company processes shipment data files daily to update the
   -                       status of shipments and track delivery performance.

### Conclusion:
Spring Batch is ideal for applications requiring robust batch processing capabilities, 
handling large volumes of data efficiently, and providing features like transaction 
management, monitoring, and scheduling, making it a powerful tool for various business-critical operations.


## 11. How does Spring Batch work? you may include code snippet as part of your answer.

## 12. How can we schedule a Spring Batch Job?

## 13. What is the cron expression?

## 14. Explain Spring task?

## 15. What is Filter and any filter example?

## 16. What is the Interceptor? What we can do with interceptor?

## 17. In Interceptor, What is preHandle? What is postHandle?

## 18. What is Swagger, why do we need it? What does it do except "documentation"?
