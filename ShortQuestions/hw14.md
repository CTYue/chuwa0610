# HW14

## 1. List all of the annotations you learned from class and homework to annotaitons.md

- Please refer to annotations.md in ShortQuestions folder.

## 2. Briefly reading: https://www.techgeeknext.com/spring-boot/spring-aop-interview-questions

## 3. What is the Aspect Oriented Programming, explain it with detailed use cases?

- Aspect-Oriented Programming (AOP) is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns. It allows you to add behavior to existing code without modifying the code itself. AOP is often used for logging, security, transaction management, and more.

- Key Concepts
    - Aspect: A module that encapsulates a concern that cuts across multiple classes.
    - Join Point: A point in the program where an aspect can be applied (e.g., method execution).
    - Advice: Action taken by an aspect at a particular join point (e.g., before, after, around).
    - Pointcut: A set of join points where an advice should be applied.
    - Weaving: The process of applying aspects to a target object.

- Use Cases
### 1. Logging:
- Problem: Adding logging to multiple methods increases code clutter.
- Solution: Use AOP to create a logging aspect that automatically logs method calls and exits.
- Ex:
```java
@Aspect
public class LoggingAspect {
    @Before("execution(* com.example.service.*.*(..))")
    public void logBefore(JoinPoint joinPoint) {
        System.out.println("Method called: " + joinPoint.getSignature().getName());
    }
}
```

### 2. Security：
- Problem: Securing multiple methods requires adding security checks in each method.
- Solution: Use AOP to create a security aspect that checks permissions before method execution.
- Ex:
```java
@Aspect
public class SecurityAspect {
    @Before("execution(* com.example.service.*.*(..))")
    public void checkSecurity(JoinPoint joinPoint) throws Throwable {
        // Perform security check
        if (!userHasPermission()) {
            throw new SecurityException("Unauthorized access");
        }
    }
}
```

### 3. Transaction Management:
- Problem: Managing transactions manually can be error-prone and cumbersome.
- Solution: Use AOP to manage transactions declaratively.
- Ex:
```java
@Aspect
public class TransactionAspect {
    @Around("execution(* com.example.service.*.*(..))")
    public Object manageTransaction(ProceedingJoinPoint joinPoint) throws Throwable {
        // Start transaction
        Transaction tx = startTransaction();
        try {
            Object result = joinPoint.proceed();
            // Commit transaction
            tx.commit();
            return result;
        } catch (Throwable t) {
            // Rollback transaction
            tx.rollback();
            throw t;
        }
    }
}
```

## 4. What are the advantages and disadvantages of Spring AOP?

- Advantages of Spring AOP:
    - Modularity: Separates cross-cutting concerns (like logging, security) from business logic, leading to cleaner code.
    - Reusability: Aspects can be reused across multiple classes and projects.
    - Maintainability: Changes to cross-cutting concerns need to be made in one place only.
    - Declarative: Allows for declarative application of aspects via annotations or XML configuration.

- Disadvantages of Spring AOP:
    - Complexity: Understanding and debugging aspects can be difficult, especially for new developers.
    - Performance Overhead: Introduces a slight performance overhead due to aspect weaving.
    - Limited Scope: Spring AOP is proxy-based and works only with Spring-managed beans, not with internal method calls or static methods.
    - Potential for Overuse: Overuse of AOP can lead to code that is hard to understand and maintain.

## 5. Explain following concept in your own words, you may include code snippet as part of your answer
### 1. Aspect
- An Aspect is a module that encapsulates a concern that cuts across multiple classes. It typically contains pointcuts and advices that define where and what to apply.
```java
@Aspect
public class LoggingAspect {
    // Define pointcuts and advices here
}
```

### 2. PointCut
- A PointCut is an expression that matches join points. It defines where the advice should be applied.
```java
@Pointcut("execution(* com.example.service.*.*(..))")
public void serviceMethods() {}
```

### 3. JoinPoint
- A JoinPoint is a point during the execution of a program, such as the execution of a method or the handling of an exception, where an aspect can be applied.
```java
@Before("serviceMethods()")
public void logBefore(JoinPoint joinPoint) {
    System.out.println("Method called: " + joinPoint.getSignature().getName());
}
```

### 4. Advice
- Advice is the action taken by an aspect at a particular join point. Types of advice include before, after, around, etc.
```java
@Around("serviceMethods()")
public Object logAround(ProceedingJoinPoint joinPoint) throws Throwable {
    System.out.println("Method start: " + joinPoint.getSignature().getName());
    Object result = joinPoint.proceed();
    System.out.println("Method end: " + joinPoint.getSignature().getName());
    return result;
}
```

## 6. How do we declare a pointcut, can we declare it without annotating an empty method? Name some expressions to do it.

- You can declare a pointcut using the @Pointcut annotation. It is typically associated with an empty method, which serves as an identifier for the pointcut expression.
```java
@Pointcut("execution(* com.example.service.*.*(..))")
public void serviceMethods() {}
```
- Expressions for Pointcuts:
    - execution: Matches method execution.
    ```java
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void serviceMethods() {}
    ```

    - within: Matches all methods within specified types.
    ```java
    @Pointcut("within(com.example.service.*)")
    public void withinService() {}
    ```

    - this: Matches join points where the bean reference is an instance of the given type.
    ```java
    @Pointcut("this(com.example.service.MyService)")
    public void thisService() {}
    ```
- Declaring Pointcut Inline without Empty Method:
```java
@Before("execution(* com.example.service.*.*(..))")
public void logBefore(JoinPoint joinPoint) {
    System.out.println("Method called: " + joinPoint.getSignature().getName());
}
```

## 7. Compare different types of advices in Spring AOP.
- Before Advice
    - Description: Executes before the join point (e.g., method execution).
    - Use Case: Logging, security checks.
    - Ex:
    ```java
    @Before("execution(* com.example.service.*.*(..))")
    public void logBefore(JoinPoint joinPoint) {
        System.out.println("Before method: " + joinPoint.getSignature().getName());
    }
    ```

- After Returning Advice
    - Description: Executes after the join point completes normally.
    - Use Case: Post-processing, logging return values.
    - Ex:
    ```java
    @AfterReturning(pointcut = "execution(* com.example.service.*.*(..))", returning = "result")
    public void logAfterReturning(JoinPoint joinPoint, Object result) {
        System.out.println("Method returned: " + result);
    }
    ```

- After Throwing Advice
    - Description: Executes if the join point throws an exception.
    - Use Case: Exception handling, logging errors.
    - Ex:
    ```java
    @AfterThrowing(pointcut = "execution(* com.example.service.*.*(..))", throwing = "error")
    public void logAfterThrowing(JoinPoint joinPoint, Throwable error) {
        System.out.println("Exception: " + error);
    }
    ```

- After (Finally) Advice
    - Description: Executes after the join point, regardless of its outcome.
    - Use Case: Resource cleanup, final logging.
    - Ex:
    ```java
    @After("execution(* com.example.service.*.*(..))")
    public void logAfter(JoinPoint joinPoint) {
        System.out.println("After method: " + joinPoint.getSignature().getName());
    }
    ```

- Around Advice
    - Description: Surrounds the join point, allowing pre- and post-processing.
    - Use Case: Comprehensive logging, transaction management.
    - Ex:
    ```java
    @Around("execution(* com.example.service.*.*(..))")
    public Object logAround(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println("Before method: " + joinPoint.getSignature().getName());
        Object result = joinPoint.proceed();
        System.out.println("After method: " + joinPoint.getSignature().getName());
        return result;
    }
    ```
## 8. Reading: https://www.javainuse.com/spring/sprbatch_interview

## 9. Spring WebFlux vs Stream API+CompletableFuture, why use Spring WebFlux over the other?

- Spring WebFlux:
    - Asynchronous and Non-blocking: Designed for handling a large number of concurrent connections with a small number of threads.
    - Reactive Programming: Built on Project Reactor, supports reactive streams and backpressure.
    - Declarative Approach: Provides a higher-level, declarative way to define data pipelines and transformations.
    - Scalability: Suitable for applications that require high scalability and responsiveness.
    - Ecosystem Integration: Seamlessly integrates with other Spring modules and reactive libraries.

- Stream API + CompletableFuture:
    - Asynchronous Processing: Allows asynchronous computation and combining multiple async operations.
    - Java Standard Library: Utilizes standard Java libraries, no need for additional dependencies.
    - Imperative Style: More familiar to developers used to imperative programming.
    - Control over Concurrency: Fine-grained control over thread management and concurrency.

- Why Use Spring WebFlux Over Stream API + CompletableFuture?
    - Higher-Level Abstractions: WebFlux offers built-in support for reactive streams, backpressure, and declarative programming, simplifying complex asynchronous workflows.
    - Non-Blocking I/O: Optimized for non-blocking I/O operations, making it ideal for web applications with high concurrency.
    - Integration: Better integration with the Spring ecosystem and reactive libraries, providing a cohesive development experience.
    - Scalability: More efficient handling of high-throughput scenarios due to its reactive nature.

## 10. When to use Spring Batch? please provide detailed exaples with business context.

- When to Use Spring Batch
    - Spring Batch is ideal for processing large volumes of data in a consistent, reliable, and efficient manner. It supports features like transaction management, job processing statistics, and job restart capabilities.
- Business Contexts and Examples
### 1. ETL (Extract, Transform, Load) Processes:
- Example: A retail company needs to consolidate daily sales data from multiple stores into a central data warehouse.
- Solution: Use Spring Batch to read sales data from different databases (Extract), convert and normalize the data (Transform), and load it into the central warehouse (Load).
```java
@Configuration
public class ETLBatchConfig {
    @Bean
    public Job etlJob(JobBuilderFactory jobBuilderFactory, StepBuilderFactory stepBuilderFactory) {
        return jobBuilderFactory.get("etlJob")
            .start(etlStep(stepBuilderFactory))
            .build();
    }

    @Bean
    public Step etlStep(StepBuilderFactory stepBuilderFactory) {
        return stepBuilderFactory.get("etlStep")
            .<SalesData, ProcessedData>chunk(1000)
            .reader(salesDataReader())
            .processor(dataProcessor())
            .writer(dataWriter())
            .build();
    }

    // Define reader, processor, and writer beans here
}
```
### 2. Data Migration:
- Example: A bank needs to migrate customer data from an old system to a new system.
- Solution: Use Spring Batch to read data from the old system, transform it to fit the new system’s schema, and write it to the new system.
```java
@Configuration
public class DataMigrationBatchConfig {
    @Bean
    public Job dataMigrationJob(JobBuilderFactory jobBuilderFactory, StepBuilderFactory stepBuilderFactory) {
        return jobBuilderFactory.get("dataMigrationJob")
            .start(migrationStep(stepBuilderFactory))
            .build();
    }

    @Bean
    public Step migrationStep(StepBuilderFactory stepBuilderFactory) {
        return stepBuilderFactory.get("migrationStep")
            .<OldCustomer, NewCustomer>chunk(500)
            .reader(oldSystemReader())
            .processor(customerDataProcessor())
            .writer(newSystemWriter())
            .build();
    }

    // Define reader, processor, and writer beans here
}
```

## 11. How does Spring Batch work? you may include code snippet as part of your answer.
- Spring Batch provides a framework for writing batch processing jobs. The primary components are Job, Step, ItemReader, ItemProcessor, and ItemWriter.

- Key Components
    - Job: Represents the entire batch process. Contains multiple steps.
    - Step: Represents a single phase of the job. Can be a chunk-oriented step or a tasklet step.
    - ItemReader: Reads data.
    - ItemProcessor: Processes data.
    - ItemWriter: Writes data.

- Ex:
```java
@Configuration
@EnableBatchProcessing
public class BatchConfig {

    @Autowired
    private JobBuilderFactory jobBuilderFactory;

    @Autowired
    private StepBuilderFactory stepBuilderFactory;

    @Bean
    public Job exampleJob() {
        return jobBuilderFactory.get("exampleJob")
            .start(exampleStep())
            .build();
    }

    @Bean
    public Step exampleStep() {
        return stepBuilderFactory.get("exampleStep")
            .<String, String>chunk(10)
            .reader(itemReader())
            .processor(itemProcessor())
            .writer(itemWriter())
            .build();
    }

    @Bean
    public ItemReader<String> itemReader() {
        return new ListItemReader<>(Arrays.asList("item1", "item2", "item3"));
    }

    @Bean
    public ItemProcessor<String, String> itemProcessor() {
        return item -> item.toUpperCase();
    }

    @Bean
    public ItemWriter<String> itemWriter() {
        return items -> items.forEach(System.out::println);
    }
}
```
- Job Configuration:
    - The exampleJob is defined with a single step, exampleStep.
    - exampleStep processes items in chunks of 10.

- Reader:
    - itemReader reads items from a list.

- Processor:
- itemProcessor converts each item to uppercase.

- Writer:
- itemWriter writes items to the console.

## 12. How can we schedule a Spring Batch Job?

- We can schedule a Spring Batch job using Spring's @Scheduled annotation or by integrating with a scheduling framework like Quartz.
- Enable Scheduling: Add @EnableScheduling to your configuration class.
- Schedule the Job: Use @Scheduled on a method to trigger the job.
- Ex:
```java
@Configuration
@EnableBatchProcessing
@EnableScheduling
public class BatchSchedulerConfig {

    @Autowired
    private JobLauncher jobLauncher;

    @Autowired
    private Job exampleJob;

    @Bean
    public Job exampleJob(JobBuilderFactory jobBuilderFactory, StepBuilderFactory stepBuilderFactory) {
        return jobBuilderFactory.get("exampleJob")
            .start(exampleStep(stepBuilderFactory))
            .build();
    }

    @Bean
    public Step exampleStep(StepBuilderFactory stepBuilderFactory) {
        return stepBuilderFactory.get("exampleStep")
            .<String, String>chunk(10)
            .reader(itemReader())
            .processor(itemProcessor())
            .writer(itemWriter())
            .build();
    }

    @Scheduled(cron = "0 0 * * * ?") // Runs every hour
    public void runJob() throws Exception {
        JobParameters params = new JobParametersBuilder()
            .addString("JobID", String.valueOf(System.currentTimeMillis()))
            .toJobParameters();
        jobLauncher.run(exampleJob, params);
    }

    @Bean
    public ItemReader<String> itemReader() {
        return new ListItemReader<>(Arrays.asList("item1", "item2", "item3"));
    }

    @Bean
    public ItemProcessor<String, String> itemProcessor() {
        return item -> item.toUpperCase();
    }

    @Bean
    public ItemWriter<String> itemWriter() {
        return items -> items.forEach(System.out::println);
    }
}
```
- Using Quartz Scheduler
    - Add Dependencies: Include Quartz dependencies in your pom.xml.
    - Configure Quartz: Set up Quartz job and trigger.
    - Trigger Spring Batch Job: Implement a Quartz job to trigger the Spring Batch job.

## 13. What is the cron expression?

- A cron expression is a string representing a schedule for running tasks. It consists of six fields that define the timing:
```sql
┌───────────── second (0-59)
│ ┌───────────── minute (0-59)
│ │ ┌───────────── hour (0-23)
│ │ │ ┌───────────── day of month (1-31)
│ │ │ │ ┌───────────── month (1-12 or JAN-DEC)
│ │ │ │ │ ┌───────────── day of week (0-7 or SUN-SAT, 0 and 7 are Sunday)
│ │ │ │ │ │
* * * * * *
```

```java
@Scheduled(cron = "0 0 * * * ?") // Runs every hour at minute 0 and second 0
public void runJob() {
    // Job execution logic
}
```

## 14. Explain Spring task?
- A Spring Task refers to a scheduled task managed by Spring's task execution framework. It allows you to schedule methods to run at fixed intervals or specific times using annotations or XML configuration.
### 1. Annotation: Use @Scheduled to mark a method for scheduled execution.
```java
@Scheduled(fixedRate = 5000) // Runs every 5 seconds
public void myTask() {
    // Task logic
}
```
### 2. Configuration: Configure tasks in Spring-managed beans or XML files.

### 3. Types of Scheduling:
    - Fixed Rate: Executes at fixed intervals.
    - Fixed Delay: Waits a fixed period after the previous execution completes.
    - Cron Expression: Provides more complex scheduling patterns.

### 4. Execution Context: Tasks run within the Spring application context, leveraging Spring's dependency injection and transaction management.

## 15. What is Filter and any filter example?
- A Filter in programming generally refers to a mechanism that processes input and produces output based on certain criteria or transformations. In the context of web development, a filter intercepts requests and responses to perform pre-processing or post-processing tasks.
- Ex: In Java Servlets or Spring Web applications, you can define filters to perform tasks like logging, authentication, or modifying request parameters.
```java
import javax.servlet.*;
import java.io.IOException;

public class LoggingFilter implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        // Initialization code
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        // Perform pre-processing tasks
        System.out.println("Logging request: " + request.getRemoteAddr() + " " + request.getLocalAddr());

        // Pass request along the filter chain
        chain.doFilter(request, response);

        // Perform post-processing tasks
        System.out.println("Logging response status: " + response.getContentType());
    }

    @Override
    public void destroy() {
        // Cleanup code
    }
}
```
- Initialization (init): Initializes the filter.
- Filtering (doFilter): Processes requests and responses, optionally passing them to the next filter or servlet.
- Cleanup (destroy): Cleans up resources when the filter is destroyed.

## 16. What is the Interceptor? What we can do with interceptor?
- An Interceptor is a design pattern that allows code to be invoked before and after a method or request is executed. In the context of web applications, interceptors are commonly used to perform cross-cutting concerns such as logging, authentication, authorization, or modifying requests and responses

- What We Can Do with Interceptors:
    - Pre-processing and Post-processing: Execute code before and after the execution of a method or request.
    - Modify Behavior: Modify request parameters, headers, or response content dynamically.
    - Cross-cutting Concerns: Implement logging, security checks, performance monitoring, or caching.

## 17. In Interceptor, What is preHandle? What is postHandle?
- preHandle Method:
    - Purpose: Executes before the actual handler method (controller method) is invoked.
    - Use: Used for pre-processing tasks such as logging, authentication, or modifying the request.
    - Return Value: Returns true to continue with the handler execution or false to stop further execution.

- postHandle Method:
    - Purpose: Executes after the handler method (controller method) has been invoked but before the view is rendered.
    - Use: Used for post-processing tasks such as modifying the model and view, logging, or adding additional attributes to the ModelAndView object.
    - Parameters: Provides access to the ModelAndView object, allowing modifications before rendering the view.

## 18. What is Swagger, why do we need it? What does it do except "documentation"?
- Swagger is a set of open-source tools and specifications that help developers design, build, document, and consume RESTful web services. It includes tools like Swagger UI for interactive API documentation and Swagger Codegen for generating client libraries.

- Why Do We Need Swagger?
    - API Documentation: Provides interactive documentation for RESTful APIs, making it easier for developers to understand and consume APIs.

    - API Testing: Allows testing endpoints directly from the documentation interface, facilitating rapid development and debugging.

    - Client Generation: Generates client libraries in multiple languages from API definitions, reducing the effort required to consume APIs.

    - API Standardization: Enforces consistency in API design and usage across teams by using a standardized specification (OpenAPI).

- What does it do except "documentation"?
    - Mock Servers: Allows generating mock servers based on API specifications for testing purposes.
    - API Versioning: Supports versioning of APIs and maintains backward compatibility through clear documentation and definition.
    - Code Generation: Generates server-side code skeletons based on API definitions, speeding up backend development.

