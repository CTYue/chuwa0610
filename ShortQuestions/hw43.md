# HW11
1. List all the annotations you learned from class and homework to annotation.md  
   see annotation.md [here](annotation.md)
2. Compare Spring and Spring boot? What are the benefits of Springboot?  
    The reason why we need Spring Boot is we are changing or shifting towards applications like microservices and with microservices; one of the most important things aim is we would want to be able to develop applications very quickly. So instead of building one large application, we would like to build ten small microservices, which have their own scope and their own capabilities. Spring-based applications have lots of configurations. It can be of XML configuration, Java configuration or annotations, etc. For example, If we want to use Spring MVC, we need to use @ComponentScan annotation, Dispatcher servlet, view resolver, web jars, etc. This kind of configuration makes it slow to develop an application. So, in this place, Spring Boot Autoconfiguration comes in. It looks at what types of frameworks are available at the classpath and it looks at what configurations are provided by the programmers or what configurations are provided already for the application. It will look at both of them. Data is not configured but there is hibernation on the classpath, so it will configure the data source automatically. It will configure the in-memory database, it will configure the dispatcher servlet automatically. This is called autoconfiguration. Spring Boot creates a starter project by which all the XML configurations and dependencies get by default.

   | Spring                                                                                         | Springboot                                                                                          |
   |------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|
   | Spring is an open-source lightweight framework widely used to develop enterprise applications. | Spring Boot is built on top of the conventional spring framework, widely used to develop REST APIs. |
   | dependency injection                                                                           | Autoconfiguration                                                                                   |
   | To run the Spring application, a deployment descriptor is required.                            | There is no requirement for a deployment descriptor.                                                |
   | Developers have to define dependencies manually in the pom.xml file.                           | pom.xml file internally handles the required dependencies.                                          |
   | More code                                                                                      | Less Code                                                                                           |

3. What is IOC and What is DI?
   - **Inversion of Control**
      > Inversion of Control is a principle in software engineering which transfers the control of objects or portions of a program to a container or framework.
     - The advantages of this architecture are:
       - decoupling the execution of a task from its implementation
       - making it easier to switch between different implementations
       - greater modularity of a program
       - greater ease in testing a program by isolating a component or mocking its dependencies, and allowing components to communicate through contracts
      
   - **Dependency Injection**
      > Dependency injection is a pattern we can use to implement IoC, where the control being inverted is setting an object’s dependencies.
        Connecting objects with other objects, or “injecting” objects into other objects, is done by an assembler rather than by the objects themselves.
4. What is `@ComponentScan`?  
   see annotation.md [here](annotation.md#componentscan)
5. What is @SpringbootApplication?  
   see annotation.md [here](annotation.md#springbootapplication)
6. How many ways to define a bean? Provide code examples.
   - Class level
     [more](annotation.md#service)
    ```java
    @Component
    @Service
    @Repository
    @Controller
    @ContollerAdvice
    @ComponentScan
    ```
   - Method level
     [more](annotation.md#bean)
    ```java
    @Bean (used with @Configuration) together XML
    ```
   - XML
    ```java
    <bean id="dataNucleusChuwaNoComponent"
       class="com.chuwa.springbasic.components.impl.DataNucleusChuwaNoComponent"></bean>
    ```
   
7. What is the default bean name for `@Component` and `@Bean`? Also compare `@Component` and `@Bean`.

    |                       | `@Component`                                                     | `@Bean`                                                                                                         |
    |-----------------------|------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------|
    | Default Bean Name     | uncapitalized simple class name (`MyService`->`myService`)       | the method name itself                                                                                          |
    | Control               | Preferable for component scanning and automatic wiring.          | When want to wire components from 3rd-party libraries                                                           |
    | Method of Declaration | is used to annotate a class directly, making it a detected bean. | is used within a method in a @Configuration annotated class, allowing detailed configuration and initialization |
    | Intended Use          | simpler, self-contained class definitions                        | require more complex construction or setup                                                                      |
8. Compare `@Component` and `@Service`, `@Repository`, `@Controller`?
   - `@Component` is a generic stereotype for any Spring-managed component or bean.
   - `@Repository` is a stereotype for the persistence layer.
   - `@Service` is a stereotype for the service layer.
   - `@Controller` is a stereotype for the presentation layer (spring-MVC).

9. Explain `@Autowired`, `@Qualifier`, `@Resource` and `@Primary`?  
   see annotation.md [here](annotation.md)

10. How many annotations we can use to inject a bean?
    1. `@Autowired`: One of the most commonly used annotations, @Autowired, is part of the Spring framework. It can be used on constructors, setters, or fields to automatically inject the appropriate beans by type. If more than one bean of the same type exists, you can use @Qualifier to specify which bean to inject.
    2. `@Inject`: @Inject works similarly by injecting dependencies, but it is not part of the Spring-specific library. It doesn’t support some of the additional features of @Autowired, like the required attribute.
    3. `@Resource`: @Resource can be used to inject beans by name. It is not as flexible as @Autowired because it does not support the fine-grained control provided by Spring’s @Qualifier annotation, but it is useful when you need to specify a bean explicitly by its name.
    4. `@Value`: While not used for bean injection in the traditional sense, @Value is used to inject values into beans from property files or annotation parameters. This is often used for setting configuration values rather than injecting complex objects.
       ```java
       @Component
       public class MovieRecommender {
           @Value("${catalog.name}")
           private String catalogName;
       }
       ```
    
11. Explain and compare different types of dependency injection, their pros and cons, and use cases.

    |           | Constructor Injection                                                                                                                                                                                                                      | Setter Injection                                                                                                                                                                                                                                                                   | Field Injection                                                                                                                                             |
    |-----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------|
    | pros      | **Immutable Dependencies**, **Ease of Testing**, **Preferred by Spring**                                                                                                                                                                   | **Flexibility**: Allows for the object's dependencies to be set and modified after it has been constructed, offering more flexibility during runtime. **Avoids Circular Dependency Issues**: Useful in resolving circular dependencies without complex refactorings.               | Very easy to use and requires minimal boilerplate code. No need for constructors or setters.                                                                |
    | cons      | **Verbose**: Can result in large constructors if there are many dependencies, which can be cumbersome and hard to manage. **Circular Dependencies**: Can create problems when there are circular dependencies unless specifically handled. | **Possible Incomplete State**: An object can be in an incomplete state if the setters are not called, which can lead to bugs if not properly handled. **More Code to Maintain**                                                                                                    | Hidden Dependencies, Difficulty in Testing, Potential for Overwriting                                                                                       |
    | use cases | Constructor Injection is generally preferred for mandatory and stable dependencies.                                                                                                                                                        | Setter Injection is suited for optional and modifiable dependencies: Useful when an object needs to be created first before its dependencies can be resolved, or when dependencies need to change dynamically at runtime. Also beneficial when dealing with optional dependencies. | Suitable for simple use cases where ease of development is a priority, and the components are not expected to be used in a wide range of different contexts |
        
12. If we have multiple beans for one type, how to set one is primary? and how Spring IOC picks one bean to inject if no primary.
    - Using the `@Primary` annotation or the `@Qualifier` annotation to specify which bean should be injected.
    - If no bean is designated, Spring will typically throw a NoUniqueBeanDefinitionException indicating that more than one bean of the required type is defined, and it cannot make a decision on which one to inject. In some configurations, particularly with XML or when using custom BeanFactory or Autowired configurations, Spring might use other mechanisms (like the order of definition) to decide which bean to use, but this is less common and generally not reliable.
13. Compare BeanFactory and ApplicationContext in a Spring framework?

    | BeanFactory                                       | ApplicationContext                                                                            |
    |---------------------------------------------------|-----------------------------------------------------------------------------------------------|
    | loads beans on-demand                             | loads all beans at startup                                                                    |
    | only supports two scopes, Singleton and Prototype | enhances BeanFactory for enterprise applications and supports almost all types of bean scopes |
    The ApplicationContext comes with advanced features, including several that are geared towards enterprise applications, while the BeanFactory comes with only basic features. Therefore, it’s generally recommended to use the ApplicationContext, and we should use BeanFactory only when memory consumption is critical.
14. Explain bean scope in Spring IOC? List bean scopes with explanations and code examples if possible.
    1. **Singleton (Default Scope)**
       - Description: A single instance of the bean is created and shared across the entire container. This is the default scope if none is specified.
       - Use Case: Use this scope for stateless beans or when a single shared instance can manage the required state throughout the application lifecycle.
    2. **Prototype**
       - Description: A new instance of the bean is created every time it is requested from the container. This scope is useful for all operations that are unique to the particular instance and maintain state independently.
       - Use Case: Suitable for stateful beans where each consumer/request requires a new instance.
    3. **Request (Specific to web applications)**
       - Description: A bean is instantiated once per HTTP request. That is, each HTTP request has its own instance of a bean created.
       - Use Case: Appropriate for keeping data that is specific and exclusive to an HTTP request.
    4. **Session (Specific to web applications)**
       - Description: A bean is instantiated once per HTTP session. The bean is shared between requests in the same session.
       - Use Case: Suitable for data that needs to be consistent and maintained across multiple requests within the same user session.
    5. **Application (Specific to web applications)**
        - Description: A bean is instantiated once per ServletContext. Essentially, the bean is scoped to the lifecycle of a ServletContext.
        - Use Case: Useful for beans that need to be shared across all sessions in a web application.
    6. **WebSocket (Specific to web applications)**
       - Description: A bean is scoped to the lifecycle of a WebSocket session.
       - Use Case: Ideal for managing data within the scope of a WebSocket session  
       Code cases find in: [Quick Guide to Spring Bean Scopes](https://www.baeldung.com/spring-bean-scopes)
15. Configure a bean using xml. If bean has parameters/dependencies, how can we configure the bean?
    ```xml
    <!--   Here <constructor-arg ref="myDependency"/> tells Spring to inject the MyDependency bean into the constructor of MyBean.-->
        <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://www.springframework.org/schema/beans
                               http://www.springframework.org/schema/beans/spring-beans.xsd">
    
        <bean id="myDependency" class="com.example.MyDependency">
            <!-- Configuration for MyDependency if needed -->
        </bean>
    
        <bean id="myBean" class="com.example.MyBean">
            <constructor-arg ref="myDependency"/>
        </bean>
    </beans>
    ```
16. Do Q15 without xml, use Springboot IOC annotations instead.
```java
// Using Constructor injection
@Component
public class MyBean {
    private final MyDependency myDependency;

    @Autowired
    public MyBean(MyDependency myDependency) {
        this.myDependency = myDependency;
    }
}
```
```java
// Using @Bean
@Configuration
public class AppConfig {
    @Bean
    public MyBean myBean() {
        return new MyBean(myDependency());
    }

    @Bean
    public MyDependency myDependency() {
        return new MyDependency();
    }
}
```