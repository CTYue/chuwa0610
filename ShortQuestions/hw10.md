# HW10

1. **Compare Spring and Springboot? What are the benfits of Springboot?**
    
    Spring need to manually configure beans and other components using XML files in the beginning, then spring introduced Java-based configuration as an alternative to XML, which need to use @Configuration + @Bean define beans.
    
    Spring boot simplified it by auto-configuration by @SpringBootApplication. And Spring boot include an embedded server(such as Tomcat). 
    
2. **What is IOC and What is DI?**
    
    IOC: Inversion of control
    
    DI: dependency injection.
    
    In a non-IoC framework, the developer need to new instance by themselves, which is complex and it make code hard to change and update. For example, if the dependency changed, the code also need to change.  And you need to manually change the instantiation and configuration in various parts of the application.
    
    Spring use proxy pattern to solve this problem.  In Spring, objects are created and managed by Spring IoC container. Spring will read the configuration defined by developer, instead of application code create objects, Spring container creates object, and automatically injects the required dependencies into beans.  If the dependency updates, the changes will be centralized.
    
3. **What is @CompnonentScan ?**
    
    @ComponentScan allows Spring to find and register your components as beans in the ApplicationContext.
    
    ```java
    @Configuration
    @ComponentScan(basePackages = "com.example.myapp.services")
    public class AppConfig {
        // Configuration and bean definitions go here
    }
    ```
    
    In spring boot app, ComponentScan is automatically configured when you use SpringBootApplication.
    
4. **What is @SpringbootApplication ?**
    
    SpringBootApplication = Configuration + EnableAutoConfiguration + SpringBootApplication
    
    Spring boot will automatically scan all the package and sub package which has @Component, @Service, @Repository, @Controller, and register them into Spring Application context.
    
5. **How many ways to define a bean? Provide code examples.**
    1. Annotation based configuration
        
        Use annotations like @Component, @Service, @Repository, @Controller, These classes are automatically detected through classpath scanning, Spring will automatically instantiate this component.  
        
        ```java
        @Component
        public class MyBean {
            // Bean implementation
        }
        ```
        
    2. Java-based configuration
        
        Using @Configuration classes and @Bean annotations to register bean into Application context.
        
        ```java
        @Configuration
        public class AppConfig {
            @Bean
            public MyBean myBean() {
                return new MyBean();
            }
        }
        ```
        
    3. XML-based configuration
        
        Use XML configuration file to define beans.
        
        ```java
        <beans xmlns="http://www.springframework.org/schema/beans"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:schemaLocation="http://www.springframework.org/schema/beans
               http://www.springframework.org/schema/beans/spring-beans.xsd">
            <bean id="myBean" class="com.example.MyBean"/>
        </beans>
        ```
        
6. **What is default bean name for @Component and @Bean ? Also compare @Component and @Bean**
    
    Using Component annotation, the default name is Entity name. 
    
    eg:
    
    ```java
    @Component
    public class CustomerService {
        // Implementation
    }
    // The bean name will be CustomerService
    ```
    
    Using Bean annotation, the default name would be the method
    
    ```java
    @Configuration
    public class AppConfig {
        @Bean
        public MyBean myBean() {
            return new MyBean();
        }
    }
    // The bean name is myBean
    ```
    
    @Component is used to auto-detect and auto-configure beans using classpath scanning. Spring will auto-scanning components and directly instantiated it.
    
    @Bean is used within @Configuration classes to explicitly declare a single bean, Spring will manage the life cycle of the beans. The developer need to manually instantiate bean. @Bean gives more control over the bean instantiation process than @Component, it suitable for when you need to control the instantiation process or when you need to instantiate third-party classes.
    
7. **Compare @component and @service , @repository , @controller ?**
    
    Repository, Service, Controller are the specialization of Component annotation.
    
    Repository is used in persistence layer, which mostly corresponds to database access operations.
    
    Service used in service layer, which holds business logic, calls methods in the repository layer and process business function.
    Controller used in presentation layer, to mark a class as a web controller.
    
8. **Explain @Autowired , @Qualifier , @Resource and @Primary ?**
    
    @Autowired is used to automatically inject dependencies in Spring. It can be applied to fields, constructors, and methods.
    
    ```java
    @Component
    public class VehicleService {
        @Autowired
        private Engine engine;
    }
    ```
    
    When you have multiple beans of the same type and want to inject one specific bean, @Qualifier is used with @Autowired to specify which bean should be injected. 
    
    ```java
    @Component
    public class VehicleService {
        @Autowired
        @Qualifier("dieselEngine")
        private Engine engine;
    }
    ```
    
    @Resource is similar to @Autowired but is a part of the Java standard (JSR-250). 
    
    ```java
    @Component
    public class VehicleService {
        @Resource(name = "electricEngine")
        private Engine engine;
    }
    ```
    
    @Primary is used to designate a bean as the primary candidate when more than one bean of the same type qualifies for a single autowiring dependency. 
    
    ```java
    @Component
    @Primary
    public class DieselEngine implements Engine {
    }
    
    @Component
    public class ElectricEngine implements Engine {
    }
    
    @Component
    public class VehicleService {
        @Autowired
        private Engine engine;  // DieselEngine will be injected because it is marked @Primary
    }
    ```
    
9. **How many annotaitons we can use to inject a bean?**
    1. Constructor injection
        
        Do not need annotations unless there are multiple constructors.
        
        ```java
        @Component
        public class ExampleService {
            private final DependencyComponent dependency;
        
            // Constructor for dependency injection
            public ExampleService(DependencyComponent dependency) {
                this.dependency = dependency;
            }
        
            // Method that uses the dependency
            public void performAction() {
                dependency.action();
            }
        }
        
        // 多个构造器
        @Component
        public class ExampleService {
            private DependencyComponent dependency;
            private AnotherDependency anotherDependency;
        
            @Autowired
            public ExampleService(DependencyComponent dependency, AnotherDependency anotherDependency) {
                this.dependency = dependency;
                this.anotherDependency = anotherDependency;
            }
        
            public ExampleService(DependencyComponent dependency) {
                this.dependency = dependency;
            }
        
            // Method that uses the dependencies
            public void performAction() {
                dependency.action();
                anotherDependency.anotherAction();
            }
        }
        ```
        
    2. Autowired: This is the most common annotation used for automatic dependency injection in Spring, where injection is performed by type. It can be used on constructors, setters, or fields.
    
    And @Inject, @Resource, @Qualifier..
    
10. **Explain and compare differnet types of denpendency injection, their pros and cons, and use cases**
    1. Constructor injections: 
        
        pros: Once set, the dependencies cannot be changed, which leads to safer and cleaner code, Easier to create mock objects for unit testing as dependencies are passed through the constructor.
        
        Cons: Can lead to problems when two classes depend on each other.
        
    2. Setter injection:
        
        pros: Flexibility, Allows the object to be constructed with default settings and the dependencies to be set later.
        
        cons: Here is a risk of leaving an object partially initialized if the setters are not properly managed and Dependencies can be changed throughout the lifecycle of the object, which can lead to issues
        
    3. Field Injection: Dependencies are injected directly into the fields of a class, typically using annotations like @Autowired on private fields.
        
        pros: No need for constructors or setters, making the code cleaner and more concise.
        
        cons: Hard testing. It can be difficult to inject dependencies for testing because fields are typically private.
        
11. **If we have multiple beans for one type, how to set one is primary? and how Spring IOC picks one bean to inject if no primary**
    1. Use @Primary
        
        ```java
        @Component
        public class MySqlDatabase implements Database {
            // implementation details
        }
        
        @Component
        @Primary
        public class InMemoryDatabase implements Database {
            // implementation details
        }
        // it will inject InMemoryDatabase as default.
        
        // If need to use MySqlDatabase instead of default
        @Service
        public class DataProcessingService {
            private Database database;
        
            @Autowired
            public DataProcessingService(@Qualifier("mySqlDatabase") Database database) {
                this.database = database;  // 将注入 MySqlDatabase
            }
        }
        ```
        
    2. If no @Primary, use @Qualifier
        
        ```java
        @Autowired
        @Qualifier("specificBeanName")
        private MyBean myBean;
        
        // Get bean
        MyBean myBean = applicationContext.getBean("specificBeanName", MyBean.class);
        ```
        
    3. Bean Naming
        
        If there is no @Primary or @Qualifier used, Spring will use the bean name as a fallback. 
        
        ```java
        // Bean defined as:
        @Component("mySpecificBean")
        public class MySpecificBean implements MyBean {
        }
        
        // Autowired in another component:
        @Autowired
        private MyBean mySpecificBean; // Matches the bean name "mySpecificBean"
        ```
        
12. **Compare BeanFactory and ApplicationContext in Spring framework?**
    
    BeanFactory is the basic interface of Spring IOC, it used by Spring framework, developer can not access to it. 
    
    BeanFactory is the root factory of ApplicationContext, applicationContext provides additional capabilities such as easier integration with Spring AOP etc
    
13. **Explain bean scope in Spring IOC? List bean scopes with explainations and code examples if possible.**
    1. Singleton(default)
        
         Most common for stateless beans where the same instance can be used without interference between requests or users.
        
    2. Prototype
        
        ```java
        @Component
        @Scope("prototype")
        public class PrototypeService {
            // Service methods
        }
        ```
        
    
    Useful when each operation requires a unique instance, eg: user create name & user update name, if use singleton, one user create name, the other user can not create name, they can only update name.
    
14. **Configure a bean using xml. If bean has parameters/dependencies, how can we configure the bean?**

```java
//Example without dependencies:
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="simpleService" class="com.example.SimpleService"/>
</beans>

//Example with dependencies (setter injection):
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="simpleService" class="com.example.SimpleService"/>

    <bean id="complexService" class="com.example.ComplexService">
        <property name="simpleService" ref="simpleService"/>
        <property name="serviceName" value="MyComplexService"/>
    </bean>
</beans>

//Example with dependencies (constructor injection):
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="simpleService" class="com.example.SimpleService"/>

    <bean id="complexService" class="com.example.ComplexService">
        <constructor-arg ref="simpleService"/>
        <constructor-arg value="MyComplexService"/>
    </bean>
</beans>
```