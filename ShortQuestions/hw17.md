# Homework50 Microservice

### 2. Document the microservice architeture and components/tools/dependencies

**Microservice architecture** involves developing an application as a collection of small, independent services that communicate over a network. Each service handles a specific function and can be developed, deployed, and scaled independently.

- Independently deployable
- Loosely coupled

#### **Architecture Overview**

- **Microservices**: Independent services, each encapsulating a specific business function, with its own codebase and data store.
- **API Gateway**: A single entry point that handles routing, load balancing, authentication, and aggregation of responses from various microservices.
- **Service Registry**: A dynamic directory that keeps track of service instances and their locations, enabling service discovery.
- **Configuration Server**: Centralized management of configuration settings for all microservices.
- **Message Broker**: Facilitates asynchronous communication between services, supporting message queuing and event-driven interactions.
- **Database**: Each microservice typically manages its own database to maintain data consistency and encapsulation.

#### **Key Components and Tools**

- API gateway

  Acts as a proxy server to intercept traffic and route it to back-end services, which can help with manageability, control, and communication

  Nginx, Zuul

- Service discovery

  Helps with dynamism, location transparency, and mobility, which can be especially important as a system grows.

  Eureka, Consul, Zookeeper

- Configuration management

  Helps manage the configurations of centralized services, which can help maintain consistency and simplify management.

  Spring Cloud Config, Consul, Vault

- Load balancer

  Helps spread incoming traffic across multiple microservices, which can help with scalability and performance.

  Ribbon, Nginx, AWS Elastic Load Balancing (ELB)

- Resilience

  A design pattern that can help keep a service alive without failing, which is important for availability.

  Hystrix, Resilience4j

- Containers

  Can help make applications easier to scale and faster to develop, which can encourage innovation and faster time-to-market.

  Docker, Kubernetes, OpenShift

- Database per service

  Ensures loose coupling by giving each service its own database, which can allow the service to use the best database for its needs.

  MySQL, PostgreSQL, MongoDB

- Fault tolerance

  An essential trait for microservice architecture, as failures are likely to happen daily once a system reaches a certain number of integration points.

  Resilience4j, Chaos Monkey

- Service orchestration

  Helps integrate microservices and dictate when each one is invoked.

  Apache Kafka, Camunda, Kubernetes

#### **Dependencies**

- **Network**: Services communicate over HTTP, gRPC, or messaging protocols.
- **CI/CD**: Jenkins, GitLab CI/CD, CircleCI for continuous integration and deployment.
- **Container Orchestration**: Kubernetes for managing containerized services.
- **Version Control**: Git for source code management.

### 3. What are Resilience patterns? What is circuit breaker?

**Resilience patterns** are strategies to improve system reliability and handle failures gracefully. Key patterns include:

- **Circuit Breaker**: Prevents repeated calls to a failing service to avoid cascading failures and allows the service time to recover.
- **Retry**: Automatically retries a failed operation a few times before giving up.
- **Fallback**: Provides an alternative response when a service fails.
- **Timeout**: Sets a maximum duration for operations to prevent excessive waiting.
- **Rate Limiting**: Controls the number of requests to prevent overloading.
- **Bulkhead**: Isolates parts of the system to prevent failures from spreading.

**Circuit Breaker** is a pattern that:

- **Closed State**: Allows requests and monitors failures.
- **Open State**: Stops requests to a failing service and waits for recovery.
- **Half-Open State**: Tests a few requests to check if the service has recovered.

### 4. Read this article, then list the important questions, then write your answers.

1. **Difference between Monolithic, SOA and Microservices Architecture**

**Monolisthic:** 

The entire application is built as one cohesive unit. Components are tightly coupled.

**SOA, Service Oriented Architecture:**

It is a group of services interacting or communicating with each other. Uses an Enterprise Service Bus (ESB) for communication and coordination between services. Services are loosely coupled but can share data and communicate over a network.

**Microservice:**

It involves structuring an application in the form of a cluster of small, autonomous services modeled around a business domain. The functional modules can be deployed independently, are scalable, are aimed at achieving specific business goals, and communicate with each other over standard protocols. 

2. **Explain how independent microservices communicate with each other.** 

Communication between microservices can take place through: 

- HTTP/REST with JSON or binary protocol for request-response 
- Websockets for streaming.  
- A broker or server program that uses advanced routing algorithms.  

RabbitMQ, Nats, Kafka, etc., can be used as message brokers; each is built to handle a particular message semantic. You can also use Backend as a Service like Space Cloud to automate your entire backend. 

3. Explain spring cloud and spring boot.

**Spring Cloud**: In Microservices, the Spring cloud is a system that integrates with external systems. This is a short-lived framework designed to build applications quickly. It contributes significantly to microservice architecture due to its association with finite amounts of data processing.

**Spring Boot:** Spring Boot is an open-sourced, Java-based framework that provides its developers with a platform on which they can create stand-alone, production-grade Spring applications.

3. **Cohesion and Coupling:**

**Cohesion:**

refers to how closely related and focused the responsibilities of a single module or component are. High cohesion means that the component has a well-defined purpose, with all its parts working together towards a single objective. This leads to more maintainable and understandable code.

**Coupling:**

It refers to the degree of interdependence between different modules or components. Low coupling means that components are largely independent and changes in one component have minimal impact on others. This results in a more flexible and scalable system.

**High Cohesion** is desirable; it means that a component does one thing well.

**Low Coupling** is desirable; it means that components are not overly reliant on one another.

4. **What is Eureka, how does it work?**

**Eureka** is a service discovery tool from Netflix, part of the Spring Cloud ecosystem. It helps microservices discover and communicate with each other dynamically.

**Eureka Server**: Acts as a registry where all the microservices (clients) register themselves. It maintains a list of all available services and their instances.

**Eureka Client**: A component embedded in microservices that registers the service with the Eureka Server and provides heartbeats to indicate its availability.

**Discovery**: When a service needs to communicate with another service, it queries the Eureka Server for the service's location. The server returns the address of the service instance, enabling direct communication.

**Self-Preservation**: Eureka has a self-preservation mode to handle network partition issues, ensuring that services do not get wrongly marked as unavailable during transient failures.

5. **What is Domain Driven Design?**

DDD emphasizes understanding the business's needs and creating a shared language  between developers and business stakeholders to ensure the software effectively solves the right problems.

- Concentrate on the core domain and domain logic. 
- Analyze domain models to find complex designs. 
- Engage in regular collaboration with the domain experts to improve the application model and address emerging domain issues. 

6. **Oauth:**

OAuth (Open Authorization Protocol) enables users to authenticate themselves with third-party service providers. With this protocol, you can access client applications on HTTP for third-party providers such as GitHub, Facebook, etc. Using it, you can also share resources on one site with another site without requiring their credentials.

### 5. how to do load balance in microservice? Write along Summary by yourself.

**Identify Load Balancer Types**:

- **Hardware Load Balancers**: High performance but costly.
- **Software Load Balancers**: More flexible and scalable.

**Choose a Load Balancing Algorithm**:

- **Round Robin**: Distributes requests sequentially.
- **Least Connections**: Directs traffic to the server with the fewest active connections.
- **IP Hash**: Uses client IP to distribute requests.

**Implement Load Balancer**:

- Use tools like Nginx, HAProxy, or cloud-based solutions (e.g., AWS Elastic Load Balancing).

**Configure Health Checks**:

- Ensure that only healthy instances receive traffic.

**Scalability and Redundancy**:

- Enable auto-scaling to handle varying loads.
- Implement failover mechanisms for high availability.

**Monitor and Optimize**:

- Continuously monitor performance and optimize settings.

**Some of the commonly used algorithms:**

- **Least Connection Method:** directs traffic to the server with the fewest active connections. Most useful when there are a large number of persistent connections in the traffic unevenly distributed between the servers.
-  **Least Response Time Method:** directs traffic to the server with the fewest active connections, the fewest send requests and the lowest average response time.
- **Round Robin Method**: rotates servers by directing traffic to the first available server and then moves that server to the bottom of the queue. Most useful when servers are of equal specification, in a single geographic location and there are not many persistent connections.
- **IP Hash**: the IP address of the client determines which server receives the request.
- **The "Power of Two Choices"** - The algorithm decides which server will respond to each request by picking two random servers from the fleet and choosing the one with the fewest active connections. The whole purpose is to save the load balancer from the cost of having to check all servers, while still making a better choice than a purely random decision. By randomly picking a small number of entries among a list and then selecting the least loaded one, the probability of choosing an overloaded server decreases. This is especially true as the number of servers in the fleet grows and the distribution of selected servers widens. The system balances itself: The wider the distribution, the fairer the outcome.

### 6. How to do service discovery?

**Service discovery** is a method used in microservices architectures to enable services to find and communicate with each other dynamically. There are two main types of service discovery: client-side and server-side.

- **Client-Side Discovery**

In client-side discovery, the client is responsible for determining the network locations of available service instances. The client queries a service registry to get the available instances and then selects one based on some criteria.

**Steps:**

1. **Service Registration**: When a service starts, it registers its network location (IP address and port) with a service registry.
2. **Service Lookup**: When a client needs to call a service, it queries the service registry to get a list of available instances.
3. **Load Balancing**: The client selects one of the available service instances, often using a load-balancing algorithm.

**Tools**:

- **Eureka**: A REST-based service registry from Netflix.
- **Consul**: Provides service discovery, configuration, and health checking.
- **Zookeeper**: Manages configuration, synchronization, and naming in a distributed system.



- **Server-Side Discovery**

In server-side discovery, the client makes a request to a load balancer, which then queries the service registry and forwards the request to an available service instance.

**Steps:**

1. **Service Registration**: Similar to client-side discovery, services register their network locations with a service registry.
2. **Service Lookup**: The load balancer queries the service registry to get the available instances.
3. **Load Balancing**: The load balancer forwards the client request to one of the available service instances.

**Tools**:

- **AWS Elastic Load Balancer (ELB)**: Distributes incoming application traffic across multiple targets.
- **NGINX**: Can act as a load balancer and perform server-side service discovery.
- **Envoy**: A high-performance proxy that provides service discovery, load balancing, and more.

