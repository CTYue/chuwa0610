# HW17

## 1. List all of the new learned annotations to your annotations.md

- Please refer the annotations.md inside of the ShortQuestions folder.

## 2. Document the microservice architeture and components/tools/dependencies

- Microservice Architecture:
    - An architectural style that structures an application as a collection of loosely coupled services.
    - Key Features:
        - Single Responsibility: Each service focuses on a specific business function.
        - Independence: Services can be developed, deployed, and scaled independently.
        - Communication: Services communicate through lightweight protocols (e.g., HTTP, gRPC).

- Components and Tools:
    - Service Discovery:
        - Eureka: Netflix's service registry for tracking microservices.
        - Consul: Tool for discovering and configuring services.
    - API Gateway:
        - Zuul: Netflix's edge service for routing and filtering requests.
        - Spring Cloud Gateway: Modern, reactive gateway for microservices.
    - Configuration Management:
        - Spring Cloud Config: Centralized external configuration management for applications.
    - Load Balancing:
        - Ribbon: Client-side load balancer for distributing network traffic.
    - Monitoring and Logging:
        - Prometheus: Monitoring and alerting toolkit.
        - Grafana: Visualization tool for monitoring data.
        - ELK Stack: Elasticsearch, Logstash, and Kibana for log management and analysis.
    - Circuit Breaker:
        - Hystrix: Netflix's latency and fault tolerance library.
        - Resilience4j: Lightweight fault tolerance library.

- Dependencies:
    - Spring Boot: Framework for building microservices.
    - Spring Cloud: Tools for building common patterns in distributed systems (e.g., configuration management, service discovery).
    - Feign: Declarative HTTP client for making web service calls.

## 3. What are Resilience patterns? What is circuit breaker?

- Resilience Patterns: 
    - Bulkhead: Isolate services to prevent a failure in one from cascading to others.
    - Circuit Breaker: Temporarily blocks calls to a failing service to prevent overload.
    - Retry: Automatically retry a failed request a specified number of times.
    - Fallback: Provide a default response or alternative processing when a service fails.
    - Timeout: Set a maximum time to wait for a response from a service.

- Circuit Breaker:
    - Function: Prevents a system from repeatedly calling a failing service.
    - States:
        - Closed: Calls pass through; if failures exceed a threshold, switch to Open.
        - Open: Calls are blocked for a timeout period to allow recovery.
        - Half-Open: A few calls are allowed to test if the service has recovered.
        - Goal: Protect resources and improve system stability by isolating failures.

## 4. Read this article, then list the important questions, then write your answers https://www.interviewbit.com/microservices-interview-questions/#main-features-of-microservices.

### 1. What issues are generally solved by spring clouds?

- Complicated issues caused by distributed systems: This includes network issues, latency problems, bandwidth problems, and security issues. 

- Service Discovery issues: Service discovery allows processes and services to communicate and locate each other within a cluster. 

- Redundancy issues: Distributed systems can often have redundancy issues. 

- Load balancing issues: Optimize the distribution of workloads among multiple computing resources, including computer clusters, central processing units, and network links. 

- Reduces performance issues: Reduces performance issues caused by various operational overheads. 

### 2. Write main components of Microservices.

- Containers, Clustering, and Orchestration 

- IaC [Infrastructure as Code Conception] 

- Cloud Infrastructure 

- API Gateway 

- Enterprise Service Bus 

- Service Delivery 

### 3. What are the benefits and drawbacks of Microservices?

- Benefits:
    - Self-contained, and independent deployment module. 
    - Independently managed services.   
    - In order to improve performance, the demand service can be deployed on multiple servers.   
    - It is easier to test and has fewer dependencies.

- Drawbacks:
    - Due to the complexity of the architecture, testing and monitoring are more difficult.  
    - Lacks the proper corporate culture for it to work.   
    - Pre-planning is essential.  
    - Complex development.  
    - Requires a cultural shift.  

### 4. Explain spring cloud and spring boot.

- Spring Cloud: In Microservices, the Spring cloud is a system that integrates with external systems. This is a short-lived framework designed to build applications quickly. It contributes significantly to microservice architecture due to its association with finite amounts of data processing.

- Spring Boot: Spring Boot is an open-sourced, Java-based framework that provides its developers with a platform on which they can create stand-alone, production-grade Spring applications. In addition to reducing development time and increasing productivity, it is easily understood.  

### 5. Write main features of Microservices.

- Decoupling: Within a system, services are largely decoupled. The application as a whole can therefore be easily constructed, altered, and scalable

- Componentization: Microservices are viewed as independent components that can easily be exchanged or upgraded

- Business Capabilities: Microservices are relatively simple and only focus on one service

- Team autonomy: Each developer works independently of each other, allowing for a faster project timeline

- Continuous Delivery: Enables frequent software releases through systematic automation of software development, testing, and approval

- Responsibility: Microservices are not focused on applications as projects. Rather, they see applications as products they are responsible for

- Decentralized Governance: Choosing the right tool according to the job is the goal. Developers can choose the best tools to solve their problems

- Agility: Microservices facilitate agile development. It is possible to create new features quickly and discard them again at any time.

## 5. how to do load balance in microservice? Write a long Summary by yourself.
### 1. https://www.geeksforgeeks.org/load-balancer-system-design-interview-question/
### 2. https://www.fullstack.cafe/blog/load-balancing-interview-questions

- Load Balancing in Microservices: It is a critical component in microservice architecture, ensuring that incoming network traffic is distributed across multiple servers. This improves the system's responsiveness and availability by preventing any single server from becoming a bottleneck. Here's an in-depth look at load balancing in microservices, including its mechanisms, types, and considerations.

- Mechanisms of Load Balancing:
### 1. DNS Load Balancing:
- How it Works: Distributes requests to different IP addresses based on DNS resolution.
- Pros: Simple to set up.
- Cons: Limited control over traffic distribution, slower propagation of changes.

### 2. Client-Side Load Balancing:
- How it Works: The client gets a list of available servers from a service registry and distributes requests based on a load-balancing algorithm.
- Tools: Netflix Ribbon, Spring Cloud LoadBalancer.
- Pros: Fine-grained control over traffic, reduced dependency on external load balancers.
- Cons: Increased complexity in the client code.

### 3. Server-Side Load Balancing:
- How it Works: An intermediary load balancer distributes requests among multiple backend servers.
- Tools: HAProxy, NGINX, AWS Elastic Load Balancer.
- Pros: Centralized control, easier management and monitoring.
- Cons: Single point of failure if not properly configured.

### 4. Service Mesh:
- How it Works: Uses a dedicated infrastructure layer for handling service-to-service communication.
- Tools: Istio, Linkerd.
- Pros: Advanced traffic management, security features, and observability.
- Cons: Added complexity and overhead.

- Types of Load Balancing Algorithms:
### 1. Round Robin:
- Description: Distributes requests evenly across all servers in a cyclic manner.
- Use Case: Suitable for similar server capacities and low-complexity needs.

### 2. Least Connections:
- Description: Directs requests to the server with the fewest active connections.
- Use Case: Effective for environments with varying server loads.

### 3. IP Hash:
- Description: Distributes requests based on the hash of the client's IP address.
- Use Case: Useful for maintaining session persistence.

### 4. Weighted Round Robin:
- Description: Distributes requests based on server weights assigned according to their capacities.
- Use Case: Ideal for environments with servers of different capacities.

### 5. Random:
- Description: Distributes requests randomly among servers.
- Use Case: Simple scenarios with uniform server capacities.

- Considerations for Load Balancing: 
### 1. Scalability: Ensure the load balancing mechanism can handle increased traffic as the application scales.
### 2. Fault Tolerance: Implement health checks to detect and route around failed instances.
### 3. Latency and Throughput: Optimize for low latency and high throughput to enhance user experience.
### 4. Session Persistence: Maintain user sessions across requests using strategies like sticky sessions or IP hash.
### 5. Security: Secure communication between clients and servers, often using SSL/TLS.
### 6. Monitoring and Logging: Implement comprehensive monitoring and logging to track performance and troubleshoot issues.

- Example: Implementing Load Balancing with Spring Cloud
### 1. Client-Side with Ribbon:
```java
// Application.java
@SpringBootApplication
@EnableEurekaClient
@EnableFeignClients
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}

// FeignClient Configuration
@FeignClient(name = "microservice-name")
public interface MicroserviceClient {
    @GetMapping("/endpoint")
    ResponseEntity<String> getResponse();
}

// Application.yml
ribbon:
  eureka:
    enabled: true
  MaxAutoRetries: 3
  MaxAutoRetriesNextServer: 2
```

### 2. Server-side with Spring Cloud Gateway:
```java
// GatewayApplication.java
@SpringBootApplication
@EnableEurekaClient
public class GatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(GatewayApplication.class, args);
    }
}

// application.yml
spring:
  cloud:
    gateway:
      routes:
        - id: microservice-route
          uri: lb://microservice-name
          predicates:
            - Path=/microservice/**
```

- Load balancing in microservices is essential for distributing traffic, ensuring high availability, and maintaining optimal performance. By understanding and implementing various load balancing mechanisms and algorithms, and considering critical factors such as scalability, fault tolerance, and security, organizations can build robust and resilient microservice architectures

## 6. How to do service discovery?
- Mechanism by which microservices automatically locate and communicate with each other.

### 1. Client-Side Discovery:
- How it Works: Clients query a service registry to get the list of available service instances.
- Tools: Netflix Eureka, Consul.
- Pros: Direct control over the discovery process.
- Cons: Increased complexity in client-side code.

### 2. Server-Side Discovery:
- How it Works: A load balancer queries the service registry and routes client requests to the appropriate service instance.
- Tools: AWS Elastic Load Balancer, NGINX, HAProxy.
- Pros: Simplifies client code, centralizes the discovery process.
- Cons: Potential single point of failure if not properly managed.

- Steps for Implementing Service Discovery:
### 1. Register Services:
    - Services register themselves with a service registry upon startup.
    - Example (Spring Boot with Eureka):
```java
    @EnableEurekaClient
    @SpringBootApplication
    public class ServiceApplication {
        public static void main(String[] args) {
            SpringApplication.run(ServiceApplication.class, args);
        }
    }
```
### 2. Discover Services:
    - Services or clients query the registry to find other services.
    - Example (Spring Cloud with Feign):
```java
    @FeignClient(name = "service-name")
    public interface ServiceClient {
        @GetMapping("/endpoint")
        String getResponse();
    }
```

### 3. Health Checks:
    - Regularly check the health of registered services to keep the registry updated with live instances.

## 7. prepare your own answers for each questions https://www.interviewbit.com/kafka-interview-questions/# purpose-of-partitions-in-kafka

### 1. Purpose of Partitions in Kafka:
    - Partitions in Kafka provide a way to split the topic log into smaller segments. Each partition can be hosted on a separate server, allowing Kafka to scale horizontally and handle large volumes of data. Partitions enable parallel processing of data, improving throughput and performance by allowing multiple consumers to read from different partitions simultaneously. They also help in distributing the load across multiple brokers, providing fault tolerance and enabling Kafka to maintain a high level of availability and reliability.

### 2. Kafka Interview Questions for Freshers:
- What is Apache Kafka?
    - Apache Kafka is a distributed streaming platform designed for high-throughput, low-latency, and real-time data feeds. It is used for building real-time data pipelines and streaming applications. Kafka can handle large volumes of data in a fault-tolerant and scalable manner.

- What are the core components of Kafka?
    - The core components of Kafka are:
    - Producer: Sends records to Kafka topics.
    - Consumer: Reads records from Kafka topics.
    - Broker: Kafka server that stores and serves data.
    - Topic: A category or feed name to which records are stored and published.
    - Partition: A log of messages split into smaller parts within a topic.
    - ZooKeeper: Manages and coordinates Kafka brokers.

- Explain the concept of a Kafka topic.
    - A Kafka topic is a logical channel to which records are sent by producers and from which records are read by consumers. Topics are split into partitions, which enable Kafka to scale horizontally and handle large data streams efficiently.

- How does Kafka ensure fault tolerance?
    - Kafka ensures fault tolerance through data replication. Each partition of a topic is replicated across multiple brokers. If a broker fails, one of the replicas takes over, ensuring no data loss and continuous operation.

- What is ZooKeeper’s role in Kafka?
    - ZooKeeper is used in Kafka for managing and coordinating the Kafka brokers. It keeps track of the status of Kafka brokers, topics, and partitions, and helps in leader election for partitions.

### 3. Kafka Interview Questions for Experienced
- What are Kafka Streams?
    - Kafka Streams is a client library for building real-time, scalable, and fault-tolerant stream processing applications on top of Kafka. It allows processing data in a stream processing paradigm, providing capabilities such as event-time processing, stateful processing, and exactly-once semantics.

- Explain the concept of Kafka Connect.
    - Kafka Connect is a tool for connecting Kafka with external systems (databases, key-value stores, search indexes, etc.) using connectors. It provides scalable and fault-tolerant streaming data pipelines, allowing data to be pulled from or pushed to Kafka topics.

- What is a Kafka consumer group?
    - A Kafka consumer group is a group of consumers that work together to consume records from a Kafka topic. Each consumer in the group reads data from different partitions, allowing parallel data processing and ensuring that each record is processed only once

- How does Kafka handle message ordering?
    - Kafka guarantees message ordering within a partition. Records sent to a particular partition are stored in the order they are received, and consumers read them in the same order. However, there is no ordering guarantee across different partitions.

### 4. MCQ on Kafka

- What is a Kafka broker responsible for? 
    - Managing partitions

- Which of the following ensures high availability in Kafka?
    - Replication

- Kafka uses ______ for coordinating distributed applications.
    - ZooKeeper

- What is the default retention period for a Kafka topic?
    - 7 days

- Which of the following is not a core component of Kafka?
    - Connector