# HW17

## 1.  list all of the new annotations you learned to your annotations.md
See [annotations.md](annotations.md)
## 2.  Document the microservice architeture and components/tools/dependencies
### Microservice Integration Flow

- **Client requests** are routed through the **API Gateway** (Kong, NGINX), which ensures requests are authenticated and rate-limited.
- The **API Gateway** communicates with the appropriate services, using **Service Discovery** (Consul, Eureka) to locate service instances dynamically.
- Services fetch their configuration settings from a **Configuration Management** system (Spring Cloud Config, Consul) to ensure they are using the correct parameters.
- **Service Communication** (REST, gRPC, RabbitMQ, Kafka) facilitates data exchange between services, whether synchronously or asynchronously.
- **Data Storage** (PostgreSQL, MongoDB, MySQL) provides persistent storage solutions for services, allowing them to store and retrieve data reliably.
- Services log their activities to a centralized **Logging** system (ELK Stack, Fluentd) for unified monitoring and troubleshooting.
- **Monitoring** tools (Prometheus, Grafana) track service health and performance, providing alerts and dashboards for real-time insights.
- **Security** mechanisms (OAuth 2.0, JWT, Spring Security) ensure that only authorized users and services can access sensitive endpoints and data.
- Services are containerized using **Docker**, ensuring consistency across development, testing, and production environments.
- **Kubernetes** handles the orchestration of these containers, managing their deployment, scaling, and maintenance.
- **CI/CD pipelines** (Jenkins, GitHub Actions, GitLab CI) automate the process of building, testing, and deploying services, ensuring that updates are rolled out smoothly and efficiently.

### Components
1. **API Gateway**
    - **Tool**: Kong, NGINX
    - **Purpose**: Routes incoming client requests to the appropriate microservice, handles authentication and rate limiting to ensure secure and controlled access.

2. **Service Discovery**
    - **Tool**: Consul, Eureka
    - **Purpose**: Dynamically locates and manages service instances, allowing services to find and communicate with each other without hardcoding service addresses.

3. **Configuration Management**
    - **Tool**: Spring Cloud Config, Consul
    - **Purpose**: Provides centralized configuration management, enabling services to retrieve their configuration settings from a common source, which simplifies management and consistency.

4. **Service Communication**
    - **Tool**: REST, gRPC, RabbitMQ, Kafka
    - **Purpose**: Facilitates both synchronous (e.g., REST, gRPC) and asynchronous (e.g., RabbitMQ, Kafka) communication between services, ensuring reliable message exchange and decoupling services.

5. **Data Storage**
    - **Tool**: PostgreSQL, MongoDB, MySQL
    - **Purpose**: Stores persistent data for microservices, ensuring data durability and enabling services to retrieve and manage their data efficiently.

6. **Logging**
    - **Tool**: ELK Stack (Elasticsearch, Logstash, Kibana), Fluentd
    - **Purpose**: Collects and centralizes logs from all services, providing a unified view for debugging, monitoring, and auditing purposes.

7. **Monitoring**
    - **Tool**: Prometheus, Grafana
    - **Purpose**: Continuously monitors service health and performance, providing real-time metrics and alerting to detect and respond to issues promptly.

8. **Security**
    - **Tool**: OAuth 2.0, JWT, Spring Security
    - **Purpose**: Ensures secure communication and access control through authentication and authorization mechanisms, protecting services and data from unauthorized access.

9. **Containerization**
    - **Tool**: Docker
    - **Purpose**: Encapsulates services into containers, ensuring consistency across environments and simplifying deployment and scaling.

10. **Orchestration**
    - **Tool**: Kubernetes
    - **Purpose**: Manages containerized applications, automating deployment, scaling, and operations of application containers across clusters of hosts.

11. **Continuous Integration/Continuous Deployment (CI/CD)**
    - **Tool**: Jenkins, GitHub Actions, GitLab CI
    - **Purpose**: Automates the build, testing, and deployment processes, ensuring that code changes are consistently and reliably integrated and delivered to production environments.


### Dependencies

- **Spring Boot**: Base framework for microservices
- **Spring Cloud**: Tools for distributed systems
- **Hibernate**: ORM for data access
- **Feign**: Declarative REST client
## 3.  What are Resilience patterns? What is circuit breaker?
- What are Resilience patterns?
    - Resilience patterns are design strategies used in software architecture to ensure that applications remain functional and responsive under various failure conditions. These patterns help to handle faults gracefully, maintain availability, and recover quickly from errors.
- What is a circuit breaker?
    - A circuit breaker is a resilience pattern that prevents a system from repeatedly trying to execute an operation that's likely to fail. It monitors the success and failure of operations and, upon detecting a certain threshold of failures, opens the circuit to stop further attempts, allowing the system to recover or fallback to a different strategy.

## 4.  Read this article, then list the important questions, then write your answers
- 1.  https://www.interviewbit.com/microservices-interview-questions/#main-features-of-microservices
### Important Questions

1. **What is a Microservice?**
    - Microservices, also known as Microservices Architecture, is an SDLC approach where large applications are built as a collection of small functional modules.
    - They help in easy maintenance, faster development, and are beneficial for DevOps and Agile methodologies.
    - Applications are modeled as collections of services that are maintainable, testable, loosely coupled, independently deployable, designed around business capabilities, and managed by small teams.

2. **Name some famous companies that use Microservice architecture.**
    - Twitter
    - Netflix
    - Amazon

3. **Explain CDC (Consumer-Driven Contract).**
    - Ensures service communication compatibility by establishing an agreement (contract) between consumers and service providers regarding data exchange formats.
    - Used to develop microservices efficiently used by external systems.

4. **What issues are generally solved by Spring Cloud?**
    - Complicated issues caused by distributed systems: network, latency, bandwidth, and security issues.
    - Service discovery issues.
    - Redundancy issues.
    - Load balancing issues.
    - Reduces performance issues caused by operational overheads.

5. **Write the main components of Microservices.**
    - Containers, Clustering, and Orchestration
    - Infrastructure as Code (IaC)
    - Cloud Infrastructure
    - API Gateway
    - Enterprise Service Bus
    - Service Delivery

6. **What are the benefits and drawbacks of Microservices?**
    - **Benefits:**
        - Self-contained, independent deployment modules.
        - Independently managed services.
        - Improved performance and scalability.
        - Easier testing and fewer dependencies.
        - Simplicity in debugging and maintenance.
        - Better communication between developers and business users.
        - Smaller development teams.
    - **Drawbacks:**
        - Complex testing and monitoring.
        - Requires proper corporate culture.
        - Essential pre-planning.
        - Complex development and cultural shift.
        - More expensive than monoliths.
        - Security implications and network maintenance difficulty.

7. **Name three common tools mostly used for microservices.**
    - Wiremock
    - Docker
    - Hystrix

8. **Explain the working of Microservice Architecture.**
    - Clients: Different users send requests from various devices.
    - Identity Provider: Validate a user's or client's identity and issue security tokens.
    - API Gateway: Handles the requests from clients.
    - Static Content: Contains all of the system's content.
    - Management: Services are balanced on nodes and failures are identified.
    - Service Discovery: A guide to discovering the routes of communication between microservices.
    - Content Delivery Network: Includes distributed network of proxy servers and their data centers.
    - Remote Service: Provides remote access to data or information that resides on networked computers and devices.
9. **Write the difference between Monolithic, SOA, and Microservices Architecture.**
    - **Monolithic Architecture:** All components bundled together in one large system.
    - **SOA (Service-Oriented Architecture):** Group of interacting services.
    - **Microservices Architecture:** Small, autonomous services modeled around a business domain, independently deployable, and scalable.

10. **Explain Spring Cloud and Spring Boot.**
    - **Spring Cloud:** Integrates with external systems, designed for building applications quickly, associated with microservice architecture.
    - **Spring Boot:** Java-based framework for creating stand-alone, production-grade Spring applications, reduces development time and increases productivity.

11. **What is the role of Actuator in Spring Boot?**
    - Provides restful web services to access the current state of a production application.
    - Allows monitoring and managing application usage without additional coding or configuration.

12. **Explain how you can override the default properties of Spring Boot projects.**
    - By specifying properties in the `application.properties` file.
    - Example:
        - `spring.mvc.view.suffix: .jsp`
        - `spring.mvc.view.prefix: /WEB-INF/`

13. **Write the main features of Microservices.**
    - Decoupling, Componentization, Business Capabilities, Team Autonomy, Continuous Delivery, Responsibility, Decentralized Governance, Agility.

14. **What do you mean by Cohesion and Coupling?**
    - **Coupling:** Relationship between software modules; can be highly coupled, loosely coupled, or uncoupled. Loose coupling is preferred.
    - **Cohesion:** Relationship between parts of a module serving the same purpose. High cohesion enhances functionality.

15. **What do you mean by Bounded Context?**
    - A central pattern in Domain-Driven Design (DDD).
    - Breaks large models into manageable contexts and explicitly defines their relationships.
    - Promotes an object-oriented approach and ensures integrity and mutability of data models.

16. **Write the fundamental characteristics of Microservice Design.**
    - Based on business capabilities, product ownership, essential messaging frameworks, decentralized governance, decentralized data management, automated infrastructure, and designing for failure.

17. **What are the challenges of using Microservices?**
    - **Functional Challenges:** Heavy infrastructure setup, significant investment, excessive planning for operational overhead.
    - **Technical Challenges:** Interdependency of microservices, operations overhead, need for skilled professionals, complexity in automation, managing configurations, deployment, debugging, and testing.

18. **Explain PACT in Microservices.**
    - Open-source tool for testing interactions in isolation against contracts.
    - Supports multiple languages like Ruby, Java, Scala, .NET, JavaScript, Swift/Objective-C.

19. **Explain how independent microservices communicate with each other.**
    - Through HTTP/REST with JSON or binary protocol, Websockets, message brokers like RabbitMQ, Nats, Kafka, or using Backend as a Service like Space Cloud.

20. **What do you mean by client certificates?**
    - Digital certificates for client systems to authenticate requests to remote servers.
    - Provides strong assurance of requestor's identity in mutual authentication designs.
## 5.  how to do load balance in microservice? Write a long Summary by yourself.
- 1.  https://www.geeksforgeeks.org/load-balancer-system-design-interview-question/
- 2.  https://www.fullstack.cafe/blog/load-balancing-interview-questions
### Why Use a Load Balancer?

- **Distributes Traffic**: Spreads incoming requests across multiple servers.
- **Improves Performance**: Enhances response times and overall system efficiency.
- **Increases Availability**: Ensures high availability and reliability of applications.

### When to Use?

- **High Traffic Websites**: To manage heavy loads.
- **Redundancy Needs**: For failover and disaster recovery.
- **Scalability**: To handle varying traffic volumes.

### Pros of Using Load Balancer

- **Optimized Resource Utilization**: Maximizes server usage.
- **Fault Tolerance**: Minimizes downtime and service interruptions.
- **Scalability**: Easily scale up/down based on demand.

### If Not Used

- **Single Point of Failure**: Increases risk of downtime.
- **Inefficient Resource Use**: Servers may be under or over-utilized.
- **Poor Performance**: Slower response times during high traffic.
## 6.  How to do service discovery?

1. **Client-Side Discovery**:
    - Clients query a service registry to discover service instances and then load balance requests across available instances.
    - **Tools**: Eureka, Consul

2. **Server-Side Discovery**:
    - A load balancer queries the service registry and routes client requests to available service instances.
    - **Tools**: NGINX, HAProxy

3. **DNS-Based Discovery**:
    - Uses DNS to map service names to their respective IP addresses.
    - **Tools**: AWS Route 53, Consul

### Pros

- **Automated Updates**: Services are registered and deregistered dynamically.
- **Load Balancing**: Efficient distribution of requests.
- **Fault Tolerance**: Provides redundancy and failover capabilities.

### If Not Used

- **Manual Updates**: Increased complexity in maintaining service locations.
- **Single Point of Failure**: Higher risk of downtime and unavailability.
- **Scalability Issues**: Difficulty in handling dynamic scaling of services.
## 7.  prepare your own answers for each questions  https://www.interviewbit.com/kafka-interview-questions/#purpose-of-partitions-in-kafka
- 1.  Kafka Interview Questions for Freshers
### Important Questions

1. **What does it mean if a replica is not an In-Sync Replica for a long time?**
    - A replica that has been out of ISR (In-Sync Replica) for a long period of time indicates that the follower is unable to fetch data at the same rate as the leader.

2. **What are the traditional methods of message transfer? How is Kafka better than them?**
    - **Message Queuing:**
        - Uses a point-to-point technique.
        - Messages are consumed and removed from the queue.
        - Asynchronous messaging with potential delays due to network issues.
    - **Publisher-Subscriber Model:**
        - Publishers produce messages in multiple categories.
        - Subscribers consume messages from categories they are subscribed to.
        - Messages are only removed once all subscribers have consumed them.
    - **Kafka Advantages:**
        - **Scalable:** Partitions and streamlines data using clusters.
        - **Faster:** A single Kafka broker can handle thousands of clients.
        - **Durability and Fault-Tolerant:** Data is kept persistent and replicated across clusters.

3. **What are the major components of Kafka?**
    - **Topic:** Category or feed in which records are saved and published.
    - **Producer:** Source of data for one or more Kafka topics.
    - **Consumer:** Reads messages from subscribed topics.
    - **Broker:** Server that works as part of a Kafka cluster.
    - **ZooKeeper:** Maintains and coordinates the Kafka cluster.

4. **Explain the four core API architecture that Kafka uses.**
    - **Producer API:** Allows applications to publish records to Kafka topics.
    - **Consumer API:** Allows applications to subscribe to Kafka topics and process records.
    - **Streams API:** Enables stream processing of data in Kafka.
    - **Connect API:** Connects Kafka topics to applications, facilitating data movement.

5. **What do you mean by a Partition in Kafka?**
    - Kafka topics are separated into partitions, each containing records in a fixed order with unique offsets.
    - Partitions allow parallel data processing and replication for fault tolerance.

6. **What do you mean by ZooKeeper in Kafka and what are its uses?**
    - **ZooKeeper:** Naming registry for distributed applications, configuration, and synchronization service.
    - **Uses:**
        - Maintains Kafka cluster state.
        - Coordinates brokers and topics.
        - Notifies nodes of topology changes.
        - Facilitates leader elections and broker coordination.

7. **Can we use Kafka without ZooKeeper?**
    - As of version 2.8, Kafka can be used without ZooKeeper. However, the version is not yet production-ready and lacks some key features.

8. **Explain the concept of Leader and Follower in Kafka.**
    - Each partition has a leader server handling read and write requests.
    - Followers replicate the leader's data and take over if the leader fails.

9. **Why is Topic Replication important in Kafka? What do you mean by ISR in Kafka?**
    - **Topic Replication:** Ensures durability and high availability by maintaining copies of topics across brokers.
    - **ISR (In-Sync Replica):** Replicas that are up to date with the partition's leader.

10. **What do you understand about a consumer group in Kafka?**
    - A consumer group is a collection of consumers that work together to ingest data from the same topic(s).
    - Ensures load balancing and fault tolerance among consumers.

11. **What is the maximum size of a message that Kafka can receive?**
    - By default, the maximum size is 1MB, adjustable via broker settings. Kafka is designed to handle 1KB messages efficiently.

12. **What are some of the features of Kafka?**
    - High throughput and fault tolerance.
    - Built-in partitioning system.
    - Replication for data durability.
    - Handles large amounts of data.
    - Saves and replicates messages across clusters.
    - Collaborates with ZooKeeper for coordination.
    - Well supported by Apache Spark.

13. **How do you start a Kafka server?**
    - Ensure Java 8+ is installed.
    - Extract Kafka.
    - Run specific commands to start the Kafka server and related services in the correct order.

14. **What do you mean by geo-replication in Kafka?**
    - Geo-replication allows messages to be copied across multiple data centers or cloud regions.
    - Achieved using Kafka's MirrorMaker Tool for data backup and redundancy.

15. **What are some of the disadvantages of Kafka?**
    - Performance degrades with message tweaking.
    - Does not support wildcard topic selection.
    - Large messages reduce performance due to compression.
    - Lacks support for certain messaging paradigms.
    - Incomplete set of monitoring tools.

16. **Tell me about some real-world usages of Apache Kafka.**
    - **Message Broker:** Manages large amounts of similar messages.
    - **Monitor Operational Data:** Tracks metrics like security logs.
    - **Website Activity Tracking:** Ensures data transfer and receipt.
    - **Data Logging:** Replicates data for recovery.
    - **Stream Processing:** Handles and processes streaming data.

17. **What are the use cases of Kafka monitoring?**
    - Track system resource consumption.
    - Monitor threads and JVM usage.
    - Keep an eye on broker, controller, and replication statistics.
    - Identify performance bottlenecks and demanding applications.

18. **What do you mean by Kafka schema registry?**
    - Stores Avro schemas for producers and consumers.
    - Ensures schema compatibility between producers and consumers.
    - Allows easy serialization and de-serialization.

19. **What are the benefits of using clusters in Kafka?**
    - Maintains load balance.
    - Statelss brokers with Zookeeper coordination.
    - High throughput and performance.
    - Leader election for partitions ensures reliability.

20. **Describe partitioning key in Kafka.**
    - Messages (records) have a key and a value.
    - The key is used for partitioning.
    - Ensures order and consistency within a partition.
    - Important for events requiring sequential processing.

21. **What is the purpose of partitions in Kafka?**
    - Allows a single topic to be spread across multiple servers.
    - Enables parallel data processing.
    - Helps in distributing data load among brokers.
- 2.  Kafka Interview Questions for Experienced
      Here is a summary of the provided content:

1. **Use Cases Where Kafka is Not Suitable**:
    - Kafka is designed for handling large data volumes.
    - Not suitable for small message volumes.
    - Not ideal for ETL jobs.
    - Other tools like RabbitMQ are better for simple task queues.
    - Kafka is not suitable for long-term storage.

2. **Replication Tools in Kafka**:
    - **Preferred Replica Leader Election Tool**: Balances leaders across brokers.
    - **Topics Tool**: Manages Kafka topics.
    - **Tool to Reassign Partitions**: Changes replica assignments.
    - **StateChangeLogMerger Tool**: Troubleshoots state change issues.
    - **Change Topic Configuration Tool**: Manages topic configurations.

3. **Differences Between RabbitMQ and Kafka**:
    - **Architecture**:
        - RabbitMQ: General-purpose message broker with synchronous/asynchronous communication.
        - Kafka: High-volume, durable, scalable message and stream platform.
    - **Message Handling**:
        - RabbitMQ: No message ordering, messages deleted after consumption.
        - Kafka: Supports message ordering, messages retained for a period.
    - **Approach**:
        - RabbitMQ: Push-based model with low latency.
        - Kafka: Pull-based model with higher throughput.
    - **Performance**:
        - RabbitMQ: Handles high messages per second with more resources.
        - Kafka: High throughput with limited resources, suited for large data use cases.

4. **Optimizing Kafka Performance**:
    - **Kafka Producer Tuning**: Adjust batch size and linger time for latency and throughput.
    - **Kafka Broker Tuning**: Balance leaders across nodes.
    - **Kafka Consumers Tuning**: Ensure consumers keep up with producers by matching partitions to consumers.

5. **Differences Between Redis and Kafka**:
    - **Message Delivery**:
        - Redis: Push-based, no message retention, faster.
        - Kafka: Pull-based, supports message retention, handles large data volumes.
    - **Data Handling**:
        - Redis: In-memory, fast.
        - Kafka: Disk-based, slower but scalable.

6. **Kafka Security**:
    - **Encryption**: Messages are encrypted between broker and clients.
    - **Authentication**: Only authenticated applications can connect to Kafka.
    - **Authorization**: Controls write access to prevent data contamination.

7. **Differences Between Kafka and Java Messaging Service (JMS)**:
    - **Message Delivery**:
        - JMS: Push-based, messages deleted after acknowledgment.
        - Kafka: Pull-based, messages retained for a time.
    - **Suitability**:
        - JMS: Suited for complex multi-node clusters.
        - Kafka: Handles large data volumes with ordered partitions.

8. **Kafka MirrorMaker**:
    - Tool for copying data from one Kafka cluster to another with the same topic name.

9. **Differences Between Kafka and Flume**:
    - **Functionality**:
        - Kafka: Distributed data system for real-time streaming.
        - Flume: Collects, aggregates, and moves log data efficiently.
    - **Model**:
        - Kafka: Pull-based.
        - Flume: Push-based.

10. **Confluent Kafka**:
    - A comprehensive Apache Kafka distribution with enhanced integration, management, and security tools. Available in open-source, enterprise, and cloud versions.

11. **Kafka Message Compression**:
    - Reduces message size to save disk space, increase throughput, and lower latency. Adds CPU overhead for compression/decompression.

12. **Kafka Multi-Tenancy**:
    - Supports multiple topics for data consumption and production on the same cluster, allowing logical isolation.

13. **Log Compaction and Quotas in Kafka**:
    - **Log Compaction**: Keeps the last known value for each message key for state restoration.
    - **Quotas**: Limits the byte-rate for producers and fetch requests to prevent resource monopolization.

14. **Kafka Guarantees**:
    - Messages are ordered as published, fault tolerance up to n-1 servers, and "at least one" delivery semantics per partition.

15. **Unbalanced Kafka Cluster**:
    - Issues like leader skew and broker skew can lead to unbalanced clusters. Solutions include using auto.leader.rebalance.enable and partition reassignment tools.

16. **Expanding a Kafka Cluster**:
    - New servers need unique broker ids. Use the partition reassignment tool to migrate data to new servers.

17. **Graceful Shutdown in Kafka**:
    - Ensures logs are synced to disk and partitions are reassigned before shutdown to minimize downtime.

18. **Changing Partitions in Kafka**:
    - Partitions can be expanded using the alter command but cannot be reduced.

19. **BufferExhaustedException and OutOfMemoryException in Kafka**:
    - **BufferExhaustedException**: Thrown when producer buffer is full.
    - **OutOfMemoryException**: Occurs when message queue fills up due to large messages or message spikes.

20. **Changing Kafka Retention Time at Runtime**:
    - Use kafka-topics.sh or kafka-configs.sh to alter retention time for topics.

21. **Differences Between Kafka Streams and Spark Streaming**:
    - **Fault Tolerance**:
        - Kafka: Partitions and replicas.
        - Spark: Cache and RDD.
    - **Task Handling**:
        - Kafka: Real-time streams.
        - Spark: Real-time and batch tasks.

22. **Znodes in Kafka Zookeeper**:
    - **Persistence Znode**: Continues to function after the client disconnects.
    - **Ephemeral Znode**: Exists only while the client is alive.
    - **Sequential Znode**: Appends an increasing counter to the path’s end.
- 3.  MCQ on Kafka
      Here are the multiple-choice questions based on the previous content:

1.
Which of the following should be started before starting the Kafka server?

- **Zookeeper**

2.
Which of the following is the correct command to create a new topic in Kafka?

- **kafka-topics.sh**

3.
You have demonstrated that a five-node Kafka cluster can process ten million messages per minute. It is conceivable that your input will climb to twenty-five million messages each minute. How many extra nodes should the cluster have?

- **8**

4.
The data alteration is reduced when messages transit from producer to broker to consumer by using which of the following techniques:

- **Binary Message Format**

5.
Data replication can help to enhance fault tolerance. Which of the following is a replication disadvantage?

- **States of inconsistency**

6.
Temporary znodes are often called as which of the following:

- **Ephemeral Nodes**

7.
There are 20 nodes in a Kafka cluster. There are five different topics, each with six partitions. How many broker processes will be active in total?

- **There are 20 processes, one for each node.**

8.
Which of the following commands is used to start the Kafka broker?

- **kafka-server-start.sh**

9.
Which of the following commands is used to add messages to a topic in Kafka?

- **kafka-console-producer.sh**

10.
Which of the following features of znode is used for leader election?

- **Sequential feature**

11.
Which of the following is a consumer-side API that is used to retrieve the messages as a stream?

- **consumerMap.get()**

12.
The replication model in Kafka is based on which of the following methods:

- **Primary backup method**

13.
The replication factor for a Kafka topic is set to 5. Two of the cluster’s nodes have failed. Users in the business world are concerned about losing messages. So, what do you say to them? Select the correct option.

- **They can continue to send messages since there is a four-server fault tolerance.**