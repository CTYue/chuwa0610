2.  what is selenium?
Selenium is a suite of open-source tools for automating web browser interactions. It allows you to record and playback actions in a browser, as well as directly control the browser programmatically. Selenium is widely used for web application testing.
3.  what is cucumber?
Cucumber is a Behavior-Driven Development (BDD) framework that focuses on writing test cases from a business perspective using plain text. It allows you to define how a feature should behave in a user-friendly way, along with steps for automated testing.
4.  what is JMeter?
JMeter is a load testing tool used to measure the performance of applications under load. It can simulate multiple users concurrently accessing an application to identify bottlenecks and analyze performance behavior.
5.  What is the lifecircle of Junit?
@BeforeClass (static): Executes once before any tests in the class are run. Often used for one-time setup like database connections.
@Before (non-static): Executes before each test method in the class. Used for test-specific setup like creating test objects.
Test Method: The actual test code that verifies the behavior of the unit under test.
@After (non-static): Executes after each test method. Used for test-specific cleanup like closing connections or deleting temporary data.
@AfterClass (static): Executes once after all tests in the class have run. Used for one-time cleanup like closing database connections.
6.  Is @BeforeAll method should be Class level(static)?
@BeforeAll must be static because it's executed before any test instances are created. It's suitable for one-time setup that applies to all tests in the class.
7.  What is Mockito? and what is its limitations?  what kind of tools can give help?
Mockito is a mocking framework for unit testing in Java. It allows you to create mock objects that simulate the behavior of real dependencies, enabling you to isolate your test unit and focus on its functionality.
Limitations of Mockito:
Mockito mocks cannot capture static methods or final classes.
Mocks don't handle multithreading well by default.
Alternatives:
PowerMock for mocking static methods and final classes.
JMockit for advanced mocking features.
8.  What is @Mock and what is @InjectMocks?
@Mock creates a mock object with no predefined behavior. You configure its behavior using Mockito methods like when(), thenReturn(), etc.
@InjectMocks injects mocks created with @Mock into the class being tested. It simplifies injecting dependencies without manual wiring.
9.  What is the stubbing (define behaviors)?
Stubbing refers to defining the behavior of a mock object using methods like when(), thenReturn(), thenThrow(), etc. You control how the mock object responds to calls from your test unit.
10.  what is Mockito ArgumentMatchers
Mockito ArgumentMatchers provide a set of utility classes to help you match method arguments in stubbing. They allow for flexible matching patterns, such as anyInt(), eq("value"), etc.
11.  what is Hamcrest Matchers
Hamcrest is a matcher library that provides more expressive ways to write assertions in your tests. It allows you to create custom matchers for complex logic in assertions.
12.  do you know @spy? what is difference between @spy and @Mock?
@Spy creates a partial mock object. It allows you to mock specific methods while keeping the real behavior of other methods. Use it when you want to observe interactions with real methods or have complex object hierarchies.
@Mock: Completely mocks the object, providing full control over its behavior. No real methods are called by default.
@Spy: Partially mocks the object. Real methods are called unless explicitly stubbed.
13.  What is assertion?
In testing, an assertion is a statement that verifies the expected outcome of your test. Assertions typically use comparison operators (e.g., assertEquals, assertTrue) to check if the actual result matches what you expect.
14.  If you have developed a new feature, how many types of tests for this feature? and what kind of tests are written by you? what is the purpose of each type of tests?
Unit Tests: Focus on testing individual units of code (e.g., methods, classes). They are isolated and verify the functionality of the unit in different scenarios.
Integration Tests: Test how multiple units interact with each other. They ensure proper communication and data flow between components.
End-to-End Tests (E2E Tests): Simulate user interactions and test the entire application flow. They provide a higher-level view of functionality.
