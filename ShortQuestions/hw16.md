# HW16

## 1. List all of the new learned annotations to your annotations.md

- Please Refer the annotations.md inside of the ShortQuestions folder.

## 2. What is selenium?

- Selenium is a tool for automating web browsers. It allows you to write scripts in various programming languages to control browser actions, making it useful for testing web applications and web scraping.

## 3. What is cucumber?

- Cucumber is a testing tool that supports Behavior-Driven Development (BDD). It allows you to write tests in a natural language that non-programmers can read, using a format called Gherkin. This makes it easier to collaborate on test scenarios with all stakeholders.

## 4. What is JMeter?

- JMeter is an open-source tool used for performance testing and load testing of web applications and other services. It simulates multiple users accessing a service to measure its performance under different conditions.

## 5. What is the lifecircle of Junit?

- @BeforeClass: Runs once before all tests in the class.
- @Before: Runs before each test method.
- @Test: The test method.
- @After: Runs after each test method.
- @AfterClass: Runs once after all tests in the class.

## 6. Is @BeforeAll method should be Class level(static)?

- Yes, the @BeforeAll method in JUnit 5 should be static because it runs once before all tests in the class, and JUnit needs to call it without creating an instance of the test class. That's why it should be class level(static).

## 7. What is Mockito? and what is its limitations? what kind of tools can give help?

- Mockito is a Java framework for creating mock objects in unit tests. It allows you to simulate the behavior of complex objects and define their responses to specific interactions.

- Limitations: 
    - Cannot mock static methods (Mockito 1.x).
    - Cannot mock constructors.
    - Limited support for final classes and methods (Mockito 1.x).
    - Cannot verify the behavior of private methods directly.

- Tools that can give help:
    - PowerMock: Extends Mockito to mock static methods, constructors, and private methods.
    - EasyMock: Another framework for creating mock objects, sometimes preferred for its different API and features.

## 8. What is @Mock and what is @InjectMocks?

- @Mock: Used to create and inject mock objects in Mockito. It marks a field as a mock, which Mockito will initialize.

- @InjectMocks: Used to inject mock objects (created with @Mock) into the class under test. Mockito will try to inject mocks into the tested class using constructor injection, setter injection, or field injection.

## 9. What is the stubbing (define behaviors)?

- Stubbing in Mockito refers to defining the behavior of a mock object for specific method calls. It specifies what the mock should return or do when certain methods are invoked.

- Ex:
```java
when(mockObject.method()).thenReturn(value);
```

## 10. What is Mockito ArgumentMatchers?

- Mockito ArgumentMatchers are used to specify flexible criteria for method arguments when defining stubs or verifying interactions. They allow you to match arguments more generically rather than specifying exact values.

- Ex:
```java
when(mockObject.method(anyString())).thenReturn(value);
verify(mockObject).method(eq("expectedValue"));
```

- Common matchers include: any(), anyString(), eq(value)

## 11. What is Hamcrest Matchers?

- Hamcrest Matchers are a set of matchers used for writing readable and flexible assertions in tests. They allow you to describe expected conditions in a human-readable way, improving test clarity.

- Ex:
```java
assertThat(actual, is(equalTo(expected)));
assertThat(list, hasItem(item));
```

- Common matchers include: is(), equalTo(), hasItem(), containsString()

## 12. Do you know @spy? what is difference between @spy and @Mock?

- @Spy is used to create a spy object in Mockito, which wraps an existing object and allows you to partially mock it.

- Difference ebetween @Spy and @Mock:
    - @Spy: Partially mocks an existing object, allowing you to override specific methods while keeping the original behavior of others.
    - @Mock: Creates a completely mock object with no real behavior, which you can fully control and define.

- Ex:
```java
@Spy
MyClass spyObject = new MyClass(); // Partially mocks MyClass

@Mock
MyClass mockObject; // Fully mocks MyClass
```

## 13. What is assertion?

- An assertion is a statement in a test that checks if a condition is true. If the condition fails, the test fails. Assertions are used to verify that the code behaves as expected.

- Ex:
```java
assertEquals(expected, actual);
```

## 14. If you have developed a new feature, how many types of tests for this feature? and what kind of tests are written by you? what is the purpose of each type of tests?

- Unit Tests: Test individual components or methods in isolation. Purpose: Verify the correctness of specific code units.

- Integration Tests: Test interactions between components or with external systems. Purpose: Ensure that different parts of the system work together correctly.

- Functional Tests: Test the feature's functionality from an end-user perspective. Purpose: Validate that the feature meets the specified requirements.

- Acceptance Tests: Validate that the feature meets business requirements and user needs. Purpose: Ensure the feature is ready for production based on user stories or acceptance criteria.

## 15. Add unit test for CommentServiceImpl, the coverage should be 100%.

## 16. Write Integration tests for PostController. The tests should cover all scenarios.