# HW16
## 1.  List all of the new learned annotations to your annotations.md
See [annotations.md](annotations.md)
## 2.  what is selenium?
- A tool used for automating web browsers, as user-behavior simulation
- Also widely used for testing web applications to ensure they function correctly across different browsers and platforms.

## 3.  what is cucumber?
- A testing tool that supports Behavior-Driven Development (BDD) and Test-Driven Development (BDD) .
- Use Given, When Then as behavior keyword in .feature file
```gherkin
Feature: Example feature

Scenario: Example scenario
Given I open the browser
When I navigate to "https://www.example.com"
Then I should see the title "Example Domain"

```
- Giving the definitions in class using annotations
```java
public class StepDefinitions {
    WebDriver driver;

    @Given("I open the browser")
    public void iOpenTheBrowser() {
        System.setProperty("webdriver.chrome.driver", "/path/to/chromedriver");
        driver = new ChromeDriver();
    }

    @When("I navigate to {string}")
    public void iNavigateTo(String url) {
        driver.get(url);
    }

    @Then("I should see the title {string}")
    public void iShouldSeeTheTitle(String title) {
        assertEquals(title, driver.getTitle());
        driver.quit();
    }
}

```
- Run test also using annotations
```java
@RunWith(Cucumber.class)
@CucumberOptions(features = "src/test/resources/features")
public class RunCucumberTest {
}

```
## 4.  what is JMeter?
- It is a tool for performance testing and load testing of web applications
- It can simulate multiple users accessing a web service concurrently to evaluate its performance under high load conditions.
- It helps in measuring the performance of a web application by simulating a heavy load on a server, group of servers, network, or object to test its strength or analyze overall performance under different load types.
- It supports distributed testing, which means you can use multiple machines to create a large load on a server or application.
- It provides detailed and customizable reports, including graphical analysis of performance test results.
## 5.  What is the lifecircle of Junit?
JUnit is a popular testing framework for Java that is used to write and run repeatable automated tests. It is widely used for unit testing of Java applications. The life cycle of a JUnit test case typically involves the following phases:

### JUnit Test Life Cycle

1. **Initialization**: This phase involves setting up the test environment. This is done using methods annotated with `@BeforeAll` and `@BeforeEach`.

2. **Execution**: This is the main phase where the actual test methods are executed. The test methods are annotated with `@Test`.

3. **Teardown**: This phase involves cleaning up the test environment. This is done using methods annotated with `@AfterEach` and `@AfterAll`.

### Example 
```java
public class ExampleTest {

    @BeforeAll
    public static void initAll() {
        System.out.println("BeforeAll - Executed once before all test methods");
    }

    @BeforeEach
    public void init() {
        System.out.println("BeforeEach - Executed before each test method");
    }

    @Test
    public void testMethod1() {
        System.out.println("Test - testMethod1");
    }

    @Test
    public void testMethod2() {
        System.out.println("Test - testMethod2");
    }

    @AfterEach
    public void tearDown() {
        System.out.println("AfterEach - Executed after each test method");
    }

    @AfterAll
    public static void tearDownAll() {
        System.out.println("AfterAll - Executed once after all test methods");
    }
}
```

### Output
```
BeforeAll - Executed once before all test methods
BeforeEach - Executed before each test method
Test - testMethod1
AfterEach - Executed after each test method
BeforeEach - Executed before each test method
Test - testMethod2
AfterEach - Executed after each test method
AfterAll - Executed once after all test methods
```

## 6.  Is @BeforeAll method should be Class level(static)?
@BeforeAll method should be a class-level static method. This is because @BeforeAll is intended to be executed once before any of the test methods in the class. Making it static ensures that it runs before any instance of the test class is created, allowing it to set up resources that are shared across all test instances.
## 7.  What is Mockito? and what is its limitations?  what kind of tools can give help?
- It is a testing framework for Java that allows developers to create and use mock objects in unit tests.
- Mockito allows you to create mock objects for interfaces and classes, you can specify the behavior of methods on mock objects.
- Mockito provides methods to verify that specific interactions with mock objects occurred.
- Mockito supports partial mocking of real objects using spies.
- Supports annotations like @Mock, @Spy, @InjectMocks, and @Captor to simplify the setup of tests.
### Limitations
- Mockito cannot mock final classes and methods by default.
- Mockito cannot mock static methods directly
- Mockito cannot mock private methods.
- When dealing with complex dependency trees, setting up mocks and injects can become cumbersome.
## 8.  What is @Mock and what is @InjectMocks?
### @Mock
- Creates a mock object of the annotated class
```java
@RunWith(MockitoJUnitRunner.class) 
class StudentTest { 

	@Mock
	Pen pen;
	@Test
	public void writeWithPenTest() throws Exception { 
		Mockito.when(pen.getRedPen()).thenReturn("Red Pen");
	} 

}

```
### @InjectMocks
- Creates and instance of the class and mocks that created using @Mock
- Doesn't even need to initialize the class
```java
// student need a pen
class Student { 

	private Pen pen; 

	public Student(Pen pen) { 
		this.pen = pen; 
	} 

	public String write() { 
		return "Student Write with: " + pen.getRedPen(); 
	} 

}

// then
@RunWith(MockitoJUnitRunner.class)
class StudentTest {

    @Mock
    Pen pen;

    @InjectMocks
    Student student;

    @Test
    public void writeWithPenTest() throws Exception {
        Mockito.when(pen.getRedPen()).thenReturn("Red Pen");
        assertEquals("Student Write with: Red Pen", student.write());
    }

}

```
## 9.  What is the stubbing (define behaviors)?
- Stubbing allows you to define the behavior of methods on mock objects.
- You can specify return values, throw exceptions, chain multiple behaviors, use argument matchers, and provide custom answers.
- Stubbing is essential for isolating the system under test and ensuring that tests focus on its behavior without relying on actual dependencies.
## 10.  what is Mockito ArgumentMatchers
- They are utility methods provided by the Mockito framework to specify flexible argument matching rules when stubbing methods or verifying interactions. Instead of matching exact argument values.
- `ArgumentMatchers` allow you to define more general conditions for the arguments passed to a method.

Here are some commonly used `ArgumentMatchers`:

1. **`any()`**: Matches any argument of the specified type.
   ```java
   Mockito.when(mockedObject.someMethod(ArgumentMatchers.any())).thenReturn(someValue);
   ```

2. **`any(Class<T> type)`**: Matches any argument of the specified class type.
   ```java
   Mockito.when(mockedObject.someMethod(ArgumentMatchers.any(String.class))).thenReturn(someValue);
   ```

3. **`eq(T value)`**: Matches an argument that equals the specified value.
   ```java
   Mockito.when(mockedObject.someMethod(ArgumentMatchers.eq("specificValue"))).thenReturn(someValue);
   ```

4. **`isA(Class<T> type)`**: Matches an argument that is an instance of the specified class.
   ```java
   Mockito.when(mockedObject.someMethod(ArgumentMatchers.isA(String.class))).thenReturn(someValue);
   ```

5. **`notNull()`**: Matches any non-null argument.
   ```java
   Mockito.when(mockedObject.someMethod(ArgumentMatchers.notNull())).thenReturn(someValue);
   ```

6. **`isNull()`**: Matches a null argument.
   ```java
   Mockito.when(mockedObject.someMethod(ArgumentMatchers.isNull())).thenReturn(someValue);
   ```

7. **`anyInt()`, `anyString()`, `anyBoolean()`, etc.**: Matches any argument of the specific primitive type or class.
   ```java
   Mockito.when(mockedObject.someMethod(ArgumentMatchers.anyInt())).thenReturn(someValue);
   ```

8. **`contains(String substring)`**: Matches a string argument that contains the specified substring.
   ```java
   Mockito.when(mockedObject.someMethod(ArgumentMatchers.contains("substring"))).thenReturn(someValue);
   ```

## 11.  what is Hamcrest Matchers
- Hamcrest is a framework for writing matcher objects, which allow you to create flexible and readable assertions in tests.
- Hamcrest matchers are used primarily in unit testing to match objects against specific conditions. 
- They are often used with testing frameworks like JUnit.

Here are some commonly used Hamcrest matchers:

1. **`equalTo(T value)`**: Checks if the actual value is equal to the given value.
   ```java
   assertThat(actualValue, equalTo(expectedValue));
   ```

2. **`is(T value)`**: A wrapper around `equalTo` for readability.
   ```java
   assertThat(actualValue, is(expectedValue));
   ```

3. **`not(T value)`**: Checks if the actual value is not equal to the given value.
   ```java
   assertThat(actualValue, not(expectedValue));
   ```

4. **`nullValue()`**: Checks if the actual value is null.
   ```java
   assertThat(actualValue, nullValue());
   ```

5. **`notNullValue()`**: Checks if the actual value is not null.
   ```java
   assertThat(actualValue, notNullValue());
   ```

6. **`instanceOf(Class<?> type)`**: Checks if the actual value is an instance of the given class.
   ```java
   assertThat(actualValue, instanceOf(ExpectedClass.class));
   ```

7. **`containsString(String substring)`**: Checks if the actual string contains the given substring.
   ```java
   assertThat(actualString, containsString("substring"));
   ```

8. **`startsWith(String prefix)`**: Checks if the actual string starts with the given prefix.
   ```java
   assertThat(actualString, startsWith("prefix"));
   ```

9. **`endsWith(String suffix)`**: Checks if the actual string ends with the given suffix.
   ```java
   assertThat(actualString, endsWith("suffix"));
   ```

10. **`hasItems(T... items)`**: Checks if a collection contains the given items.
    ```java
    assertThat(actualCollection, hasItems(item1, item2));
    ```

11. **`greaterThan(T value)`**: Checks if the actual value is greater than the given value.
    ```java
    assertThat(actualValue, greaterThan(expectedValue));
    ```

12. **`lessThan(T value)`**: Checks if the actual value is less than the given value.
    ```java
    assertThat(actualValue, lessThan(expectedValue));
    ```

- **`allOf(Matcher... matchers)`**: Checks if all matchers are satisfied.
  ```java
  assertThat(actualValue, allOf(greaterThan(minValue), lessThan(maxValue)));
  ```

- **`anyOf(Matcher... matchers)`**: Checks if any matcher is satisfied.
  ```java
  assertThat(actualValue, anyOf(is(value1), is(value2)));
  ```

## 12.  do you know @spy? what is difference between @spy and @Mock?
### `@Mock`
- `@Mock` is used to create a mock object. A mock object is a simulated object that mimics the behavior of real objects in controlled ways. Mocks are used to isolate the class under test by simulating its dependencies.
-  By default, all methods of a mock return either null, zero, or false, depending on the return type. You can specify the behavior of the mock's methods using `Mockito.when()`.

```java
@RunWith(MockitoJUnitRunner.class)
public class SomeTest {

    @Mock
    private List<String> mockedList;

    @Test
    public void testMock() {
        Mockito.when(mockedList.get(0)).thenReturn("Mocked Element");

        assertEquals("Mocked Element", mockedList.get(0));
        assertNull(mockedList.get(1)); // by default, other methods return null
    }
}
```

### `@Spy`
- `@Spy` is used to create a spy object. A spy object is a real instance of a class, but its methods can be stubbed. This means you can call real methods on the spy object while still having the ability to override specific methods.
- By default, all methods of a spy call the real methods unless they are stubbed. This allows for partial mocking, where you can mock specific methods and let others behave as normal.

```java
@RunWith(MockitoJUnitRunner.class)
public class SomeTest {

    @Spy
    private List<String> spiedList = new ArrayList<>();

    @Test
    public void testSpy() {
        spiedList.add("Real Element");
        Mockito.doReturn("Spied Element").when(spiedList).get(0);

        assertEquals("Spied Element", spiedList.get(0)); // stubbed method
        assertEquals(1, spiedList.size()); // real method
    }
}
```

## 13.  What is assertion?
- It is used to verify that certain conditions hold true at specific points in the code.
- It is used in test co check results matches expected behavior
- JUnit:
  - assertEquals(expected, actual): Checks if two values are equal.
  - assertTrue(condition): Checks if a condition is true.
  - assertFalse(condition): Checks if a condition is false.
  - assertNull(object): Checks if an object is null.
  - assertNotNull(object): Checks if an object is not null.
```java
import static org.junit.Assert.*;

@Test
public void testAddition() {
    int result = add(2, 3);
    assertEquals(5, result);
}

```
## 14.  If you have developed a new feature, how many types of tests for this feature? and what kind of tests are written by you? what is the purpose of each type of tests?

1. **Unit Test** -By me
    - **Purpose**: To verify that individual units or components of the software work as intended. These tests focus on a single "unit" of code, usually a function or method, and are meant to test its behavior in isolation.
    - **Written by**: Developers.
    - **Example**: Testing a function that calculates the total price of items in a shopping cart.

2. **Integration Test** -Might by me
    - **Purpose**: To ensure that different units or components of the software work together correctly. These tests are used to find issues in the interaction between integrated units.
    - **Written by**: Developers or QA engineers.
    - **Example**: Testing the interaction between the shopping cart and the payment gateway.

3. **Regression Test** -Might by me
    - **Purpose**: To verify that new code changes have not adversely affected existing functionality. These tests are run after any changes to the codebase to ensure that previously working features still function correctly.
    - **Written by**: Developers or QA engineers.
    - **Example**: Running existing test suites to ensure that the addition of the new feature hasn't broken any other parts of the application.

4. **Performance Test**
    - **Purpose**: To determine how the new feature performs under various conditions, including speed, responsiveness, and stability. This helps ensure the feature meets performance criteria.
    - **Written by**: Performance engineers or QA engineers.
    - **Example**: Testing the load time and response time of the shopping cart feature under different levels of user load.

5. **Stress Test**
    - **Purpose**: To evaluate how the new feature behaves under extreme conditions, such as high traffic or data loads. This helps identify the breaking point of the system.
    - **Written by**: Performance engineers or QA engineers.
    - **Example**: Simulating a very high number of concurrent users trying to check out their carts simultaneously.

6. **User Acceptance Test (UAT)**
    - **Purpose**: To ensure that the new feature meets the business requirements and is ready for release from the end-user perspective. This involves real users testing the feature to validate its functionality and usability.
    - **Written by**: Business analysts, stakeholders, or end-users.
    - **Example**: Having a group of users test the new shopping cart feature to ensure it meets their needs and works as expected.

## 15.  Add unit test for CommentServiceImpl, the coverage should be 100%.
See [CommentServiceTest.java](..%2FCoding%2Fredbook%2Fsrc%2Ftest%2Fjava%2Fcom%2Fchuwa%2Fredbook%2FCommentServiceTest.java)
![testsCSI.png](supportingImages%2FtestsCSI.png)
## 16.  write Integration tests for PostController. The tests should cover all scenarios.
See [PostControllerIntegrationTest.java](..%2FCoding%2Fredbook%2Fsrc%2Ftest%2Fjava%2Fcom%2Fchuwa%2Fredbook%2FPostControllerIntegrationTest.java)