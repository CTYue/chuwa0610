# Homework47 Testing

### 2. what is selenium?

Selenium is an open-source tool for automating web browsers. It is primarily used for testing web applications and supports multiple programming languages like Java, Python, and C#. With Webdriver you can programmatically control a web browser.

**Simulate User Actions**: Selenium helps with user behavior simulation by allowing you to automate interactions with a web application. You can program Selenium to perform tasks like clicking buttons, entering text in forms, navigating through pages, selecting dropdown options, and other typical user interactions.

**Automate Testing**: Selenium can run tests automatically, simulating user behavior across different browsers and environments.

**Cross-Browser Testing**: Selenium WebDriver supports multiple browsers, enabling you to ensure your application behaves consistently for all users, regardless of their browser choice.

**Repetition and Scalability**: You can repeat the same test across different scenarios, or scale up to run tests in parallel using Selenium Grid, speeding up the testing process.

### 3. what is cucumber?

Cucumber is a tool used for Behavior-Driven Development (BDD). Cucumber allows you to write test scenarios in plain language that everyone can understand, regardless of their technical expertise. These scenarios describe how a system should behave in specific situations.

### 4. what is JMeter?

JMeter is used for performance testing and load testing of web applications. It helps simulate a heavy load on servers, networks, or objects to test their strength and analyze overall performance under various conditions. 

### 5. What is the life circle of Junit？

**Test Class Instantiation**: A new instance of the test class is created for each test method.

**Setup Phase**:

- @BeforeAll: Runs once before all tests; used for one-time setup.
- @BeforeEach: Runs before each test; sets up test-specific conditions.

**Test Execution**:

- @Test: The test methods are executed, containing assertions to verify expected outcomes.

**Teardown Phase**:

- @AfterEach: Runs after each test; cleans up resources.
- @AfterAll: Runs once after all tests; final cleanup.

### 6. Should @BeforeAll method  be Class level(static)?

Yes, the `@BeforeAll` method in JUnit should be at the class level and must be static.

 `@BeforeAll` methods are intended to run once before any of the test methods in the test class are executed. Since JUnit creates a new instance of the test class for each test method, making the `@BeforeAll` method static ensures that it is only executed once, regardless of the number of test instances created.

### 7. What is Mockito? and what is its limitations? what kind of tools can give help?

**Mockito** is a Java framework for creating mock objects in unit tests, allowing you to simulate and control dependencies. It helps isolate the unit under test by mocking its interactions with other components.

### Limitations:

1. **Cannot Mock Final Classes/Methods**: Limited in mocking final classes or methods.
2. **Private Methods**: Does not support mocking private methods directly.
3. **Static Methods**: Cannot mock static methods by default (with some exceptions in recent versions).
4. **Complex Configurations**: Can be cumbersome for complex dependencies.
5. **Stateful Interactions**: Less effective for tests requiring state tracking over multiple interactions.

### Complementary Tools:

- **PowerMock**: For mocking static methods, final classes, and private methods.
- **JUnit**: For structuring and running tests.
- **Spring Test**: For testing Spring applications.

### 8. What is @Mock and what is @InjectMocks?

**`@Mock`**: Used to create and inject mock instances of a class or interface in tests. These mocks simulate the behavior of real objects for isolated testing.

**`@InjectMocks`**: Used to automatically inject the mocks created with `@Mock` into the class being tested. It sets up the dependencies of the class under test by injecting the mock objects.

### 9. What is the stubbing (define behaviors)?

**Stubbing** defines how mock objects should behave by specifying what values they return or what actions they perform when certain methods are called. 

- **Define Method Behavior**: Use `when` to specify which method on the mock object should return a particular value or perform a certain action.

- **Return Values**: Use `thenReturn` to define what value should be returned when the method is called.

- **Throw Exceptions**: Use `thenThrow` to specify that a method should throw an exception when called.

- **Do Actions**: Use `doAnswer` or `doNothing` to define custom actions or do nothing when a method is called.

```java
import static org.mockito.Mockito.*;

public class ExampleTest {
    @Mock
    List<String> mockList;

    @Test
    void testMocking() {
        when(mockList.size()).thenReturn(10);  // Stubbing size() to return 10
        when(mockList.get(0)).thenThrow(new RuntimeException());  // Stubbing get(0) to throw an exception

        // Use mockList in tests
    }
}

```

### 10. What is Mockito Argument Matchers?

**Mockito Argument Matchers** are used to specify flexible conditions for method arguments when stubbing or verifying interactions with mock objects. They allow you to match arguments based on conditions rather than exact values.

`any()`: Matches any value.

`eq(value)`: Matches the exact value.

`isNull()`: Matches `null`.

`startsWith(prefix)`: Matches strings that start with a given prefix.

### 11. What is Hamcrest Matchers?

**Hamcrest Matchers** is a library used for writing expressive and readable assertions in tests. It provides a set of pre-defined matchers and allows you to create custom matchers for more complex conditions.

**Fluent Syntax**: Enables writing assertions in a natural language style.

**Reusable Matchers**: Provides a variety of matchers for different types of assertions, such as `equalTo`, `containsString`, `greaterThan`, and more.

**Custom Matchers**: Allows creating your own matchers for specific needs.

```java
@Test
void testUsingHamcrest() {
    String actual = "Hello, world!";
    assertThat(actual, startsWith("Hello"));  // Asserts that the string starts with "Hello"
    assertThat(actual, containsString("world"));  // Asserts that the string contains "world"
}
```

### 12. Do you know @spy? What is difference between @spy and @Mock?

`@Spy` and `@Mock` are annotations used in Mockito for creating mock objects. 

**@Mock**

- **Purpose**: Creates a mock instance of a class or interface. Mocks provide default behavior and can be configured to return specific values or throw exceptions when methods are called.
- **Behavior**: All methods are stubbed by default and return default values (e.g., `null`, `0`, `false`).
- **Usage**: Ideal for replacing complex dependencies with simple mocks in tests.

**@Spy**

- **Purpose**: Creates a spy instance of a class. Spies are partial mocks that wrap real instances, allowing you to call real methods while also stubbing specific methods.
- **Behavior**: By default, all methods call the real implementation unless explicitly stubbed. This means you can use a real object's behavior in addition to customizing it for the test.
- **Usage**: Useful when you want to verify interactions with real methods or change only specific behaviors while keeping the rest of the object’s functionality.

### 13. What is assertion?

An assertion is a statement used in testing to verify that a particular condition holds true. Assertions are used to check if the actual results of code match the expected results. If an assertion fails, it indicates that there is a problem with the code being tested.

### 14. If you have developed a new feature, how many type of tests for this feature? and what kind of tests are written by you? what is the purpose of each type of tests?

 **Unit Tests**

- **Purpose**: Validate the correctness of individual components or methods in isolation from the rest of the application.
- **Focus**: Test the functionality of a single class or method, ensuring it behaves as expected with various inputs.
- **Example**: Testing a method that calculates discounts based on input values.

**Integration Tests**

- **Purpose**: Ensure that different components or services work together correctly.
- **Focus**: Test the interaction between multiple components, such as database integration or API endpoints.
- **Example**: Testing how a service interacts with a database or how different microservices communicate.

**Functional Tests**

- **Purpose**: Verify that the feature meets the specified requirements and behaves correctly from a user perspective.
- **Focus**: Test end-to-end functionality to ensure the feature works as intended in real-world scenarios.
- **Example**: Testing a user login feature to ensure that the login process works correctly from the user's perspective.

**End-to-End (E2E) Tests**

- **Purpose**: Validate the complete flow of the application, from the user interface through to the backend and database.
- **Focus**: Test the entire application flow, including user interactions and data persistence.
- **Example**: Testing a user registration process that involves filling out a form, submitting it, and verifying that the user is created in the database.

**Acceptance Tests**

- **Purpose**: Ensure that the feature meets the acceptance criteria defined by stakeholders or product owners.
- **Focus**: Validate that the feature aligns with business requirements and user expectations.
- **Example**: Testing if a newly implemented search feature returns relevant results as defined by user stories.

**Performance Tests**

- **Purpose**: Assess the performance characteristics of the feature under load.
- **Focus**: Test how the feature performs with different volumes of data or traffic to ensure it meets performance requirements.
- **Example**: Testing how a search feature performs with a large dataset or high number of concurrent users.

**Security Tests**

- **Purpose**: Identify vulnerabilities and ensure that the feature adheres to security standards.
- **Focus**: Test for potential security issues such as authentication, authorization, and data protection.
- **Example**: Testing if the feature properly handles user permissions and prevents unauthorized access.

**Usability Tests**

- **Purpose**: Evaluate the user experience and ensure the feature is user-friendly.
- **Focus**: Test the ease of use and intuitiveness of the feature from a user's perspective.
- **Example**: Observing users interacting with a new feature to identify any usability issues or areas for improvement.